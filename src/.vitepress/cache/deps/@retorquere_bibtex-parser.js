import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/@unified-latex/unified-latex-util-print-raw/index.cjs
var require_unified_latex_util_print_raw = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-print-raw/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var linebreak = Symbol("linebreak");
    var ESCAPE = "\\";
    function _printRaw(node) {
      if (typeof node === "string") {
        return [node];
      }
      if (Array.isArray(node)) {
        return [].concat(
          ...node.map((n) => _printRaw(n))
        );
      }
      let argsString, escape;
      switch (node.type) {
        case "root":
          return _printRaw(node.content);
        case "argument":
          return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
          let suffix = node.suffixParbreak ? "" : linebreak;
          let leadingWhitespace = "";
          if (node.sameline && node.leadingWhitespace) {
            leadingWhitespace = " ";
          }
          if (node.sameline) {
            return [
              leadingWhitespace,
              "%",
              ..._printRaw(node.content),
              suffix
            ];
          }
          return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
          let env = _printRaw(node.env);
          let envStart = [ESCAPE + "begin{", ...env, "}"];
          let envEnd = [ESCAPE + "end{", ...env, "}"];
          argsString = node.args == null ? [] : _printRaw(node.args);
          return [
            ...envStart,
            ...argsString,
            ..._printRaw(node.content),
            ...envEnd
          ];
        case "displaymath":
          return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
          return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
          return ["$", ..._printRaw(node.content), "$"];
        case "macro":
          argsString = node.args == null ? [] : _printRaw(node.args);
          escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
          return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
          return [linebreak, linebreak];
        case "string":
          return [node.content];
        case "verb":
          return [
            ESCAPE,
            node.env,
            node.escape,
            ..._printRaw(node.content),
            node.escape
          ];
        case "whitespace":
          return [" "];
        default:
          console.warn(
            "Cannot find render for node ",
            node,
            `(of type ${typeof node})`
          );
          return ["" + node];
      }
    }
    function printRaw(node, options) {
      const asArray = options != null ? options.asArray : false;
      const printedTokens = _printRaw(node);
      if (asArray) {
        return printedTokens;
      }
      return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
    }
    exports.linebreak = linebreak;
    exports.printRaw = printRaw;
  }
});

// node_modules/@unified-latex/unified-latex-util-match/index.cjs
var require_unified_latex_util_match = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-match/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilPrintRaw = require_unified_latex_util_print_raw();
    function createMacroMatcher(macros) {
      const macrosHash = Array.isArray(macros) ? macros.length > 0 ? typeof macros[0] === "string" ? Object.fromEntries(
        macros.map((macro2) => {
          if (typeof macro2 !== "string") {
            throw new Error("Wrong branch of map function");
          }
          return [macro2, {}];
        })
      ) : Object.fromEntries(
        macros.map((macro2) => {
          if (typeof macro2 === "string") {
            throw new Error("Wrong branch of map function");
          }
          if (macro2.escapeToken != null) {
            return [
              macro2.content,
              { escapeToken: macro2.escapeToken }
            ];
          }
          return [macro2.content, {}];
        })
      ) : {} : macros;
      return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
          return false;
        }
        const spec = macrosHash[node.content];
        if (!spec) {
          return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
          return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
        }
        return true;
      };
    }
    function createEnvironmentMatcher(macros) {
      const environmentsHash = Array.isArray(macros) ? Object.fromEntries(
        macros.map((str) => {
          return [str, {}];
        })
      ) : macros;
      return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
          return false;
        }
        const envName = unifiedLatexUtilPrintRaw.printRaw(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
          return false;
        }
        return true;
      };
    }
    var match = {
      macro(node, macroName) {
        if (node == null) {
          return false;
        }
        return node.type === "macro" && (macroName == null || node.content === macroName);
      },
      anyMacro(node) {
        return match.macro(node);
      },
      environment(node, envName) {
        if (node == null) {
          return false;
        }
        return (node.type === "environment" || node.type === "mathenv") && (envName == null || unifiedLatexUtilPrintRaw.printRaw(node.env) === envName);
      },
      anyEnvironment(node) {
        return match.environment(node);
      },
      comment(node) {
        if (node == null) {
          return false;
        }
        return node.type === "comment";
      },
      parbreak(node) {
        if (node == null) {
          return false;
        }
        return node.type === "parbreak";
      },
      whitespace(node) {
        if (node == null) {
          return false;
        }
        return node.type === "whitespace";
      },
      /**
       * Matches whitespace or a comment with leading whitespace.
       */
      whitespaceLike(node) {
        if (node == null) {
          return false;
        }
        return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
      },
      string(node, value) {
        if (node == null) {
          return false;
        }
        return node.type === "string" && (value == null || node.content === value);
      },
      anyString(node) {
        return match.string(node);
      },
      group(node) {
        if (node == null) {
          return false;
        }
        return node.type === "group";
      },
      argument(node) {
        if (node == null) {
          return false;
        }
        return node.type === "argument";
      },
      blankArgument(node) {
        if (!match.argument(node)) {
          return false;
        }
        return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
      },
      math(node) {
        if (node == null) {
          return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
      },
      createMacroMatcher,
      createEnvironmentMatcher
    };
    var {
      anyEnvironment,
      anyMacro,
      anyString,
      argument,
      blankArgument,
      comment,
      environment,
      group,
      macro,
      math,
      parbreak,
      string,
      whitespace
    } = match;
    exports.anyEnvironment = anyEnvironment;
    exports.anyMacro = anyMacro;
    exports.anyString = anyString;
    exports.argument = argument;
    exports.blankArgument = blankArgument;
    exports.comment = comment;
    exports.environment = environment;
    exports.group = group;
    exports.macro = macro;
    exports.match = match;
    exports.math = math;
    exports.parbreak = parbreak;
    exports.string = string;
    exports.whitespace = whitespace;
  }
});

// node_modules/@unified-latex/unified-latex-util-visit/index.cjs
var require_unified_latex_util_visit = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-visit/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilMatch = require_unified_latex_util_match();
    function listMathChildren(node) {
      const NULL_RETURN = { enter: [], leave: [] };
      if (Array.isArray(node)) {
        return NULL_RETURN;
      }
      if (unifiedLatexUtilMatch.match.math(node)) {
        return { enter: ["content"], leave: [] };
      }
      const renderInfo = node._renderInfo || {};
      if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
      }
      if (unifiedLatexUtilMatch.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
          return { enter: ["args"], leave: [] };
        } else if (renderInfo.inMathMode === false) {
          return { enter: [], leave: ["args"] };
        }
      }
      if (unifiedLatexUtilMatch.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
          return { enter: ["content"], leave: [] };
        } else {
          return { enter: [], leave: ["content"] };
        }
      }
      return NULL_RETURN;
    }
    var CONTINUE = Symbol("continue");
    var SKIP = Symbol("skip");
    var EXIT = Symbol("exit");
    var DEFAULT_CONTEXT = {
      inMathMode: false,
      hasMathModeAncestor: false
    };
    function visit(tree, visitor, options) {
      const {
        startingContext = DEFAULT_CONTEXT,
        test = () => true,
        includeArrays = false
      } = options || {};
      let enter;
      let leave;
      if (typeof visitor === "function") {
        enter = visitor;
      } else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
      }
      walk(tree, {
        key: void 0,
        index: void 0,
        parents: [],
        containingArray: void 0,
        context: { ...startingContext }
      });
      function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays ? test(node, { key, index, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest ? toResult(
          enter(node, {
            key,
            index,
            parents,
            context,
            containingArray
          })
        ) : [CONTINUE];
        if (result[0] === EXIT) {
          return result;
        }
        if (result[0] === SKIP) {
          return leave && nodePassesTest ? toResult(
            leave(node, {
              key,
              index,
              parents,
              context,
              containingArray
            })
          ) : result;
        }
        if (Array.isArray(node)) {
          for (let index2 = 0; index2 > -1 && index2 < node.length; index2++) {
            const item = node[index2];
            const result2 = walk(item, {
              key,
              index: index2,
              parents,
              context,
              containingArray: node
            });
            if (result2[0] === EXIT) {
              return result2;
            }
            if (typeof result2[1] === "number") {
              index2 = result2[1] - 1;
            }
          }
        } else {
          let childProps = ["content", "args"];
          switch (node.type) {
            case "macro":
              childProps = ["args"];
              break;
            case "comment":
            case "string":
            case "verb":
            case "verbatim":
              childProps = [];
              break;
          }
          const mathModeProps = listMathChildren(node);
          for (const key2 of childProps) {
            const value = node[key2];
            const grandparents = [node].concat(parents);
            if (value == null) {
              continue;
            }
            const newContext = { ...context };
            if (mathModeProps.enter.includes(key2)) {
              newContext.inMathMode = true;
              newContext.hasMathModeAncestor = true;
            } else if (mathModeProps.leave.includes(key2)) {
              newContext.inMathMode = false;
            }
            const result2 = walk(value, {
              key: key2,
              index: void 0,
              parents: grandparents,
              context: newContext,
              containingArray: void 0
            });
            if (result2[0] === EXIT) {
              return result2;
            }
          }
        }
        return leave && nodePassesTest ? toResult(
          leave(node, {
            key,
            index,
            parents,
            context,
            containingArray
          })
        ) : result;
      }
    }
    function toResult(value) {
      if (value == null) {
        return [CONTINUE];
      }
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE, value];
      }
      return [value];
    }
    exports.CONTINUE = CONTINUE;
    exports.EXIT = EXIT;
    exports.SKIP = SKIP;
    exports.visit = visit;
  }
});

// node_modules/@unified-latex/unified-latex-util-trim/index.cjs
var require_unified_latex_util_trim = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-trim/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilMatch = require_unified_latex_util_match();
    var unifiedLatexUtilVisit = require_unified_latex_util_visit();
    function trim(nodes) {
      if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
      }
      const { trimmedStart } = trimStart(nodes);
      const { trimmedEnd } = trimEnd(nodes);
      return { trimmedStart, trimmedEnd };
    }
    function trimStart(nodes) {
      const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
      nodes.splice(0, start);
      for (const leadingToken of nodes) {
        if (!unifiedLatexUtilMatch.match.comment(leadingToken)) {
          break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
          leadingToken.leadingWhitespace = false;
        }
        if (start > 0 && leadingToken.sameline) {
          leadingToken.sameline = false;
        }
      }
      return { trimmedStart: start };
    }
    function trimEnd(nodes) {
      const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
      nodes.splice(nodes.length - end, end);
      for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!unifiedLatexUtilMatch.match.comment(trailingToken)) {
          break;
        }
        delete trailingToken.suffixParbreak;
        if (unifiedLatexUtilMatch.match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
          trailingToken.leadingWhitespace = false;
        }
      }
      return { trimmedEnd: end };
    }
    function amountOfLeadingAndTrailingWhitespace(ast) {
      let start = 0;
      let end = 0;
      for (const node of ast) {
        if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.parbreak(node)) {
          start++;
        } else {
          break;
        }
      }
      if (start === ast.length) {
        return { start, end: 0 };
      }
      for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.parbreak(node)) {
          end++;
        } else {
          break;
        }
      }
      return { start, end };
    }
    var unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
      return (tree) => {
        unifiedLatexUtilVisit.visit(tree, (node) => {
          if (!(unifiedLatexUtilMatch.match.math(node) || unifiedLatexUtilMatch.match.anyEnvironment(node))) {
            return;
          }
          let firstNode = node.content[0];
          if (unifiedLatexUtilMatch.match.comment(firstNode) && firstNode.sameline) {
            firstNode.suffixParbreak = false;
            trimEnd(node.content);
            const { trimmedStart } = trimStart(node.content.slice(1));
            node.content.splice(1, trimmedStart);
          } else {
            trim(node.content);
          }
        });
      };
    };
    var unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
      return (tree) => {
        trim(tree.content);
      };
    };
    function hasWhitespaceEquivalent(nodes) {
      let start = false;
      let end = false;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (unifiedLatexUtilMatch.match.comment(node)) {
          if (node.leadingWhitespace) {
            start = true;
            break;
          }
          continue;
        }
        if (unifiedLatexUtilMatch.match.whitespace(node)) {
          start = true;
        }
        break;
      }
      for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (unifiedLatexUtilMatch.match.comment(node)) {
          if (node.leadingWhitespace) {
            end = true;
            break;
          }
          continue;
        }
        if (unifiedLatexUtilMatch.match.whitespace(node)) {
          end = true;
        }
        break;
      }
      return { start, end };
    }
    exports.hasWhitespaceEquivalent = hasWhitespaceEquivalent;
    exports.trim = trim;
    exports.trimEnd = trimEnd;
    exports.trimStart = trimStart;
    exports.unifiedLatexTrimEnvironmentContents = unifiedLatexTrimEnvironmentContents;
    exports.unifiedLatexTrimRoot = unifiedLatexTrimRoot;
  }
});

// node_modules/@unified-latex/unified-latex-util-split/index.cjs
var require_unified_latex_util_split = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-split/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilMatch = require_unified_latex_util_match();
    function splitOnCondition(nodes, splitFunc = () => false, options) {
      if (!Array.isArray(nodes)) {
        throw new Error(`Can only split an Array, not ${nodes}`);
      }
      const { onlySplitOnFirstOccurrence = false } = options || {};
      const splitIndices = [];
      for (let i = 0; i < nodes.length; i++) {
        if (splitFunc(nodes[i])) {
          splitIndices.push(i);
          if (onlySplitOnFirstOccurrence) {
            break;
          }
        }
      }
      if (splitIndices.length === 0) {
        return { segments: [nodes], separators: [] };
      }
      let separators = splitIndices.map((i) => nodes[i]);
      let segments = splitIndices.map((splitEnd, i) => {
        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
        return nodes.slice(splitStart, splitEnd);
      });
      segments.push(
        nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
      );
      return { segments, separators };
    }
    function splitOnMacro(ast, macroName) {
      if (typeof macroName === "string") {
        macroName = [macroName];
      }
      if (!Array.isArray(macroName)) {
        throw new Error("Type coercion failed");
      }
      const isSeparator = unifiedLatexUtilMatch.match.createMacroMatcher(macroName);
      const { segments, separators } = splitOnCondition(ast, isSeparator);
      return { segments, macros: separators };
    }
    function unsplitOnMacro({
      segments,
      macros
    }) {
      if (segments.length === 0) {
        console.warn("Trying to join zero segments");
        return [];
      }
      if (segments.length !== macros.length + 1) {
        console.warn(
          "Mismatch between lengths of macros and segments when trying to unsplit"
        );
      }
      let ret = segments[0];
      for (let i = 0; i < macros.length; i++) {
        ret = ret.concat(macros[i]).concat(segments[i + 1]);
      }
      return ret;
    }
    function arrayJoin(array, sep) {
      return array.flatMap((item, i) => {
        if (i === 0) {
          return item;
        }
        if (Array.isArray(sep)) {
          return [...sep, ...item];
        } else {
          return [sep, ...item];
        }
      });
    }
    exports.arrayJoin = arrayJoin;
    exports.splitOnCondition = splitOnCondition;
    exports.splitOnMacro = splitOnMacro;
    exports.unsplitOnMacro = unsplitOnMacro;
  }
});

// node_modules/@unified-latex/unified-latex-util-replace/index.cjs
var require_unified_latex_util_replace = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-replace/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilVisit = require_unified_latex_util_visit();
    var unifiedLatexUtilMatch = require_unified_latex_util_match();
    var unifiedLatexUtilTrim = require_unified_latex_util_trim();
    var unifiedLatexUtilSplit = require_unified_latex_util_split();
    function replaceNode(ast, visitor) {
      unifiedLatexUtilVisit.visit(ast, {
        leave: (node, info) => {
          let replacement = visitor(node, info);
          if (typeof replacement === "undefined" || replacement === node) {
            return;
          }
          if (!info.containingArray || info.index == null) {
            throw new Error(
              "Trying to replace node, but cannot find containing array"
            );
          }
          if (replacement === null || Array.isArray(replacement) && replacement.length === 0) {
            info.containingArray.splice(info.index, 1);
            return info.index;
          }
          if (!Array.isArray(replacement)) {
            replacement = [replacement];
          }
          info.containingArray.splice(info.index, 1, ...replacement);
          return info.index + replacement.length;
        }
      });
    }
    function firstSignificantNode(nodes, parbreaksAreInsignificant) {
      const index = firstSignificantNodeIndex(nodes, parbreaksAreInsignificant);
      if (index == null) {
        return null;
      }
      return nodes[index];
    }
    function lastSignificantNode(nodes, parbreaksAreInsignificant) {
      const index = lastSignificantNodeIndex(nodes, parbreaksAreInsignificant);
      if (index == null) {
        return null;
      }
      return nodes[index];
    }
    function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) || parbreaksAreInsignificant && unifiedLatexUtilMatch.match.parbreak(node)) {
          continue;
        }
        return i;
      }
      return void 0;
    }
    function firstSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) || parbreaksAreInsignificant && unifiedLatexUtilMatch.match.parbreak(node)) {
          continue;
        }
        return i;
      }
      return void 0;
    }
    function isSpaceLike(node) {
      return unifiedLatexUtilMatch.match.whitespace(node) || unifiedLatexUtilMatch.match.comment(node) && Boolean(node.leadingWhitespace);
    }
    function joinWithoutExcessWhitespace(head, tail) {
      if (tail.length === 0) {
        return;
      }
      if (head.length === 0) {
        head.push(...tail);
        return;
      }
      const headEnd = head[head.length - 1];
      const tailStart = tail[0];
      if (unifiedLatexUtilMatch.match.whitespace(headEnd) && unifiedLatexUtilMatch.match.whitespace(tailStart)) {
        head.push(...tail.slice(1));
        return;
      }
      if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
        if (unifiedLatexUtilMatch.match.whitespace(headEnd) && unifiedLatexUtilMatch.match.comment(tailStart)) {
          const comment2 = {
            type: "comment",
            content: tailStart.content,
            sameline: true,
            leadingWhitespace: true
          };
          tail = tail.slice(1);
          unifiedLatexUtilTrim.trimStart(tail);
          head.pop();
          head.push(comment2, ...tail);
          return;
        }
        head.push(...tail);
        return;
      }
      if (unifiedLatexUtilMatch.match.comment(headEnd) && unifiedLatexUtilMatch.match.comment(tailStart)) {
        if (tailStart.leadingWhitespace || tailStart.sameline) {
          head.push(
            { type: "comment", content: tailStart.content },
            ...tail.slice(1)
          );
          return;
        }
        head.push(...tail);
        return;
      }
      let comment = unifiedLatexUtilMatch.match.comment(headEnd) ? headEnd : tailStart;
      if (!unifiedLatexUtilMatch.match.comment(comment)) {
        throw new Error(
          `Expected a comment but found ${JSON.stringify(comment)}`
        );
      }
      if (!comment.leadingWhitespace || !comment.sameline) {
        comment = {
          type: "comment",
          content: comment.content,
          leadingWhitespace: true,
          sameline: true
        };
      }
      head.pop();
      head.push(comment, ...tail.slice(1));
    }
    function wrapSignificantContent(content, wrapper) {
      let hoistUntil = 0;
      let hoistAfter = content.length;
      for (let i = 0; i < content.length; i++) {
        if (unifiedLatexUtilMatch.match.whitespace(content[i]) || unifiedLatexUtilMatch.match.comment(content[i])) {
          hoistUntil = i + 1;
          continue;
        }
        break;
      }
      for (let j = content.length - 1; j >= 0; j--) {
        if (unifiedLatexUtilMatch.match.whitespace(content[j]) || unifiedLatexUtilMatch.match.comment(content[j])) {
          hoistAfter = j;
          continue;
        }
        break;
      }
      if (hoistUntil === 0 && hoistAfter === content.length) {
        return ensureArray(wrapper(content));
      }
      const frontMatter = content.slice(0, hoistUntil);
      const middle = content.slice(hoistUntil, hoistAfter);
      const backMatter = content.slice(hoistAfter, content.length);
      return frontMatter.concat(wrapper(middle), backMatter);
    }
    function ensureArray(x) {
      if (!Array.isArray(x)) {
        return [x];
      }
      return x;
    }
    function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
      while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
        nodes.pop();
        unifiedLatexUtilTrim.trimEnd(nodes);
      }
      const foundStreamingCommands = [];
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (isStreamingCommand(node)) {
          const wrapper = (content) => replacer(content, node);
          let tail = nodes.slice(i + 1);
          unifiedLatexUtilTrim.trimStart(tail);
          tail = wrapSignificantContent(tail, wrapper);
          foundStreamingCommands.push(node);
          nodes.splice(i);
          joinWithoutExcessWhitespace(nodes, tail);
        }
      }
      return { foundStreamingCommands };
    }
    function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer, options) {
      const content = group.content;
      let popFromGroup = isStreamingCommand(firstSignificantNode(content));
      let innerProcessed = replaceStreamingCommand(
        content,
        isStreamingCommand,
        replacer,
        options
      );
      if (innerProcessed.length === 0) {
        return [];
      }
      if (popFromGroup) {
        return innerProcessed;
      } else {
        return [{ type: "group", content: innerProcessed }];
      }
    }
    function replaceStreamingCommand(ast, isStreamingCommand, replacer, options) {
      if (typeof isStreamingCommand !== "function") {
        throw new Error(
          `'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`
        );
      }
      const {
        macrosThatBreakPars = [
          "part",
          "chapter",
          "section",
          "subsection",
          "subsubsection",
          "vspace",
          "smallskip",
          "medskip",
          "bigskip",
          "hfill"
        ],
        environmentsThatDontBreakPars = []
      } = options || {};
      let processedContent = [];
      if (unifiedLatexUtilMatch.match.group(ast)) {
        processedContent = replaceStreamingCommandInGroup(
          ast,
          isStreamingCommand,
          replacer
        );
      }
      if (Array.isArray(ast)) {
        const nodes = ast;
        let scanIndex = nodes.length;
        let sliceIndex = scanIndex;
        while (scanIndex > 0 && (isStreamingCommand(nodes[scanIndex - 1]) || unifiedLatexUtilMatch.match.whitespace(nodes[scanIndex - 1]))) {
          scanIndex--;
          if (isStreamingCommand(nodes[scanIndex])) {
            sliceIndex = scanIndex;
          }
        }
        if (sliceIndex !== nodes.length) {
          nodes.splice(sliceIndex);
        }
        const macroThatBreaks = unifiedLatexUtilMatch.match.createMacroMatcher(macrosThatBreakPars);
        const envThatDoesntBreak = unifiedLatexUtilMatch.match.createEnvironmentMatcher(
          environmentsThatDontBreakPars
        );
        const isPar = (node) => unifiedLatexUtilMatch.match.parbreak(node) || unifiedLatexUtilMatch.match.macro(node, "par") || macroThatBreaks(node) || unifiedLatexUtilMatch.match.environment(node) && !envThatDoesntBreak(node) || node.type === "displaymath";
        const splitByPar = unifiedLatexUtilSplit.splitOnCondition(nodes, isPar);
        splitByPar.separators = splitByPar.separators.map(
          (sep) => unifiedLatexUtilMatch.match.macro(sep, "par") ? { type: "parbreak" } : sep
        );
        const replacers = [];
        let segments = splitByPar.segments.map((segment) => {
          if (segment.length === 0) {
            return segment;
          }
          function applyAccumulatedReplacers(nodes2) {
            if (replacers.length === 0) {
              return nodes2;
            }
            return wrapSignificantContent(
              nodes2,
              composeReplacers(replacers)
            );
          }
          const { foundStreamingCommands } = replaceStreamingCommandInArray(
            segment,
            isStreamingCommand,
            replacer
          );
          const ret = applyAccumulatedReplacers(segment);
          foundStreamingCommands.forEach((macro) => {
            replacers.push((nodes2) => {
              const ret2 = replacer(nodes2, macro);
              if (!Array.isArray(ret2)) {
                return [ret2];
              }
              return ret2;
            });
          });
          return ret;
        });
        if (segments.length > 1) {
          segments.forEach((segment, i) => {
            if (i === 0) {
              unifiedLatexUtilTrim.trimEnd(segment);
            } else if (i === segments.length - 1) {
              unifiedLatexUtilTrim.trimStart(segment);
            } else {
              unifiedLatexUtilTrim.trim(segment);
            }
          });
        }
        processedContent = unifiedLatexUtilSplit.unsplitOnMacro({
          segments,
          macros: splitByPar.separators
        });
      }
      return processedContent;
    }
    function composeReplacers(replacers) {
      if (replacers.length === 0) {
        throw new Error("Cannot compose zero replacement functions");
      }
      return (nodes) => {
        let ret = nodes;
        for (let i = 0; i < replacers.length; i++) {
          const func = replacers[i];
          ret = func(ret);
        }
        return ret;
      };
    }
    function replaceNodeDuringVisit(replacement, info) {
      const parent = info.parents[0];
      if (!parent) {
        throw new Error(`Cannot replace node: parent not found`);
      }
      const container = parent[info.key];
      if (!Array.isArray(container)) {
        throw new Error(`Cannot replace node: containing array not found`);
      }
      if (info.index == null) {
        throw new Error(`Cannot replace node: node index undefined`);
      }
      if (!Array.isArray(replacement)) {
        container[info.index] = replacement;
      } else {
        container.splice(info.index, 1, ...replacement);
      }
    }
    var unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands2(options) {
      const { replacers = {} } = options || {};
      const isReplaceable = unifiedLatexUtilMatch.match.createMacroMatcher(replacers);
      return (tree) => {
        unifiedLatexUtilVisit.visit(
          tree,
          (group, info) => {
            if (info.context.hasMathModeAncestor || !group.content.some(isReplaceable)) {
              return;
            }
            let fixed = replaceStreamingCommand(
              group,
              isReplaceable,
              (content, command) => {
                return replacers[command.content](content, command);
              }
            );
            if (!info.containingArray || info.index == null) {
              return;
            }
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (unifiedLatexUtilMatch.match.whitespaceLike(prevToken) && unifiedLatexUtilMatch.match.whitespaceLike(fixed[0])) {
              unifiedLatexUtilTrim.trimStart(fixed);
            }
            if (unifiedLatexUtilMatch.match.whitespaceLike(nextToken) && unifiedLatexUtilMatch.match.whitespaceLike(fixed[fixed.length - 1])) {
              unifiedLatexUtilTrim.trimEnd(fixed);
            }
            replaceNodeDuringVisit(fixed, info);
          },
          { test: unifiedLatexUtilMatch.match.group }
        );
        unifiedLatexUtilVisit.visit(
          tree,
          (nodes, info) => {
            if (info.context.hasMathModeAncestor || !nodes.some(isReplaceable)) {
              return;
            }
            const replaced = replaceStreamingCommand(
              nodes,
              isReplaceable,
              (content, command) => {
                return replacers[command.content](content, command);
              }
            );
            if (replaced !== nodes) {
              nodes.length = 0;
              nodes.push(...replaced);
            }
          },
          { includeArrays: true, test: Array.isArray }
        );
      };
    };
    exports.firstSignificantNode = firstSignificantNode;
    exports.firstSignificantNodeIndex = firstSignificantNodeIndex;
    exports.lastSignificantNode = lastSignificantNode;
    exports.lastSignificantNodeIndex = lastSignificantNodeIndex;
    exports.replaceNode = replaceNode;
    exports.replaceNodeDuringVisit = replaceNodeDuringVisit;
    exports.replaceStreamingCommand = replaceStreamingCommand;
    exports.replaceStreamingCommandInGroup = replaceStreamingCommandInGroup;
    exports.unifiedLatexReplaceStreamingCommands = unifiedLatexReplaceStreamingCommands;
  }
});

// node_modules/@unified-latex/unified-latex-util-pegjs/index.cjs
var require_unified_latex_util_pegjs = __commonJS({
  "node_modules/@unified-latex/unified-latex-util-pegjs/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    var unifiedLatexUtilMatch = require_unified_latex_util_match();
    function decorateArrayForPegjs(array) {
      array.charAt = function(i) {
        return this[i];
      };
      array.charCodeAt = () => 0;
      array.substring = function(i, j) {
        return this.slice(i, j);
      };
      array.replace = function(a, b) {
        const ret = JSON.stringify(this);
        return ret.replace(a, b);
      };
      return array;
    }
    function splitStringsIntoSingleChars(nodes) {
      return nodes.flatMap(
        (node) => unifiedLatexUtilMatch.match.anyString(node) ? Array.from(node.content).map((c) => ({
          type: "string",
          content: c
        })) : node
      );
    }
    var _LatexPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
          var peg$startRuleFunction = peg$parsedocument;
          var peg$c0 = "%";
          var peg$c1 = ".";
          var peg$c2 = "verb*";
          var peg$c3 = "verb";
          var peg$c4 = "[";
          var peg$c5 = "]";
          var peg$c6 = "lstinline";
          var peg$c7 = "mintinline";
          var peg$c8 = "mint";
          var peg$c9 = "minted";
          var peg$c10 = "verbatim*";
          var peg$c11 = "verbatim";
          var peg$c12 = "filecontents*";
          var peg$c13 = "filecontents";
          var peg$c14 = "comment";
          var peg$c15 = "lstlisting";
          var peg$c16 = "(";
          var peg$c17 = ")";
          var peg$c18 = "begin";
          var peg$c19 = "end";
          var peg$c20 = "equation*";
          var peg$c21 = "equation";
          var peg$c22 = "align*";
          var peg$c23 = "align";
          var peg$c24 = "alignat*";
          var peg$c25 = "alignat";
          var peg$c26 = "gather*";
          var peg$c27 = "gather";
          var peg$c28 = "multline*";
          var peg$c29 = "multline";
          var peg$c30 = "flalign*";
          var peg$c31 = "flalign";
          var peg$c32 = "split";
          var peg$c33 = "math";
          var peg$c34 = "displaymath";
          var peg$c35 = "\\";
          var peg$c36 = "{";
          var peg$c37 = "}";
          var peg$c38 = "$";
          var peg$c39 = "&";
          var peg$c40 = "\r";
          var peg$c41 = "\n";
          var peg$c42 = "\r\n";
          var peg$c43 = "#";
          var peg$c44 = "^";
          var peg$c45 = "_";
          var peg$c46 = "\0";
          var peg$r0 = /^[^ \t\n\r]/;
          var peg$r1 = /^[ \t]/;
          var peg$r2 = /^[a-zA-Z]/;
          var peg$r3 = /^[0-9]/;
          var peg$r4 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
          var peg$e0 = peg$otherExpectation("document");
          var peg$e1 = peg$otherExpectation("math");
          var peg$e2 = peg$otherExpectation("token");
          var peg$e3 = peg$anyExpectation();
          var peg$e4 = peg$otherExpectation("parbreak");
          var peg$e5 = peg$otherExpectation("math token");
          var peg$e6 = peg$otherExpectation("nonchar token");
          var peg$e7 = peg$literalExpectation("%", false);
          var peg$e8 = peg$otherExpectation("whitespace");
          var peg$e9 = peg$otherExpectation("number");
          var peg$e10 = peg$literalExpectation(".", false);
          var peg$e11 = peg$otherExpectation("special macro");
          var peg$e12 = peg$literalExpectation("verb*", false);
          var peg$e13 = peg$literalExpectation("verb", false);
          var peg$e14 = peg$literalExpectation("[", false);
          var peg$e15 = peg$literalExpectation("]", false);
          var peg$e16 = peg$classExpectation([" ", "	", "\n", "\r"], true, false);
          var peg$e17 = peg$otherExpectation("verbatim listings");
          var peg$e18 = peg$literalExpectation("lstinline", false);
          var peg$e19 = peg$otherExpectation("verbatim minted");
          var peg$e20 = peg$literalExpectation("mintinline", false);
          var peg$e21 = peg$literalExpectation("mint", false);
          var peg$e22 = peg$otherExpectation("verbatim minted environment");
          var peg$e23 = peg$literalExpectation("minted", false);
          var peg$e24 = peg$otherExpectation("verbatim environment");
          var peg$e25 = peg$literalExpectation("verbatim*", false);
          var peg$e26 = peg$literalExpectation("verbatim", false);
          var peg$e27 = peg$literalExpectation("filecontents*", false);
          var peg$e28 = peg$literalExpectation("filecontents", false);
          var peg$e29 = peg$literalExpectation("comment", false);
          var peg$e30 = peg$literalExpectation("lstlisting", false);
          var peg$e31 = peg$otherExpectation("macro");
          var peg$e32 = peg$otherExpectation("group");
          var peg$e33 = peg$otherExpectation("environment");
          var peg$e34 = peg$otherExpectation("math environment");
          var peg$e36 = peg$literalExpectation("(", false);
          var peg$e37 = peg$literalExpectation(")", false);
          var peg$e38 = peg$literalExpectation("begin", false);
          var peg$e39 = peg$literalExpectation("end", false);
          var peg$e40 = peg$literalExpectation("equation*", false);
          var peg$e41 = peg$literalExpectation("equation", false);
          var peg$e42 = peg$literalExpectation("align*", false);
          var peg$e43 = peg$literalExpectation("align", false);
          var peg$e44 = peg$literalExpectation("alignat*", false);
          var peg$e45 = peg$literalExpectation("alignat", false);
          var peg$e46 = peg$literalExpectation("gather*", false);
          var peg$e47 = peg$literalExpectation("gather", false);
          var peg$e48 = peg$literalExpectation("multline*", false);
          var peg$e49 = peg$literalExpectation("multline", false);
          var peg$e50 = peg$literalExpectation("flalign*", false);
          var peg$e51 = peg$literalExpectation("flalign", false);
          var peg$e52 = peg$literalExpectation("split", false);
          var peg$e53 = peg$literalExpectation("math", false);
          var peg$e54 = peg$literalExpectation("displaymath", false);
          var peg$e55 = peg$otherExpectation("escape");
          var peg$e56 = peg$literalExpectation("\\", false);
          var peg$e57 = peg$literalExpectation("{", false);
          var peg$e58 = peg$literalExpectation("}", false);
          var peg$e59 = peg$literalExpectation("$", false);
          var peg$e60 = peg$literalExpectation("&", false);
          var peg$e61 = peg$otherExpectation("newline");
          var peg$e62 = peg$literalExpectation("\r", false);
          var peg$e63 = peg$literalExpectation("\n", false);
          var peg$e64 = peg$literalExpectation("\r\n", false);
          var peg$e65 = peg$literalExpectation("#", false);
          var peg$e66 = peg$literalExpectation("^", false);
          var peg$e67 = peg$literalExpectation("_", false);
          var peg$e68 = peg$literalExpectation("\0", false);
          var peg$e69 = peg$classExpectation([" ", "	"], false, false);
          var peg$e70 = peg$otherExpectation("letter");
          var peg$e71 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
          var peg$e72 = peg$otherExpectation("digit");
          var peg$e73 = peg$classExpectation([["0", "9"]], false, false);
          var peg$e74 = peg$otherExpectation("punctuation");
          var peg$e75 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
          var peg$e76 = peg$otherExpectation("full comment");
          var peg$e77 = peg$otherExpectation("comment");
          var peg$f0 = function(content) {
            return createNode("root", { content: content.flatMap((x) => x) });
          };
          var peg$f1 = function(t) {
            return t;
          };
          var peg$f2 = function(eq) {
            return createNode("inlinemath", { content: eq.flatMap((x) => x) });
          };
          var peg$f3 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f4 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f5 = function() {
            return createNode("parbreak");
          };
          var peg$f6 = function(x) {
            return x;
          };
          var peg$f7 = function(x) {
            return x;
          };
          var peg$f8 = function() {
            return createNode("macro", { content: "^", escapeToken: "" });
          };
          var peg$f9 = function() {
            return createNode("macro", { content: "_", escapeToken: "" });
          };
          var peg$f10 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f11 = function() {
            return createNode("whitespace");
          };
          var peg$f12 = function(a, b) {
            return a.join("") + "." + b.join("");
          };
          var peg$f13 = function(b) {
            return "." + b.join("");
          };
          var peg$f14 = function(a) {
            return a.join("") + ".";
          };
          var peg$f15 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f16 = function(env, e, end) {
            return end == e;
          };
          var peg$f17 = function(env, e, x) {
            return x;
          };
          var peg$f18 = function(env, e, x, end) {
            return end == e;
          };
          var peg$f19 = function(env, e, x) {
            return createNode("verb", {
              env,
              escape: e,
              content: x.join("")
            });
          };
          var peg$f20 = function(x) {
            return x;
          };
          var peg$f21 = function(x) {
            return createNode("displaymath", { content: x.flatMap((x2) => x2) });
          };
          var peg$f22 = function(x) {
            return x;
          };
          var peg$f23 = function(x) {
            return createNode("inlinemath", { content: x.flatMap((x2) => x2) });
          };
          var peg$f24 = function(x) {
            return x;
          };
          var peg$f25 = function(x) {
            return createNode("displaymath", { content: x.flatMap((x2) => x2) });
          };
          var peg$f26 = function(end) {
            return end.type === "string" && end.content === "]";
          };
          var peg$f27 = function(x) {
            return x;
          };
          var peg$f28 = function(o) {
            return [
              createNode("string", { content: "[" }),
              ...o,
              createNode("string", { content: "]" })
            ];
          };
          var peg$f29 = function(x) {
            return x;
          };
          var peg$f30 = function(v) {
            return createNode("group", {
              content: createNode("string", { content: v.join("") })
            });
          };
          var peg$f31 = function(d, end) {
            return end == d;
          };
          var peg$f32 = function(d, x) {
            return x;
          };
          var peg$f33 = function(d, v, end) {
            return end == d;
          };
          var peg$f34 = function(d, v) {
            return [
              createNode("string", { content: d }),
              createNode("string", { content: v.join("") }),
              createNode("string", { content: d })
            ];
          };
          var peg$f35 = function(macro, option, verbatim) {
            return [
              createNode("macro", { content: macro }),
              ...option || [],
              ...[].concat(verbatim)
            ];
          };
          var peg$f36 = function(macro, option, language, verbatim) {
            return [
              createNode("macro", { content: macro }),
              ...option || [],
              language,
              ...[].concat(verbatim)
            ];
          };
          var peg$f37 = function(env, option, language, end_env) {
            return compare_env({ content: [env] }, end_env);
          };
          var peg$f38 = function(env, option, language, body) {
            const content = [
              ...option || [],
              language,
              { type: "string", content: body }
            ];
            return createNode("environment", {
              env,
              content
            });
          };
          var peg$f39 = function(env, end_env) {
            return compare_env({ content: [env] }, end_env);
          };
          var peg$f40 = function(env, x) {
            return x;
          };
          var peg$f41 = function(env, body) {
            return createNode("verbatim", {
              env,
              content: body
            });
          };
          var peg$f42 = function(n) {
            return n.join("");
          };
          var peg$f43 = function(n) {
            return n;
          };
          var peg$f44 = function(m) {
            return createNode("macro", { content: m });
          };
          var peg$f45 = function(c) {
            return c;
          };
          var peg$f46 = function(x) {
            return createNode("group", { content: x.flatMap((x2) => x2) });
          };
          var peg$f47 = function(g) {
            return text().slice(1, -1);
          };
          var peg$f48 = function(env, env_comment, end_env) {
            return compare_env(env, end_env);
          };
          var peg$f49 = function(env, env_comment, x) {
            return x;
          };
          var peg$f50 = function(env, env_comment, body) {
            body = body.flatMap((x) => x);
            return createNode("environment", {
              env,
              content: env_comment ? [env_comment, ...body] : body
            });
          };
          var peg$f51 = function(env, env_comment, end_env) {
            return compare_env({ content: [env] }, end_env);
          };
          var peg$f52 = function(env, env_comment, x) {
            return x;
          };
          var peg$f53 = function(env, env_comment, body) {
            body = body.flatMap((x) => x);
            return createNode("mathenv", {
              env,
              content: env_comment ? [env_comment, ...body] : body
            });
          };
          var peg$f56 = function(e) {
            return createNode("string", { content: e });
          };
          var peg$f57 = function() {
            return createNode("string", { content: "\\" });
          };
          var peg$f58 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f59 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f60 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f61 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f62 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f63 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f64 = function(s) {
            return createNode("string", { content: s });
          };
          var peg$f65 = function() {
            return " ";
          };
          var peg$f66 = function(p) {
            return createNode("string", { content: p });
          };
          var peg$f67 = function(leading_sp, comment) {
            return createNode("comment", {
              ...comment,
              sameline: false,
              leadingWhitespace: leading_sp.length > 0
            });
          };
          var peg$f68 = function(spaces, x) {
            return createNode("comment", {
              ...x,
              sameline: true,
              leadingWhitespace: spaces.length > 0
            });
          };
          var peg$f69 = function(c) {
            return c;
          };
          var peg$f70 = function(c) {
            return { content: c.join(""), suffixParbreak: true };
          };
          var peg$f71 = function(c) {
            return c;
          };
          var peg$f72 = function(c) {
            return { content: c.join("") };
          };
          var peg$f73 = function() {
            var loc = location();
            return loc.start.column === 1;
          };
          var peg$currPos = 0;
          var peg$savedPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function text() {
            return input.substring(peg$savedPos, peg$currPos);
          }
          function location() {
            return peg$computeLocation(peg$savedPos, peg$currPos);
          }
          function peg$literalExpectation(text2, ignoreCase) {
            return { type: "literal", text: text2, ignoreCase };
          }
          function peg$classExpectation(parts, inverted, ignoreCase) {
            return { type: "class", parts, inverted, ignoreCase };
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsedocument() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsetoken();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsetoken();
            }
            peg$savedPos = s0;
            s1 = peg$f0(s1);
            s0 = s1;
            peg$silentFails--;
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
            return s0;
          }
          function peg$parsemath() {
            var s0, s1;
            peg$silentFails++;
            s0 = [];
            s1 = peg$parsemath_token();
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$parsemath_token();
            }
            peg$silentFails--;
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
            return s0;
          }
          function peg$parsetoken() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$parsespecial_macro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemacro();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefull_comment();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsegroup();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsemath_shift();
                    if (s1 !== peg$FAILED) {
                      s2 = [];
                      s3 = peg$currPos;
                      s4 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s4 = void 0;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s3 = peg$f1(s5);
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                      if (s3 !== peg$FAILED) {
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          s3 = peg$currPos;
                          s4 = peg$currPos;
                          peg$silentFails++;
                          s5 = peg$parsemath_shift();
                          peg$silentFails--;
                          if (s5 === peg$FAILED) {
                            s4 = void 0;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsemath_token();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s3 = peg$f1(s5);
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        }
                      } else {
                        s2 = peg$FAILED;
                      }
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parsemath_shift();
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f2(s2);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsealignment_tab();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseparbreak();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsemacro_parameter();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseignore();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsenumber();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsewhitespace();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsepunctuation();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$currPos;
                                    s2 = [];
                                    s3 = peg$currPos;
                                    s4 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s4 = void 0;
                                    } else {
                                      peg$currPos = s4;
                                      s4 = peg$FAILED;
                                    }
                                    if (s4 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s4 = [s4, s5];
                                        s3 = s4;
                                      } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s3;
                                      s3 = peg$FAILED;
                                    }
                                    if (s3 !== peg$FAILED) {
                                      while (s3 !== peg$FAILED) {
                                        s2.push(s3);
                                        s3 = peg$currPos;
                                        s4 = peg$currPos;
                                        peg$silentFails++;
                                        s5 = peg$parsenonchar_token();
                                        peg$silentFails--;
                                        if (s5 === peg$FAILED) {
                                          s4 = void 0;
                                        } else {
                                          peg$currPos = s4;
                                          s4 = peg$FAILED;
                                        }
                                        if (s4 !== peg$FAILED) {
                                          if (input.length > peg$currPos) {
                                            s5 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                          } else {
                                            s5 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e3);
                                            }
                                          }
                                          if (s5 !== peg$FAILED) {
                                            s4 = [s4, s5];
                                            s3 = s4;
                                          } else {
                                            peg$currPos = s3;
                                            s3 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s3;
                                          s3 = peg$FAILED;
                                        }
                                      }
                                    } else {
                                      s2 = peg$FAILED;
                                    }
                                    if (s2 !== peg$FAILED) {
                                      s1 = input.substring(s1, peg$currPos);
                                    } else {
                                      s1 = s2;
                                    }
                                    if (s1 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$f3(s1);
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsebegin_group();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseend_group();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parsemath_shift();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.length > peg$currPos) {
                                              s1 = input.charAt(peg$currPos);
                                              peg$currPos++;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$e3);
                                              }
                                            }
                                            if (s1 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$f4(s1);
                                            }
                                            s0 = s1;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            return s0;
          }
          function peg$parseparbreak() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsesp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsesp();
            }
            s3 = peg$parsenl();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = [];
                  s7 = peg$parsesp();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parsesp();
                  }
                  s7 = peg$parsenl();
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsecomment_start();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5, s6];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsesp();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsesp();
              }
              s3 = peg$parsenl();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = [];
                    s7 = peg$parsesp();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parsesp();
                    }
                    s7 = peg$parsenl();
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f5();
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            return s0;
          }
          function peg$parsemath_token() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$parsespecial_macro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemacro();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefull_comment();
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = [];
                  s2 = peg$parsewhitespace();
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parsewhitespace();
                  }
                  s2 = peg$parsegroup();
                  if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parsewhitespace();
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parsewhitespace();
                    }
                    peg$savedPos = s0;
                    s0 = peg$f6(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parsewhitespace();
                    while (s2 !== peg$FAILED) {
                      s1.push(s2);
                      s2 = peg$parsewhitespace();
                    }
                    s2 = peg$parsealignment_tab();
                    if (s2 !== peg$FAILED) {
                      s3 = [];
                      s4 = peg$parsewhitespace();
                      while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f7(s2);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$parsewhitespace();
                        while (s2 !== peg$FAILED) {
                          s1.push(s2);
                          s2 = peg$parsewhitespace();
                        }
                        s2 = peg$parsesuperscript();
                        if (s2 !== peg$FAILED) {
                          s3 = [];
                          s4 = peg$parsewhitespace();
                          while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$parsewhitespace();
                          }
                          peg$savedPos = s0;
                          s0 = peg$f8();
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = [];
                          s2 = peg$parsewhitespace();
                          while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parsewhitespace();
                          }
                          s2 = peg$parsesubscript();
                          if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$parsewhitespace();
                            while (s4 !== peg$FAILED) {
                              s3.push(s4);
                              s4 = peg$parsewhitespace();
                            }
                            peg$savedPos = s0;
                            s0 = peg$f9();
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseignore();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsewhitespace();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.length > peg$currPos) {
                                  s1 = input.charAt(peg$currPos);
                                  peg$currPos++;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e3);
                                  }
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f10(s1);
                                }
                                s0 = s1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            return s0;
          }
          function peg$parsenonchar_token() {
            var s0;
            peg$silentFails++;
            s0 = peg$parseescape();
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 37) {
                s0 = peg$c0;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parsebegin_group();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseend_group();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsemath_shift();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsealignment_tab();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsenl();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsemacro_parameter();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseignore();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsesp();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsepunctuation();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseEOF();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsenl();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsesp();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsesp();
              }
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = [];
              s3 = peg$parsesp();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsesp();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsenl();
                if (s3 !== peg$FAILED) {
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsecomment_start();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parsesp();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parsesp();
                    }
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$parsenl();
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      s2 = [s2, s3, s4, s5, s6];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = [];
                s2 = peg$parsesp();
                if (s2 !== peg$FAILED) {
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parsesp();
                  }
                } else {
                  s1 = peg$FAILED;
                }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f11();
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            return s0;
          }
          function peg$parsenumber() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsenum();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsenum();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s3 = peg$c1;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsenum();
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parsenum();
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s1 = peg$f12(s2, s4);
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c1;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsenum();
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parsenum();
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s1 = peg$f13(s3);
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = [];
                s3 = peg$parsenum();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsenum();
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s3 = peg$c1;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s1 = peg$f14(s2);
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f15(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            return s0;
          }
          function peg$parsespecial_macro() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c2) {
                s2 = peg$c2;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e12);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c3) {
                  s2 = peg$c3;
                  peg$currPos += 4;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e13);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s9 = peg$f16(s2, s3, s8);
                    if (s9) {
                      s9 = void 0;
                    } else {
                      s9 = peg$FAILED;
                    }
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s5 = peg$f17(s2, s3, s7);
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$currPos;
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s9 = peg$f16(s2, s3, s8);
                      if (s9) {
                        s9 = void 0;
                      } else {
                        s9 = peg$FAILED;
                      }
                      if (s9 !== peg$FAILED) {
                        s8 = [s8, s9];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s7 === peg$FAILED) {
                      s6 = void 0;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s5 = peg$f17(s2, s3, s7);
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                  s5 = peg$currPos;
                  if (input.length > peg$currPos) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s7 = peg$f18(s2, s3, s4, s6);
                    if (s7) {
                      s7 = void 0;
                    } else {
                      s7 = peg$FAILED;
                    }
                    if (s7 !== peg$FAILED) {
                      s6 = [s6, s7];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f19(s2, s3, s4);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseverbatim_listings();
              if (s0 === peg$FAILED) {
                s0 = peg$parseverbatim_minted();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseverbatim_minted_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseverbatim_environment();
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsebegin_display_math();
                      if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parseend_display_math();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                          s4 = void 0;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_token();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s3 = peg$f20(s5);
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          s3 = peg$currPos;
                          s4 = peg$currPos;
                          peg$silentFails++;
                          s5 = peg$parseend_display_math();
                          peg$silentFails--;
                          if (s5 === peg$FAILED) {
                            s4 = void 0;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsemath_token();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s3 = peg$f20(s5);
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        }
                        s3 = peg$parseend_display_math();
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f21(s2);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsebegin_inline_math();
                        if (s1 !== peg$FAILED) {
                          s2 = [];
                          s3 = peg$currPos;
                          s4 = peg$currPos;
                          peg$silentFails++;
                          s5 = peg$parseend_inline_math();
                          peg$silentFails--;
                          if (s5 === peg$FAILED) {
                            s4 = void 0;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsemath_token();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s3 = peg$f22(s5);
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                          while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            s5 = peg$parseend_inline_math();
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                              s4 = void 0;
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsemath_token();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s3;
                                s3 = peg$f22(s5);
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          }
                          s3 = peg$parseend_inline_math();
                          if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f23(s2);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parsemath_shift();
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parsemath_shift();
                            if (s2 !== peg$FAILED) {
                              s3 = [];
                              s4 = peg$currPos;
                              s5 = peg$currPos;
                              peg$silentFails++;
                              s6 = peg$currPos;
                              s7 = peg$parsemath_shift();
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parsemath_shift();
                                if (s8 !== peg$FAILED) {
                                  s7 = [s7, s8];
                                  s6 = s7;
                                } else {
                                  peg$currPos = s6;
                                  s6 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                              }
                              peg$silentFails--;
                              if (s6 === peg$FAILED) {
                                s5 = void 0;
                              } else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                              }
                              if (s5 !== peg$FAILED) {
                                s6 = peg$parsemath_token();
                                if (s6 !== peg$FAILED) {
                                  peg$savedPos = s4;
                                  s4 = peg$f24(s6);
                                } else {
                                  peg$currPos = s4;
                                  s4 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                              while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$currPos;
                                s5 = peg$currPos;
                                peg$silentFails++;
                                s6 = peg$currPos;
                                s7 = peg$parsemath_shift();
                                if (s7 !== peg$FAILED) {
                                  s8 = peg$parsemath_shift();
                                  if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                  } else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s6;
                                  s6 = peg$FAILED;
                                }
                                peg$silentFails--;
                                if (s6 === peg$FAILED) {
                                  s5 = void 0;
                                } else {
                                  peg$currPos = s5;
                                  s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                  s6 = peg$parsemath_token();
                                  if (s6 !== peg$FAILED) {
                                    peg$savedPos = s4;
                                    s4 = peg$f24(s6);
                                  } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s4;
                                  s4 = peg$FAILED;
                                }
                              }
                              s4 = peg$parsemath_shift();
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parsemath_shift();
                                if (s5 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s0 = peg$f25(s3);
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsemath_environment();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseenvironment();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            return s0;
          }
          function peg$parsesquare_bracket_argument() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c4;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$currPos;
              s6 = peg$parsetoken();
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f26(s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsetoken();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f27(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$currPos;
                s6 = peg$parsetoken();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s7 = peg$f26(s6);
                  if (s7) {
                    s7 = void 0;
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetoken();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f27(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c5;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f28(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseverbatim_group() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsebegin_group();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_group();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f29(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_group();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f29(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s3 = peg$parseend_group();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f30(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseverbatim_delimited_by_char() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f31(s1, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f32(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$currPos;
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s7 = peg$f31(s1, s6);
                  if (s7) {
                    s7 = void 0;
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f32(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s3 = peg$currPos;
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s5 = peg$f33(s1, s2, s4);
                if (s5) {
                  s5 = void 0;
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f34(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseverbatim_listings() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 9) === peg$c6) {
                s2 = peg$c6;
                peg$currPos += 9;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsesquare_bracket_argument();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s4 = peg$parseverbatim_group();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseverbatim_delimited_by_char();
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f35(s2, s3, s4);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            return s0;
          }
          function peg$parseverbatim_minted() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 10) === peg$c7) {
                s2 = peg$c7;
                peg$currPos += 10;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c8) {
                  s2 = peg$c8;
                  peg$currPos += 4;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e21);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsesquare_bracket_argument();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s4 = peg$parsegroup();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseverbatim_group();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseverbatim_delimited_by_char();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f36(s2, s3, s4, s5);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            return s0;
          }
          function peg$parseverbatim_minted_environment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsebegin_env();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebegin_group();
              if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c9) {
                  s3 = peg$c9;
                  peg$currPos += 6;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e23);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseend_group();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsesquare_bracket_argument();
                    if (s5 === peg$FAILED) {
                      s5 = null;
                    }
                    s6 = peg$parsegroup();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$currPos;
                      s8 = [];
                      s9 = peg$currPos;
                      s10 = peg$currPos;
                      peg$silentFails++;
                      s11 = peg$currPos;
                      s12 = peg$parseend_env();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parsegroup();
                        if (s13 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s14 = peg$f37(s3, s5, s6, s13);
                          if (s14) {
                            s14 = void 0;
                          } else {
                            s14 = peg$FAILED;
                          }
                          if (s14 !== peg$FAILED) {
                            s12 = [s12, s13, s14];
                            s11 = s12;
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s11 === peg$FAILED) {
                        s10 = void 0;
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                      if (s10 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s11 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          s10 = [s10, s11];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$currPos;
                        s10 = peg$currPos;
                        peg$silentFails++;
                        s11 = peg$currPos;
                        s12 = peg$parseend_env();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parsegroup();
                          if (s13 !== peg$FAILED) {
                            peg$savedPos = peg$currPos;
                            s14 = peg$f37(s3, s5, s6, s13);
                            if (s14) {
                              s14 = void 0;
                            } else {
                              s14 = peg$FAILED;
                            }
                            if (s14 !== peg$FAILED) {
                              s12 = [s12, s13, s14];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s11 === peg$FAILED) {
                          s10 = void 0;
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.length > peg$currPos) {
                            s11 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e3);
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s10 = [s10, s11];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      }
                      s7 = input.substring(s7, peg$currPos);
                      s8 = peg$parseend_env();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsebegin_group();
                        if (s9 !== peg$FAILED) {
                          if (input.substr(peg$currPos, 6) === peg$c9) {
                            s10 = peg$c9;
                            peg$currPos += 6;
                          } else {
                            s10 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e23);
                            }
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseend_group();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s0 = peg$f38(s3, s5, s6, s7);
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            return s0;
          }
          function peg$parseverbatim_environment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsebegin_env();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebegin_group();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseverbatim_env_name();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseend_group();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$currPos;
                    s6 = [];
                    s7 = peg$currPos;
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$currPos;
                    s10 = peg$parseend_env();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsegroup();
                      if (s11 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s12 = peg$f39(s3, s11);
                        if (s12) {
                          s12 = void 0;
                        } else {
                          s12 = peg$FAILED;
                        }
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = void 0;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s9 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s7;
                        s7 = peg$f40(s3, s9);
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$currPos;
                      s8 = peg$currPos;
                      peg$silentFails++;
                      s9 = peg$currPos;
                      s10 = peg$parseend_env();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsegroup();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s12 = peg$f39(s3, s11);
                          if (s12) {
                            s12 = void 0;
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s10 = [s10, s11, s12];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s9 === peg$FAILED) {
                        s8 = void 0;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                      if (s8 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                          s9 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s7;
                          s7 = peg$f40(s3, s9);
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    }
                    s5 = input.substring(s5, peg$currPos);
                    s6 = peg$parseend_env();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsebegin_group();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseverbatim_env_name();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseend_group();
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f41(s3, s5);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e24);
              }
            }
            return s0;
          }
          function peg$parseverbatim_env_name() {
            var s0;
            if (input.substr(peg$currPos, 9) === peg$c10) {
              s0 = peg$c10;
              peg$currPos += 9;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e25);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c11) {
                s0 = peg$c11;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e26);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 13) === peg$c12) {
                  s0 = peg$c12;
                  peg$currPos += 13;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e27);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 12) === peg$c13) {
                    s0 = peg$c13;
                    peg$currPos += 12;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e28);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c14) {
                      s0 = peg$c14;
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e29);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 10) === peg$c15) {
                        s0 = peg$c15;
                        peg$currPos += 10;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e30);
                        }
                      }
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parsemacro() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseescape();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsechar();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsechar();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f42(s3);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$parseescape();
              if (s2 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s1 = peg$f43(s3);
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f44(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            return s0;
          }
          function peg$parsegroup() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsebegin_group();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_group();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsetoken();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f45(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_group();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetoken();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f45(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s3 = peg$parseend_group();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f46(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e32);
              }
            }
            return s0;
          }
          function peg$parsegroup_contents_as_string() {
            var s0, s1;
            s0 = peg$currPos;
            s1 = peg$parsegroup();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f47();
            }
            s0 = s1;
            return s0;
          }
          function peg$parseenvironment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsebegin_env();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsegroup_contents_as_string();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsesameline_comment();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = peg$parseend_env();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsegroup_contents_as_string();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s10 = peg$f48(s2, s3, s9);
                    if (s10) {
                      s10 = void 0;
                    } else {
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      s8 = [s8, s9, s10];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsetoken();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f49(s2, s3, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$currPos;
                  s8 = peg$parseend_env();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsegroup_contents_as_string();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s10 = peg$f48(s2, s3, s9);
                      if (s10) {
                        s10 = void 0;
                      } else {
                        s10 = peg$FAILED;
                      }
                      if (s10 !== peg$FAILED) {
                        s8 = [s8, s9, s10];
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsetoken();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s5 = peg$f49(s2, s3, s7);
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                s5 = peg$parseend_env();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsegroup_contents_as_string();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f50(s2, s3, s4);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            return s0;
          }
          function peg$parsemath_environment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsebegin_env();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebegin_group();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsemath_env_name();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseend_group();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsesameline_comment();
                    if (s5 === peg$FAILED) {
                      s5 = null;
                    }
                    s6 = [];
                    s7 = peg$currPos;
                    s8 = peg$currPos;
                    peg$silentFails++;
                    s9 = peg$currPos;
                    s10 = peg$parseend_env();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsegroup();
                      if (s11 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s12 = peg$f51(s3, s5, s11);
                        if (s12) {
                          s12 = void 0;
                        } else {
                          s12 = peg$FAILED;
                        }
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s9 === peg$FAILED) {
                      s8 = void 0;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsemath_token();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s7;
                        s7 = peg$f52(s3, s5, s9);
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$currPos;
                      s8 = peg$currPos;
                      peg$silentFails++;
                      s9 = peg$currPos;
                      s10 = peg$parseend_env();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsegroup();
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = peg$currPos;
                          s12 = peg$f51(s3, s5, s11);
                          if (s12) {
                            s12 = void 0;
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s10 = [s10, s11, s12];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s9 === peg$FAILED) {
                        s8 = void 0;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsemath_token();
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s7;
                          s7 = peg$f52(s3, s5, s9);
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    }
                    s7 = peg$parseend_env();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsebegin_group();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsemath_env_name();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseend_group();
                          if (s10 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f53(s3, s5, s6);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            return s0;
          }
          function peg$parsebegin_display_math() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s2 = peg$c4;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseend_display_math() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s2 = peg$c5;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsebegin_inline_math() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s2 = peg$c16;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e36);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseend_inline_math() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s2 = peg$c17;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e37);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsebegin_env() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c18) {
                s2 = peg$c18;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e38);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseend_env() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseescape();
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c19) {
                s2 = peg$c19;
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e39);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemath_env_name() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 9) === peg$c20) {
              s1 = peg$c20;
              peg$currPos += 9;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e40);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c21) {
                s1 = peg$c21;
                peg$currPos += 8;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e41);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c22) {
                  s1 = peg$c22;
                  peg$currPos += 6;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e42);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c23) {
                    s1 = peg$c23;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e43);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c24) {
                      s1 = peg$c24;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e44);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c25) {
                        s1 = peg$c25;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e45);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 7) === peg$c26) {
                          s1 = peg$c26;
                          peg$currPos += 7;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e46);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 6) === peg$c27) {
                            s1 = peg$c27;
                            peg$currPos += 6;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e47);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c28) {
                              s1 = peg$c28;
                              peg$currPos += 9;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e48);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 8) === peg$c29) {
                                s1 = peg$c29;
                                peg$currPos += 8;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e49);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c30) {
                                  s1 = peg$c30;
                                  peg$currPos += 8;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e50);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 7) === peg$c31) {
                                    s1 = peg$c31;
                                    peg$currPos += 7;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e51);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 5) === peg$c32) {
                                      s1 = peg$c32;
                                      peg$currPos += 5;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e52);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c33) {
                                        s1 = peg$c33;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e53);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 11) === peg$c34) {
                                          s1 = peg$c34;
                                          peg$currPos += 11;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e54);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f56(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseescape() {
            var s0, s1;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s1 = peg$c35;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f57();
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e55);
              }
            }
            return s0;
          }
          function peg$parsebegin_group() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c36;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e57);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f58(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseend_group() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 125) {
              s1 = peg$c37;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e58);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f59(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsemath_shift() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 36) {
              s1 = peg$c38;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e59);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f60(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsealignment_tab() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 38) {
              s1 = peg$c39;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e60);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f61(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsenl() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 13) {
              s2 = peg$c40;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e62);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c41;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e63);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 13) {
                s0 = peg$c40;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e62);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c42) {
                  s0 = peg$c42;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e64);
                  }
                }
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
            return s0;
          }
          function peg$parsemacro_parameter() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c43;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e65);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f62(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsesuperscript() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 94) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f63(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsesubscript() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c45;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e67);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f64(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseignore() {
            var s0;
            if (input.charCodeAt(peg$currPos) === 0) {
              s0 = peg$c46;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e68);
              }
            }
            return s0;
          }
          function peg$parsesp() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e69);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e69);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f65();
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            return s0;
          }
          function peg$parsechar() {
            var s0;
            peg$silentFails++;
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e71);
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e70);
              }
            }
            return s0;
          }
          function peg$parsenum() {
            var s0;
            peg$silentFails++;
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e73);
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e72);
              }
            }
            return s0;
          }
          function peg$parsepunctuation() {
            var s0, s1;
            peg$silentFails++;
            s0 = peg$currPos;
            if (peg$r4.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e75);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f66(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e74);
              }
            }
            return s0;
          }
          function peg$parsecomment_start() {
            var s0;
            if (input.charCodeAt(peg$currPos) === 37) {
              s0 = peg$c0;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            return s0;
          }
          function peg$parsefull_comment() {
            var s0;
            peg$silentFails++;
            s0 = peg$parseownline_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesameline_comment();
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e76);
              }
            }
            return s0;
          }
          function peg$parseownline_comment() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsesp();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsesp();
            }
            s3 = peg$parsenl();
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            s2 = peg$parseleading_sp();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsecomment();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f67(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesameline_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsesp();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsesp();
            }
            s2 = peg$parsecomment();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f68(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsecomment_start();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f69(s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsenl();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f69(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s3 = peg$currPos;
              peg$silentFails++;
              s4 = peg$parseparbreak();
              peg$silentFails--;
              if (s4 !== peg$FAILED) {
                peg$currPos = s3;
                s3 = void 0;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f70(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecomment_start();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsenl();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f71(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsenl();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f71(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                s3 = peg$currPos;
                s4 = peg$parsenl();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsesp();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsesp();
                  }
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parsecomment_start();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$parsenl();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseEOF();
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f72(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e77);
              }
            }
            return s0;
          }
          function peg$parseleading_sp() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsestart_of_line();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsesp();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsesp();
              }
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            return s0;
          }
          function peg$parsestart_of_line() {
            var s0;
            peg$savedPos = peg$currPos;
            s0 = peg$f73();
            if (s0) {
              s0 = void 0;
            } else {
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOF() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function toString(e) {
            if (typeof e === "string") {
              return e;
            }
            if (typeof e.content === "string") {
              return e.content;
            }
            if (e && e.type === "whitespace") {
              return " ";
            }
            return e;
          }
          function compare_env(g1, g2) {
            const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
            const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
            return g1Name === g2Name;
          }
          function createNode(type, extra = {}) {
            return { type, ...extra, position: location() };
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _AlignEnvironmentPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e0 = peg$anyExpectation();
          var peg$f0 = function() {
            return [];
          };
          var peg$f1 = function(x) {
            return { cells: [], colSeps: [], ...x };
          };
          var peg$f2 = function(rowItems, rowSep, trailingComment) {
            return { ...rowItems, rowSep, trailingComment };
          };
          var peg$f3 = function(rowItems, trailingComment) {
            return { ...rowItems, rowSep: null, trailingComment };
          };
          var peg$f4 = function(x) {
            return x;
          };
          var peg$f5 = function(x) {
            return {
              cells: [],
              colSeps: [],
              rowSep: null,
              trailingComment: x
            };
          };
          var peg$f6 = function(x) {
            return x;
          };
          var peg$f7 = function(colSep, cell) {
            return { colSep, cell };
          };
          var peg$f8 = function(colSep) {
            return { colSep };
          };
          var peg$f9 = function(a, b) {
            return processRow(a, b);
          };
          var peg$f10 = function(b) {
            return processRow(null, b);
          };
          var peg$f11 = function(tok) {
            return options.isSameLineComment(tok);
          };
          var peg$f12 = function(tok) {
            return tok;
          };
          var peg$f13 = function(tok) {
            return options.isOwnLineComment(tok);
          };
          var peg$f14 = function(tok) {
            return tok;
          };
          var peg$f15 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$f16 = function(tok) {
            return tok;
          };
          var peg$f17 = function(tok) {
            return options.isRowSep(tok);
          };
          var peg$f18 = function(tok) {
            return tok;
          };
          var peg$f19 = function(tok) {
            return options.isColSep(tok);
          };
          var peg$f20 = function(tok) {
            return tok;
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1;
            s0 = [];
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parsecomment_only_line();
                if (s1 === peg$FAILED) {
                  s1 = peg$parserow_with_end();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parserow_without_end();
                  }
                }
              }
            } else {
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseEOL();
              if (s1 !== peg$FAILED) {
                s1 = peg$f0();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parserow_with_end() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parserow_items();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s2 = peg$f1(s2);
            s1 = s2;
            s2 = peg$parserow_sep();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetrailing_comment();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = peg$f2(s1, s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parserow_without_end() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parserow_items();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetrailing_comment();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              s0 = peg$f3(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsetrailing_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$parsesame_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f4(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecomment_only_line() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$parseown_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f5(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsetoken() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            s2 = peg$parserow_sep();
            if (s2 === peg$FAILED) {
              s2 = peg$parsecol_sep();
              if (s2 === peg$FAILED) {
                s2 = peg$parsetrailing_comment();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseown_line_comment();
                }
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f6(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecell() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsetoken();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsetoken();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            return s0;
          }
          function peg$parseseparated_cell() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsecol_sep();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsecell();
              if (s2 !== peg$FAILED) {
                s0 = peg$f7(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecol_sep();
              if (s1 !== peg$FAILED) {
                s1 = peg$f8(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parserow_items() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsecell();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseseparated_cell();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseseparated_cell();
              }
              s0 = peg$f9(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseseparated_cell();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseseparated_cell();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f10(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsesame_line_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f11(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f12(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseown_line_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f13(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f14(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f15(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f16(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parserow_sep() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f17(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f18(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecol_sep() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f19(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f20(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function processRow(leadCell, otherCells) {
            const cells = [leadCell || []];
            const seps = [];
            for (const x of otherCells) {
              cells.push(x.cell || []);
              seps.push(x.colSep);
            }
            return { cells, colSeps: seps };
          }
          if (!options.isWhitespace) {
            try {
              Object.assign(
                options,
                createMatchers(["\\", "hline", "cr"], ["&"])
              );
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _ArgSpecPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
          var peg$startRuleFunction = peg$parseargs_spec_list;
          var peg$c1 = "v";
          var peg$c2 = "b";
          var peg$c3 = "!";
          var peg$c4 = "D";
          var peg$c5 = "d";
          var peg$c6 = "s";
          var peg$c7 = "O";
          var peg$c8 = "o";
          var peg$c9 = "e";
          var peg$c10 = "E";
          var peg$c11 = "t";
          var peg$c12 = "R";
          var peg$c13 = "r";
          var peg$c14 = "u";
          var peg$c15 = "m";
          var peg$c16 = "{";
          var peg$c17 = "}";
          var peg$c18 = " ";
          var peg$c19 = "\n";
          var peg$c20 = "\r";
          var peg$c21 = "\\";
          var peg$r0 = /^[{ ]/;
          var peg$r1 = /^[a-zA-Z]/;
          var peg$r2 = /^[{}]/;
          var peg$e0 = peg$literalExpectation("+", false);
          var peg$e1 = peg$literalExpectation("v", false);
          var peg$e2 = peg$anyExpectation();
          var peg$e3 = peg$literalExpectation("b", false);
          var peg$e4 = peg$literalExpectation("!", false);
          var peg$e5 = peg$literalExpectation("D", false);
          var peg$e6 = peg$literalExpectation("d", false);
          var peg$e7 = peg$literalExpectation("s", false);
          var peg$e8 = peg$literalExpectation("O", false);
          var peg$e9 = peg$literalExpectation("o", false);
          var peg$e10 = peg$literalExpectation("e", false);
          var peg$e11 = peg$literalExpectation("E", false);
          var peg$e12 = peg$literalExpectation("t", false);
          var peg$e13 = peg$literalExpectation("R", false);
          var peg$e14 = peg$literalExpectation("r", false);
          var peg$e15 = peg$literalExpectation("u", false);
          var peg$e16 = peg$classExpectation(["{", " "], false, false);
          var peg$e17 = peg$literalExpectation("m", false);
          var peg$e18 = peg$literalExpectation("{", false);
          var peg$e19 = peg$literalExpectation("}", false);
          var peg$e20 = peg$literalExpectation(" ", false);
          var peg$e21 = peg$literalExpectation("\n", false);
          var peg$e22 = peg$literalExpectation("\r", false);
          var peg$e23 = peg$literalExpectation("\\", false);
          var peg$e24 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
          var peg$e25 = peg$classExpectation(["{", "}"], false, false);
          var peg$f0 = function(x) {
            return x;
          };
          var peg$f1 = function(spec) {
            return spec;
          };
          var peg$f2 = function(spec) {
            return spec;
          };
          var peg$f3 = function(openBrace) {
            return createNode("verbatim", { openBrace, closeBrace: openBrace });
          };
          var peg$f4 = function() {
            return createNode("body");
          };
          var peg$f5 = function(leading_bang, spec) {
            return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
          };
          var peg$f6 = function(braceSpec, defaultArg) {
            return createNode("optional", { ...braceSpec, defaultArg });
          };
          var peg$f7 = function(braceSpec) {
            return createNode("optional", braceSpec);
          };
          var peg$f8 = function() {
            return createNode("optionalStar");
          };
          var peg$f9 = function(g) {
            return createNode("optional", { defaultArg: g });
          };
          var peg$f10 = function() {
            return createNode("optional");
          };
          var peg$f11 = function(args) {
            return createNode("embellishment", {
              embellishmentTokens: args
            });
          };
          var peg$f12 = function(args, g) {
            return createNode("embellishment", {
              embellishmentTokens: args,
              defaultArg: g
            });
          };
          var peg$f13 = function(tok) {
            return createNode("optionalToken", { token: tok });
          };
          var peg$f14 = function(braceSpec, defaultArg) {
            return createNode("mandatory", { ...braceSpec, defaultArg });
          };
          var peg$f15 = function(braceSpec) {
            return createNode("mandatory", braceSpec);
          };
          var peg$f16 = function(stopTokens) {
            return createNode("until", { stopTokens });
          };
          var peg$f17 = function(x) {
            return [x];
          };
          var peg$f18 = function(g) {
            return g.content;
          };
          var peg$f19 = function() {
            return createNode("mandatory");
          };
          var peg$f20 = function(openBrace, closeBrace) {
            return { openBrace, closeBrace };
          };
          var peg$f21 = function(g) {
            return g.content.map(groupToStr).join("");
          };
          var peg$f22 = function(t) {
            return [t];
          };
          var peg$f23 = function(args) {
            return args.filter((a) => !a.match(/^\s*$/));
          };
          var peg$f24 = function(content) {
            return { type: "group", content };
          };
          var peg$f25 = function() {
            return "";
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$literalExpectation(text2, ignoreCase) {
            return { type: "literal", text: text2, ignoreCase };
          }
          function peg$classExpectation(parts, inverted, ignoreCase) {
            return { type: "class", parts, inverted, ignoreCase };
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parseargs_spec_list() {
            var s0, s1, s2, s4;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            peg$parsewhitespace();
            s4 = peg$parsearg_spec();
            if (s4 !== peg$FAILED) {
              s2 = peg$f0(s4);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              peg$parsewhitespace();
              s4 = peg$parsearg_spec();
              if (s4 !== peg$FAILED) {
                s2 = peg$f0(s4);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
            s2 = peg$parsewhitespace();
            s0 = peg$f1(s1);
            return s0;
          }
          function peg$parsearg_spec() {
            var s0, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              peg$currPos++;
            } else {
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            s2 = peg$parseoptional();
            if (s2 === peg$FAILED) {
              s2 = peg$parsemandatory();
              if (s2 === peg$FAILED) {
                s2 = peg$parseverbatim();
                if (s2 === peg$FAILED) {
                  s2 = peg$parserequired();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsebody();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parseuntil();
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f2(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseverbatim() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 118) {
              s1 = peg$c1;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f3(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsebody() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 98) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f4();
            }
            s0 = s1;
            return s0;
          }
          function peg$parseoptional() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 33) {
              s1 = peg$c3;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            s2 = peg$parseoptional_star();
            if (s2 === peg$FAILED) {
              s2 = peg$parseoptional_standard();
              if (s2 === peg$FAILED) {
                s2 = peg$parseoptional_delimited();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseoptional_embellishment();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseoptional_token();
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f5(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseoptional_delimited() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 68) {
              s1 = peg$c4;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebrace_spec();
              s3 = peg$parsearg();
              if (s3 !== peg$FAILED) {
                s0 = peg$f6(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 100) {
                s1 = peg$c5;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebrace_spec();
                s0 = peg$f7(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parseoptional_star() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 115) {
              s1 = peg$c6;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f8();
            }
            s0 = s1;
            return s0;
          }
          function peg$parseoptional_standard() {
            var s0, s1, s3;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 79) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$parsewhitespace();
              s3 = peg$parsearg();
              if (s3 !== peg$FAILED) {
                s0 = peg$f9(s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 111) {
                s1 = peg$c8;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e9);
                }
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f10();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parseoptional_embellishment() {
            var s0, s1, s3, s5;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 101) {
              s1 = peg$c9;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$parsewhitespace();
              s3 = peg$parseargs();
              if (s3 !== peg$FAILED) {
                s0 = peg$f11(s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 69) {
                s1 = peg$c10;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$parsewhitespace();
                s3 = peg$parseargs();
                if (s3 !== peg$FAILED) {
                  peg$parsewhitespace();
                  s5 = peg$parseargs();
                  if (s5 !== peg$FAILED) {
                    s0 = peg$f12(s3, s5);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parseoptional_token() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 116) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f13(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parserequired() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 82) {
              s1 = peg$c12;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsebrace_spec();
              s3 = peg$parsearg();
              if (s3 !== peg$FAILED) {
                s0 = peg$f14(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 114) {
                s1 = peg$c13;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebrace_spec();
                s0 = peg$f15(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parseuntil() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 117) {
              s1 = peg$c14;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseuntil_stop_token();
              if (s2 !== peg$FAILED) {
                s0 = peg$f16(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseuntil_stop_token() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f17(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebraced_group();
              if (s1 !== peg$FAILED) {
                s1 = peg$f18(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsemandatory() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 109) {
              s1 = peg$c15;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f19();
            }
            s0 = s1;
            return s0;
          }
          function peg$parsebrace_spec() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parsewhitespace_token();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsemacro();
              if (s4 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s1 = input.substring(s1, peg$currPos);
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsewhitespace_token();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro();
              if (s5 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s2 = input.substring(s2, peg$currPos);
            s0 = peg$f20(s1, s2);
            return s0;
          }
          function peg$parsearg() {
            var s0, s1;
            s0 = peg$parsetoken();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebraced_group();
              if (s1 !== peg$FAILED) {
                s1 = peg$f21(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parseargs() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsetoken();
            if (s1 !== peg$FAILED) {
              s1 = peg$f22(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 123) {
                s1 = peg$c16;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearg();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsewhitespace_token();
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearg();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsewhitespace_token();
                  }
                }
                if (input.charCodeAt(peg$currPos) === 125) {
                  s3 = peg$c17;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s0 = peg$f23(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parsebraced_group() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c16;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 125) {
                s6 = peg$c17;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsebraced_group();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsetoken();
                  if (s7 === peg$FAILED) {
                    s7 = peg$parsewhitespace_token();
                  }
                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s3 = input.substring(s3, peg$currPos);
              } else {
                s3 = s4;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parsebraced_group();
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                s5 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c17;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = void 0;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  peg$silentFails++;
                  s7 = peg$parsebraced_group();
                  peg$silentFails--;
                  if (s7 === peg$FAILED) {
                    s6 = void 0;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsetoken();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parsewhitespace_token();
                    }
                    if (s7 !== peg$FAILED) {
                      s5 = [s5, s6, s7];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s3 = input.substring(s3, peg$currPos);
                } else {
                  s3 = s4;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$parsebraced_group();
                }
              }
              if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c17;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s3 !== peg$FAILED) {
                s0 = peg$f24(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace_token();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace_token();
            }
            s1 = peg$f25();
            s0 = s1;
            return s0;
          }
          function peg$parsewhitespace_token() {
            var s0;
            if (input.charCodeAt(peg$currPos) === 32) {
              s0 = peg$c18;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s0 = peg$c19;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e21);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 13) {
                  s0 = peg$c20;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e22);
                  }
                }
              }
            }
            return s0;
          }
          function peg$parsemacro() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c21;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e24);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e24);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s2 = peg$c21;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e24);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = void 0;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
            }
            return s0;
          }
          function peg$parsetoken() {
            var s0, s1, s2, s3;
            s0 = peg$parsemacro();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (peg$r2.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e25);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                s3 = peg$parsewhitespace_token();
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                  s2 = void 0;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s0 = s3;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          const DEFAULT_OPTIONS = {
            optional: { openBrace: "[", closeBrace: "]" },
            mandatory: { openBrace: "{", closeBrace: "}" }
          };
          function createNode(type, options2) {
            const computedOptions = DEFAULT_OPTIONS[type] || {};
            return { type, ...computedOptions, ...options2 };
          }
          function groupToStr(node) {
            if (typeof node !== "object" || !node) {
              return node;
            }
            if (node.type === "group") {
              return `{${node.content.map(groupToStr).join("")}}`;
            }
            return node;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _PgfkeysPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e0 = peg$anyExpectation();
          var peg$f0 = function() {
            return [];
          };
          var peg$f1 = function(rowItems, trailingComment) {
            return {
              itemParts: [],
              ...rowItems,
              trailingComment,
              trailingComma: true
            };
          };
          var peg$f2 = function(rowItems, trailingComment) {
            return { ...rowItems, trailingComment };
          };
          var peg$f3 = function(a, b) {
            return processItem(a, b);
          };
          var peg$f4 = function(b) {
            return processItem(null, b);
          };
          var peg$f5 = function(cell) {
            return { cell };
          };
          var peg$f6 = function() {
            return {};
          };
          var peg$f7 = function(part) {
            return part;
          };
          var peg$f8 = function(x) {
            return x;
          };
          var peg$f9 = function(space, x) {
            return {
              trailingComment: x,
              leadingParbreak: space.parbreak > 0
            };
          };
          var peg$f10 = function(list) {
            return {
              whitespace: list.filter((x) => options.isWhitespace(x)).length,
              parbreak: list.filter((x) => options.isParbreak(x)).length
            };
          };
          var peg$f11 = function() {
            return !options.allowParenGroups;
          };
          var peg$f12 = function(tok) {
            return options.isSameLineComment(tok);
          };
          var peg$f13 = function(tok) {
            return tok;
          };
          var peg$f14 = function(tok) {
            return options.isOwnLineComment(tok);
          };
          var peg$f15 = function(tok) {
            return tok;
          };
          var peg$f16 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$f17 = function(tok) {
            return tok;
          };
          var peg$f18 = function(tok) {
            return options.isParbreak(tok);
          };
          var peg$f19 = function(tok) {
            return tok;
          };
          var peg$f20 = function(tok) {
            return options.isComma(tok);
          };
          var peg$f21 = function(tok) {
            return tok;
          };
          var peg$f22 = function(tok) {
            return options.isEquals(tok);
          };
          var peg$f23 = function(tok) {
            return tok;
          };
          var peg$f24 = function(tok) {
            return options.isChar(tok, "(");
          };
          var peg$f25 = function(tok) {
            return tok;
          };
          var peg$f26 = function(tok) {
            return options.isChar(tok, ")");
          };
          var peg$f27 = function(tok) {
            return tok;
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1, s2;
            s0 = [];
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parsecomment_only_line();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseitem_with_end();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseitem_without_end();
                  }
                }
              }
            } else {
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$parseEOL();
              if (s2 !== peg$FAILED) {
                s0 = peg$f0();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parseitem_with_end() {
            var s0, s2, s4, s5, s6, s7, s8;
            s0 = peg$currPos;
            peg$parsewhitespace_or_parbreaks();
            s2 = peg$parserow_items();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            peg$parsewhitespace_or_parbreaks();
            s4 = peg$parseitem_sep();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsewhitespace();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsewhitespace();
              }
              s6 = peg$parsetrailing_comment();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              s7 = [];
              s8 = peg$parsewhitespace();
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                s8 = peg$parsewhitespace();
              }
              s0 = peg$f1(s2, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseitem_without_end() {
            var s0, s2, s3;
            s0 = peg$currPos;
            peg$parsewhitespace_or_parbreaks();
            s2 = peg$parserow_items();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetrailing_comment();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = peg$f2(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parserow_items() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parseitem_part();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseseparated_part();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseseparated_part();
              }
              s0 = peg$f3(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseseparated_part();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseseparated_part();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s1 = peg$f4(s1);
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parseseparated_part() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseparbreak();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseparbreak();
            }
            s2 = peg$parseequals();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseparbreak();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseparbreak();
              }
              s4 = peg$parseitem_part();
              if (s4 !== peg$FAILED) {
                s0 = peg$f5(s4);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseparbreak();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseparbreak();
              }
              s2 = peg$parseequals();
              if (s2 !== peg$FAILED) {
                s0 = peg$f6();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            return s0;
          }
          function peg$parseitem_part() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsenon_whitespace_non_parbreak_token();
            if (s4 === peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsenon_whitespace_non_parbreak_token();
                if (s4 === peg$FAILED) {
                  s4 = peg$currPos;
                  s5 = peg$parsewhitespace();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseparbreak();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$currPos;
                    peg$silentFails++;
                    s7 = peg$currPos;
                    s8 = [];
                    s9 = peg$parsewhitespace();
                    if (s9 === peg$FAILED) {
                      s9 = peg$parseparbreak();
                    }
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$parsewhitespace();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parseparbreak();
                      }
                    }
                    s9 = peg$parsenon_whitespace_non_parbreak_token();
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s7 !== peg$FAILED) {
                      peg$currPos = s6;
                      s6 = void 0;
                    } else {
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      s5 = [s5, s6];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = input.substring(s2, peg$currPos);
            } else {
              s2 = s3;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsewhitespace();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsewhitespace();
              }
              s0 = peg$f7(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsetrailing_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$parsesame_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f8(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecomment_only_line() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsewhitespace_or_parbreaks();
            s2 = peg$parseown_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f9(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsetoken() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parsenon_token();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            return s0;
          }
          function peg$parsenon_whitespace_non_parbreak_token() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parsewhitespace();
            if (s3 === peg$FAILED) {
              s3 = peg$parseparbreak();
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseparen_block();
              if (s3 === peg$FAILED) {
                s3 = peg$parsetoken();
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            return s0;
          }
          function peg$parsenon_token() {
            var s0;
            s0 = peg$parseitem_sep();
            if (s0 === peg$FAILED) {
              s0 = peg$parseequals();
              if (s0 === peg$FAILED) {
                s0 = peg$parsetrailing_comment();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseown_line_comment();
                }
              }
            }
            return s0;
          }
          function peg$parsewhitespace_or_parbreaks() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseparbreak();
            }
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
              if (s2 === peg$FAILED) {
                s2 = peg$parseparbreak();
              }
            }
            s1 = peg$f10(s1);
            s0 = s1;
            return s0;
          }
          function peg$parseparen_block() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;
            s0 = peg$currPos;
            s1 = peg$f11();
            if (s1) {
              s1 = peg$FAILED;
            } else {
              s1 = void 0;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$currPos;
              s4 = peg$parseopen_paren();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$parseclose_paren();
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    s7 = [s7, s8];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$parseclose_paren();
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      s7 = [s7, s8];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseclose_paren();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s2 = input.substring(s2, peg$currPos);
              } else {
                s2 = s3;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesame_line_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f12(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f13(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseown_line_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f14(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f15(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f16(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f17(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseparbreak() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f18(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f19(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseitem_sep() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f20(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f21(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseequals() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f22(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f23(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseopen_paren() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f24(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f25(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseclose_paren() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f26(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f27(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function processItem(leadCell, otherCells) {
            const cells = [leadCell || []];
            for (const x of otherCells) {
              cells.push(x.cell || []);
            }
            return { itemParts: cells };
          }
          if (!options.isWhitespace) {
            try {
              Object.assign(options, {
                isChar: (node, char) => node.type === "string" && node.content === char,
                isComma(node) {
                  return node.type === "string" && node.content === ",";
                },
                isEquals(node) {
                  return node.type === "string" && node.content === "=";
                },
                isParbreak(node) {
                  return node.type === "parbreak";
                },
                isWhitespace(node) {
                  return node.type === "whitespace";
                },
                isSameLineComment: (node) => node.type === "comment" && node.sameline,
                isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
                isComment: (node) => node.type === "comment",
                allowParenGroups: true
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _MacroSubstitutionPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e0 = peg$anyExpectation();
          var peg$f0 = function(e) {
            return [].concat(...e).filter((n) => !!n);
          };
          var peg$f1 = function() {
            return [];
          };
          var peg$f2 = function(tok) {
            return options.isHash(tok);
          };
          var peg$f3 = function(tok) {
            return tok;
          };
          var peg$f4 = function(tok) {
            return options.isNumber(tok);
          };
          var peg$f5 = function(tok) {
            return tok;
          };
          var peg$f6 = function() {
            return { type: "string", content: "#" };
          };
          var peg$f7 = function(num) {
            const split = options.splitNumber(num);
            return [{ type: "hash_number", number: split.number }, split.rest];
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedouble_hash();
            if (s2 === peg$FAILED) {
              s2 = peg$parsehash_number();
              if (s2 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsedouble_hash();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsehash_number();
                  if (s2 === peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s2 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f0(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseEOL();
              if (s1 !== peg$FAILED) {
                s1 = peg$f1();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsehash() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f2(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f3(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsenumber() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f4(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f5(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedouble_hash() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsehash();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsehash();
              if (s2 !== peg$FAILED) {
                s0 = peg$f6();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsehash_number() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsehash();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsenumber();
              if (s2 !== peg$FAILED) {
                s0 = peg$f7(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          if (!options.isHash) {
            try {
              Object.assign(options, {
                isHash: (node) => node.type === "string" && node.content === "#",
                isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
                splitNumber: (node) => {
                  const number = +node.content.charAt(0);
                  if (node.content.length > 1) {
                    return {
                      number,
                      rest: {
                        type: "string",
                        content: node.content.slice(1)
                      }
                    };
                  }
                  return { number };
                }
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _LigaturesPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e0 = peg$anyExpectation();
          var peg$f0 = function(e) {
            return [].concat(...e).filter((n) => !!n);
          };
          var peg$f1 = function() {
            return [];
          };
          var peg$f2 = function(toks) {
            return options.isRecognized(toks);
          };
          var peg$f3 = function(toks) {
            return options.isRecognized(toks);
          };
          var peg$f4 = function(tok1, tok2) {
            const split = options.split(tok2);
            return options.isRecognized([tok1, split[0]]);
          };
          var peg$f5 = function(tok1, tok2) {
            const split = options.split(tok2);
            return [options.isRecognized([tok1, split[0]]), split[1]];
          };
          var peg$f6 = function(tok1, tok2) {
            return options.isRecognized([tok1, tok2]);
          };
          var peg$f7 = function(tok1, tok2) {
            return options.isRecognized([tok1, tok2]);
          };
          var peg$f8 = function(toks) {
            return options.isRecognized(toks);
          };
          var peg$f9 = function(toks) {
            return options.isRecognized(toks);
          };
          var peg$f10 = function(tok) {
            return options.isRecognized([tok]);
          };
          var peg$f11 = function(tok) {
            return options.isRecognized([tok]);
          };
          var peg$f12 = function(tok) {
            return options.isMacro(tok);
          };
          var peg$f13 = function(tok) {
            return tok;
          };
          var peg$f14 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$f15 = function(tok) {
            return tok;
          };
          var peg$f16 = function(tok) {
            return options.isSplitable(tok);
          };
          var peg$f17 = function(tok) {
            return tok;
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsetriple_ligature();
            if (s2 === peg$FAILED) {
              s2 = peg$parsedouble_ligature();
              if (s2 === peg$FAILED) {
                s2 = peg$parsemono_ligature();
                if (s2 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsetriple_ligature();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsedouble_ligature();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsemono_ligature();
                    if (s2 === peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e0);
                        }
                      }
                    }
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f0(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseEOL();
              if (s1 !== peg$FAILED) {
                s1 = peg$f1();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsetriple_ligature() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f2(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f3(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedouble_ligature() {
            var s0;
            s0 = peg$parsedouble_macro_ligature();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedouble_macro_ligature_extracted();
              if (s0 === peg$FAILED) {
                s0 = peg$parsedouble_char_ligature();
              }
            }
            return s0;
          }
          function peg$parsedouble_macro_ligature_extracted() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$parsemacro();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsewhitespace();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsewhitespace();
              }
              s3 = peg$parsesplitable();
              if (s3 !== peg$FAILED) {
                s4 = peg$f4(s1, s3);
                if (s4) {
                  s4 = void 0;
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s0 = peg$f5(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedouble_macro_ligature() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$parsemacro();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsewhitespace();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsewhitespace();
              }
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$f6(s1, s3);
                if (s4) {
                  s4 = void 0;
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s0 = peg$f7(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedouble_char_ligature() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f8(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f9(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemono_ligature() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f10(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f11(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemacro() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f12(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f13(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsewhitespace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f14(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f15(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesplitable() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f16(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f17(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          if (!options.isWhitespace) {
            try {
              Object.assign(options, {
                isMacro: (node) => node.type === "macro",
                isWhitespace: (node) => node.type === "whitespace",
                isRecognized: (nodes) => {
                  if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                    return { type: "string", content: "ô" };
                  }
                  return null;
                },
                isSplitable: (node) => node.type === "string" && node.content.length > 1,
                split: (node) => [
                  { type: "string", content: node.content.charAt(0) },
                  { type: "string", content: node.content.slice(1) }
                ]
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _XColorPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { start: peg$parsestart };
          var peg$startRuleFunction = peg$parsestart;
          var peg$c0 = ";";
          var peg$c1 = ",";
          var peg$c2 = ":";
          var peg$c3 = "/";
          var peg$c4 = ">";
          var peg$c5 = "!";
          var peg$c6 = ".";
          var peg$c7 = "!![";
          var peg$c8 = "]";
          var peg$c9 = "!!";
          var peg$c10 = "+";
          var peg$c11 = "-";
          var peg$r0 = /^[a-zA-Z0-9]/;
          var peg$r1 = /^[0-9]/;
          var peg$r2 = /^[ \t\n\r]/;
          var peg$r3 = /^[0-9a-fA-F]/;
          var peg$e0 = peg$anyExpectation();
          var peg$e1 = peg$literalExpectation(";", false);
          var peg$e2 = peg$literalExpectation(",", false);
          var peg$e3 = peg$otherExpectation("model list");
          var peg$e4 = peg$literalExpectation(":", false);
          var peg$e5 = peg$literalExpectation("/", false);
          var peg$e6 = peg$otherExpectation("model");
          var peg$e7 = peg$otherExpectation("color spec list");
          var peg$e8 = peg$otherExpectation("color spec");
          var peg$e9 = peg$otherExpectation("color");
          var peg$e10 = peg$otherExpectation("function expression");
          var peg$e11 = peg$literalExpectation(">", false);
          var peg$e12 = peg$otherExpectation("function");
          var peg$e13 = peg$otherExpectation("extended expression");
          var peg$e14 = peg$otherExpectation("core model");
          var peg$e15 = peg$otherExpectation("expr");
          var peg$e16 = peg$literalExpectation("!", false);
          var peg$e17 = peg$otherExpectation("mix expr");
          var peg$e18 = peg$otherExpectation("name");
          var peg$e19 = peg$literalExpectation(".", false);
          var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
          var peg$e21 = peg$otherExpectation("postfix");
          var peg$e22 = peg$literalExpectation("!![", false);
          var peg$e23 = peg$literalExpectation("]", false);
          var peg$e24 = peg$literalExpectation("!!", false);
          var peg$e25 = peg$otherExpectation("prefix");
          var peg$e26 = peg$otherExpectation("plus");
          var peg$e27 = peg$literalExpectation("+", false);
          var peg$e28 = peg$otherExpectation("minus");
          var peg$e29 = peg$literalExpectation("-", false);
          var peg$e30 = peg$otherExpectation("num");
          var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
          var peg$e32 = peg$otherExpectation("positive float");
          var peg$e33 = peg$otherExpectation("divisor");
          var peg$e34 = peg$otherExpectation("int");
          var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
          var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
          var peg$f0 = function(m) {
            return m;
          };
          var peg$f1 = function(m) {
            return m;
          };
          var peg$f2 = function(m) {
            return m;
          };
          var peg$f3 = function(m) {
            return m;
          };
          var peg$f4 = function(m) {
            return m;
          };
          var peg$f5 = function(a) {
            return { type: "invalid_spec", content: a };
          };
          var peg$f6 = function(f, c) {
            return c;
          };
          var peg$f7 = function(f, r) {
            return { type: "color_set", content: [f].concat(r) };
          };
          var peg$f8 = function(n, s) {
            return { type: "color_set_item", name: n, spec_list: s };
          };
          var peg$f9 = function(c, m) {
            return { type: "model_list", contents: m, core_model: c };
          };
          var peg$f10 = function(m) {
            return { type: "model_list", contents: m, core_model: null };
          };
          var peg$f11 = function(m, a) {
            return a;
          };
          var peg$f12 = function(m, r) {
            return [m].concat(r);
          };
          var peg$f13 = function(s, a) {
            return a;
          };
          var peg$f14 = function(s, r) {
            return { type: "spec_list", content: [s].concat(r) };
          };
          var peg$f15 = function(c) {
            return { type: "hex_spec", content: [c] };
          };
          var peg$f16 = function(c, d) {
            return d;
          };
          var peg$f17 = function(c, d) {
            return d;
          };
          var peg$f18 = function(c, r) {
            return { type: "num_spec", content: r ? [c].concat(r) : [c] };
          };
          var peg$f19 = function(c, fs) {
            return { type: "color", color: c, functions: fs };
          };
          var peg$f20 = function(f, n) {
            return n;
          };
          var peg$f21 = function(f, args) {
            return { type: "function", name: f, args };
          };
          var peg$f22 = function(core, d, e, es) {
            return {
              type: "extended_expr",
              core_model: core,
              div: d,
              expressions: [e].concat(es)
            };
          };
          var peg$f23 = function(core, e, es) {
            return {
              type: "extended_expr",
              core_model: core,
              div: null,
              expressions: [e].concat(es)
            };
          };
          var peg$f24 = function(e, d) {
            return { type: "weighted_expr", color: e, weight: d };
          };
          var peg$f25 = function(e) {
            return e;
          };
          var peg$f26 = function(p, n, e, po) {
            return {
              type: "expr",
              prefix: p,
              name: n,
              mix_expr: e,
              postfix: po
            };
          };
          var peg$f27 = function(p, n) {
            return { type: "complete_mix", mix_percent: p, name: n };
          };
          var peg$f28 = function(p) {
            return { type: "partial_mix", mix_percent: p };
          };
          var peg$f29 = function(c, p) {
            return c.concat(p || []);
          };
          var peg$f30 = function(n) {
            return { type: "postfix", num: n };
          };
          var peg$f31 = function(p) {
            return { type: "postfix", plusses: p };
          };
          var peg$f32 = function(n) {
            return parseInt(n, 10);
          };
          var peg$f33 = function(n) {
            return parseFloat(n);
          };
          var peg$f34 = function(n) {
            return n;
          };
          var peg$f35 = function(n) {
            return -n;
          };
          var peg$f36 = function(m, n) {
            return m ? -n : n;
          };
          var peg$f37 = function(h) {
            return h.toUpperCase();
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$literalExpectation(text2, ignoreCase) {
            return { type: "literal", text: text2, ignoreCase };
          }
          function peg$classExpectation(parts, inverted, ignoreCase) {
            return { type: "class", parts, inverted, ignoreCase };
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsestart() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsespec();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseEOL();
              if (s2 !== peg$FAILED) {
                s0 = peg$f0(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsespec_list();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseEOL();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f1(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseEOL();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f2(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsemodel_list();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseEOL();
                    if (s2 !== peg$FAILED) {
                      s0 = peg$f3(s1);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsecolor_set_spec();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parseEOL();
                      if (s2 !== peg$FAILED) {
                        s0 = peg$f4(s1);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$currPos;
                      s2 = [];
                      if (input.length > peg$currPos) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e0);
                        }
                      }
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        if (input.length > peg$currPos) {
                          s3 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e0);
                          }
                        }
                      }
                      s1 = input.substring(s1, peg$currPos);
                      s1 = peg$f5(s1);
                      s0 = s1;
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parsecolor_set_spec() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsecolor_set_item();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 59) {
                s4 = peg$c0;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecolor_set_item();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f6(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 59) {
                  s4 = peg$c0;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e1);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsecolor_set_item();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f6(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s0 = peg$f7(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecolor_set_item() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsename();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s2 = peg$c1;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsespec_list();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f8(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemodel_list() {
            var s0, s1, s2, s3;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsecore_model();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c2;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsemodel_list_tail();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f9(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list_tail();
              if (s1 !== peg$FAILED) {
                s1 = peg$f10(s1);
              }
              s0 = s1;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            return s0;
          }
          function peg$parsemodel_list_tail() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsemodel();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 47) {
                s4 = peg$c3;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsemodel();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f11(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 47) {
                  s4 = peg$c3;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsemodel();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f11(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s0 = peg$f12(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemodel() {
            var s0;
            peg$silentFails++;
            s0 = peg$parsecore_model();
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            return s0;
          }
          function peg$parsespec_list() {
            var s0, s1, s2, s3, s4, s5;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsespec();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 47) {
                s4 = peg$c3;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsespec();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f13(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 47) {
                  s4 = peg$c3;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsespec();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f13(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              s0 = peg$f14(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            return s0;
          }
          function peg$parsespec() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = peg$parsehex();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsehex();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsehex();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsehex();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsehex();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsehex();
                      if (s8 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6, s7, s8];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f15(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsedec();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c1;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s4 = peg$c1;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsedec();
                      if (s5 !== peg$FAILED) {
                        s3 = peg$f16(s1, s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                  s2 = [];
                  s3 = peg$currPos;
                  s4 = peg$parsesp();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      s3 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$currPos;
                      s4 = peg$parsesp();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsedec();
                        if (s5 !== peg$FAILED) {
                          s3 = peg$f17(s1, s5);
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  } else {
                    s2 = peg$FAILED;
                  }
                }
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                s0 = peg$f18(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            return s0;
          }
          function peg$parsecolor() {
            var s0, s1, s2, s3;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsecolor_expr();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsefunc_expr();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsefunc_expr();
              }
              s0 = peg$f19(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            return s0;
          }
          function peg$parsecolor_expr() {
            var s0;
            s0 = peg$parseext_expr();
            if (s0 === peg$FAILED) {
              s0 = peg$parseexpr();
              if (s0 === peg$FAILED) {
                s0 = peg$parsename();
              }
            }
            return s0;
          }
          function peg$parsefunc_expr() {
            var s0, s1, s2, s3, s4, s5, s6;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 62) {
              s1 = peg$c4;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsefunction();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c1;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseint();
                  if (s6 !== peg$FAILED) {
                    s4 = peg$f20(s2, s6);
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c1;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseint();
                    if (s6 !== peg$FAILED) {
                      s4 = peg$f20(s2, s6);
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
                s0 = peg$f21(s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            return s0;
          }
          function peg$parsefunction() {
            var s0;
            peg$silentFails++;
            s0 = peg$parsename();
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            return s0;
          }
          function peg$parseext_expr() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsecore_model();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s2 = peg$c1;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsediv();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s4 = peg$c2;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e4);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseweighted_expr();
                    if (s5 !== peg$FAILED) {
                      s6 = [];
                      s7 = peg$parseadditional_weighted_expr();
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        s7 = peg$parseadditional_weighted_expr();
                      }
                      s0 = peg$f22(s1, s3, s5, s6);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecore_model();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s2 = peg$c2;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseweighted_expr();
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parseadditional_weighted_expr();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parseadditional_weighted_expr();
                    }
                    s0 = peg$f23(s1, s3, s4);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
            return s0;
          }
          function peg$parseweighted_expr() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parseexpr();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s2 = peg$c1;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsedec();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f24(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseadditional_weighted_expr() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s1 = peg$c0;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseweighted_expr();
              if (s2 !== peg$FAILED) {
                s0 = peg$f25(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecore_model() {
            var s0;
            peg$silentFails++;
            s0 = peg$parsename();
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            return s0;
          }
          function peg$parseexpr() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseprefix();
            s2 = peg$parsename();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsemix_expr();
              s4 = peg$parsepostfix();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              s0 = peg$f26(s1, s2, s3, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            return s0;
          }
          function peg$parsecomplete_mix() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 33) {
              s1 = peg$c5;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsepct();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 33) {
                  s3 = peg$c5;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e16);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsename();
                  if (s4 !== peg$FAILED) {
                    s0 = peg$f27(s2, s4);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsepartial_mix() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 33) {
              s1 = peg$c5;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsepct();
              if (s2 !== peg$FAILED) {
                s0 = peg$f28(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemix_expr() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsecomplete_mix();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsecomplete_mix();
            }
            s2 = peg$parsepartial_mix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s0 = peg$f29(s1, s2);
            peg$silentFails--;
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
            return s0;
          }
          function peg$parsename() {
            var s0, s1, s2;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s0 = peg$c6;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (peg$r0.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s0 = input.substring(s0, peg$currPos);
              } else {
                s0 = s1;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            return s0;
          }
          function peg$parsepostfix() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c7) {
              s1 = peg$c7;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsenum();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c8;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e23);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s0 = peg$f30(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c9) {
                s1 = peg$c9;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e24);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = [];
                s4 = peg$parseplus();
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseplus();
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s2 = input.substring(s2, peg$currPos);
                } else {
                  s2 = s3;
                }
                if (s2 !== peg$FAILED) {
                  s0 = peg$f31(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e21);
              }
            }
            return s0;
          }
          function peg$parseprefix() {
            var s0;
            peg$silentFails++;
            s0 = peg$parseminus();
            if (s0 === peg$FAILED) {
              s0 = null;
            }
            peg$silentFails--;
            if (peg$silentFails === 0) {
              peg$fail(peg$e25);
            }
            return s0;
          }
          function peg$parseplus() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            if (input.charCodeAt(peg$currPos) === 43) {
              s2 = peg$c10;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (input.charCodeAt(peg$currPos) === 43) {
                  s2 = peg$c10;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e27);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e26);
              }
            }
            return s0;
          }
          function peg$parseminus() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            if (input.charCodeAt(peg$currPos) === 45) {
              s2 = peg$c11;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (input.charCodeAt(peg$currPos) === 45) {
                  s2 = peg$c11;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e29);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s0 = input.substring(s0, peg$currPos);
            } else {
              s0 = s1;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e28);
              }
            }
            return s0;
          }
          function peg$parsenum() {
            var s0, s1, s2, s3;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f32(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e30);
              }
            }
            return s0;
          }
          function peg$parsepct() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s3 = input.substring(s3, peg$currPos);
            } else {
              s3 = s4;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c6;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                s8 = [];
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s9 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e31);
                    }
                  }
                }
                s7 = input.substring(s7, peg$currPos);
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              s4 = input.substring(s4, peg$currPos);
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s3 = peg$c6;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = [];
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    if (peg$r1.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e31);
                      }
                    }
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s4 = input.substring(s4, peg$currPos);
                } else {
                  s4 = s5;
                }
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = input.substring(s1, peg$currPos);
              } else {
                s1 = s2;
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f33(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e32);
              }
            }
            return s0;
          }
          function peg$parsediv() {
            var s0;
            peg$silentFails++;
            s0 = peg$parsepct();
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            return s0;
          }
          function peg$parsedec() {
            var s0, s1, s2;
            s0 = peg$parsepct();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 43) {
                s1 = peg$c10;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e27);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepct();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f34(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                  s1 = peg$c11;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e29);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsepct();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f35(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
            return s0;
          }
          function peg$parseint() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            s2 = peg$parsenum();
            if (s2 !== peg$FAILED) {
              s0 = peg$f36(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            return s0;
          }
          function peg$parsesp() {
            var s0, s1;
            s0 = [];
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (peg$r2.test(input.charAt(peg$currPos))) {
                  s1 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
              }
            } else {
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsehex() {
            var s0, s1;
            s0 = peg$currPos;
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e37);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f37(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _TabularPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e0 = peg$otherExpectation("decl_start");
          var peg$e1 = peg$otherExpectation("decl_end");
          var peg$e2 = peg$otherExpectation("vert");
          var peg$e3 = peg$anyExpectation();
          var peg$e4 = peg$otherExpectation("l");
          var peg$e5 = peg$otherExpectation("r");
          var peg$e6 = peg$otherExpectation("c");
          var peg$e7 = peg$otherExpectation("p");
          var peg$e8 = peg$otherExpectation("m");
          var peg$e9 = peg$otherExpectation("b");
          var peg$e10 = peg$otherExpectation("w");
          var peg$e11 = peg$otherExpectation("W");
          var peg$e12 = peg$otherExpectation("X");
          var peg$e13 = peg$otherExpectation("!");
          var peg$e14 = peg$otherExpectation("@");
          var peg$e15 = peg$otherExpectation("<");
          var peg$e16 = peg$otherExpectation(">");
          var peg$e17 = peg$otherExpectation("group");
          var peg$e18 = peg$otherExpectation("whitespace");
          var peg$f0 = function(c) {
            return c;
          };
          var peg$f1 = function(cols) {
            return cols;
          };
          var peg$f2 = function() {
            return [];
          };
          var peg$f3 = function(divs1, start, a, end, divs2) {
            return {
              type: "column",
              pre_dividers: divs1,
              post_dividers: divs2,
              before_start_code: start,
              before_end_code: end,
              alignment: a
            };
          };
          var peg$f4 = function() {
            return {
              type: "vert_divider"
            };
          };
          var peg$f5 = function(b, g) {
            return {
              type: "bang_divider",
              content: g[0].content
            };
          };
          var peg$f6 = function(g) {
            return {
              type: "at_divider",
              content: g[0].content
            };
          };
          var peg$f7 = function(div) {
            return div;
          };
          var peg$f8 = function(g) {
            return { type: "decl_code", code: g[0].content };
          };
          var peg$f9 = function(g) {
            return { type: "decl_code", code: g[0].content };
          };
          var peg$f10 = function() {
            return { type: "alignment", alignment: "left" };
          };
          var peg$f11 = function() {
            return { type: "alignment", alignment: "center" };
          };
          var peg$f12 = function() {
            return { type: "alignment", alignment: "right" };
          };
          var peg$f13 = function() {
            return { type: "alignment", alignment: "X" };
          };
          var peg$f14 = function() {
            return "top";
          };
          var peg$f15 = function() {
            return "default";
          };
          var peg$f16 = function() {
            return "bottom";
          };
          var peg$f17 = function(a, g) {
            return {
              type: "alignment",
              alignment: "parbox",
              baseline: a,
              size: g[0].content
            };
          };
          var peg$f18 = function(g1, g2) {
            return {
              type: "alignment",
              alignment: "parbox",
              baseline: g1[0].content,
              size: g2[0].content
            };
          };
          var peg$f19 = function(tok) {
            return options.matchChar(tok, "|");
          };
          var peg$f20 = function(tok) {
            return options.matchChar(tok, "l");
          };
          var peg$f21 = function(tok) {
            return options.matchChar(tok, "r");
          };
          var peg$f22 = function(tok) {
            return options.matchChar(tok, "c");
          };
          var peg$f23 = function(tok) {
            return options.matchChar(tok, "p");
          };
          var peg$f24 = function(tok) {
            return options.matchChar(tok, "m");
          };
          var peg$f25 = function(tok) {
            return options.matchChar(tok, "b");
          };
          var peg$f26 = function(tok) {
            return options.matchChar(tok, "w");
          };
          var peg$f27 = function(tok) {
            return options.matchChar(tok, "W");
          };
          var peg$f28 = function(tok) {
            return options.matchChar(tok, "X");
          };
          var peg$f29 = function(tok) {
            return options.matchChar(tok, "!");
          };
          var peg$f30 = function(tok) {
            return options.matchChar(tok, "@");
          };
          var peg$f31 = function(tok) {
            return options.matchChar(tok, "<");
          };
          var peg$f32 = function(tok) {
            return options.matchChar(tok, ">");
          };
          var peg$f33 = function(tok) {
            return options.isGroup(tok);
          };
          var peg$f34 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parsecolumn();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              s2 = peg$f0(s3);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parsecolumn();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  s2 = peg$f0(s3);
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f1(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseEOL();
              if (s1 !== peg$FAILED) {
                s1 = peg$f2();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parsecolumn() {
            var s0, s1, s2, s3, s4, s5, s6;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsecolumn_divider();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsecolumn_divider();
            }
            s2 = peg$parsedecl_start();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s3 = peg$parsealignment();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsedecl_end();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              s5 = [];
              s6 = peg$parsecolumn_divider();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsecolumn_divider();
              }
              s0 = peg$f3(s1, s2, s3, s4, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecolumn_divider() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            s2 = peg$currPos;
            s3 = peg$parsevert();
            if (s3 !== peg$FAILED) {
              s3 = peg$f4();
            }
            s2 = s3;
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parsebang();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsegroup();
                if (s4 !== peg$FAILED) {
                  s2 = peg$f5(s3, s4);
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseat();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsegroup();
                  if (s4 !== peg$FAILED) {
                    s2 = peg$f6(s4);
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              s0 = peg$f7(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedecl_start() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parsegreater();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsegroup();
              if (s2 !== peg$FAILED) {
                s0 = peg$f8(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            return s0;
          }
          function peg$parsedecl_end() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseless();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsegroup();
              if (s2 !== peg$FAILED) {
                s0 = peg$f9(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            return s0;
          }
          function peg$parsealignment() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsel();
            if (s1 !== peg$FAILED) {
              s1 = peg$f10();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsec();
              if (s1 !== peg$FAILED) {
                s1 = peg$f11();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parser();
                if (s1 !== peg$FAILED) {
                  s1 = peg$f12();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseX();
                  if (s1 !== peg$FAILED) {
                    s1 = peg$f13();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    s2 = peg$parsep();
                    if (s2 !== peg$FAILED) {
                      s2 = peg$f14();
                    }
                    s1 = s2;
                    if (s1 === peg$FAILED) {
                      s1 = peg$currPos;
                      s2 = peg$parsem();
                      if (s2 !== peg$FAILED) {
                        s2 = peg$f15();
                      }
                      s1 = s2;
                      if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        s2 = peg$parseb();
                        if (s2 !== peg$FAILED) {
                          s2 = peg$f16();
                        }
                        s1 = s2;
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = [];
                      s3 = peg$parse_();
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$parse_();
                      }
                      s3 = peg$parsegroup();
                      if (s3 !== peg$FAILED) {
                        s0 = peg$f17(s1, s3);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsew();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseW();
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                          s2.push(s3);
                          s3 = peg$parse_();
                        }
                        s3 = peg$parsegroup();
                        if (s3 !== peg$FAILED) {
                          s4 = [];
                          s5 = peg$parse_();
                          while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$parse_();
                          }
                          s5 = peg$parsegroup();
                          if (s5 !== peg$FAILED) {
                            s0 = peg$f18(s3, s5);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parsevert() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f19(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            return s0;
          }
          function peg$parsel() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f20(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            return s0;
          }
          function peg$parser() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f21(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            return s0;
          }
          function peg$parsec() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f22(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            return s0;
          }
          function peg$parsep() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f23(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            return s0;
          }
          function peg$parsem() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f24(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            return s0;
          }
          function peg$parseb() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f25(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            return s0;
          }
          function peg$parsew() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f26(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            return s0;
          }
          function peg$parseW() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f27(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            return s0;
          }
          function peg$parseX() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f28(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            return s0;
          }
          function peg$parsebang() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f29(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
            return s0;
          }
          function peg$parseat() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f30(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            return s0;
          }
          function peg$parseless() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f31(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            return s0;
          }
          function peg$parsegreater() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f32(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            return s0;
          }
          function peg$parsegroup() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f33(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            return s0;
          }
          function peg$parse_() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f34(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          if (!options.isHash) {
            try {
              Object.assign(options, {
                matchChar: (node, char) => node.type === "string" && node.content === char,
                isGroup: (node) => node.type === "group",
                isWhitespace: (node) => node.type === "whitespace"
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _SystemePegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { body: peg$parsebody };
          var peg$startRuleFunction = peg$parsebody;
          var peg$e1 = peg$otherExpectation("item");
          var peg$e2 = peg$anyExpectation();
          var peg$e3 = peg$otherExpectation("equation");
          var peg$e4 = peg$otherExpectation("trailing comment");
          var peg$e5 = peg$otherExpectation("comment only line");
          var peg$e6 = peg$otherExpectation("non-var token");
          var peg$e7 = peg$otherExpectation("token");
          var peg$e8 = peg$otherExpectation("same line comment");
          var peg$e9 = peg$otherExpectation("own line comment");
          var peg$e10 = peg$otherExpectation(",");
          var peg$e11 = peg$otherExpectation("@");
          var peg$e12 = peg$otherExpectation("variable token");
          var peg$e13 = peg$otherExpectation("+/-");
          var peg$e14 = peg$otherExpectation("=");
          var peg$f0 = function(a, b) {
            return a.concat(b ? b : []);
          };
          var peg$f1 = function() {
            return [];
          };
          var peg$f3 = function(op, a, b, c) {
            return { type: "item", op, variable: b, content: a.concat(b, c) };
          };
          var peg$f4 = function(op, a) {
            return { type: "item", op, variable: null, content: a };
          };
          var peg$f5 = function(line, sep, comment) {
            return { ...line, sep: [].concat(sep), trailingComment: comment };
          };
          var peg$f6 = function(line, comment) {
            return { ...line, trailingComment: comment };
          };
          var peg$f7 = function(eq, ann) {
            return {
              type: "line",
              equation: eq,
              annotation: ann,
              sep: null
            };
          };
          var peg$f8 = function(at, ann) {
            return at ? { type: "annotation", marker: at, content: ann } : null;
          };
          var peg$f9 = function(left, eq, right) {
            return { type: "equation", left, right, equals: eq };
          };
          var peg$f10 = function(x) {
            return x;
          };
          var peg$f11 = function(x) {
            return {
              type: "line",
              trailingComment: x
            };
          };
          var peg$f12 = function(v, s) {
            return [v].concat(s ? s : []);
          };
          var peg$f13 = function(t) {
            return t;
          };
          var peg$f14 = function(x) {
            return x;
          };
          var peg$f15 = function(x) {
            return x;
          };
          var peg$f16 = function(tok) {
            return options.isSameLineComment(tok);
          };
          var peg$f17 = function(tok) {
            return tok;
          };
          var peg$f18 = function(tok) {
            return options.isOwnLineComment(tok);
          };
          var peg$f19 = function(tok) {
            return tok;
          };
          var peg$f20 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$f21 = function(tok) {
            return tok;
          };
          var peg$f22 = function(tok) {
            return options.isSep(tok);
          };
          var peg$f23 = function(tok) {
            return tok;
          };
          var peg$f24 = function(tok) {
            return options.isAt(tok);
          };
          var peg$f25 = function(tok) {
            return tok;
          };
          var peg$f26 = function(tok) {
            return options.isVar(tok);
          };
          var peg$f27 = function(tok) {
            return tok;
          };
          var peg$f28 = function(tok) {
            return options.isOperation(tok);
          };
          var peg$f29 = function(tok) {
            return tok;
          };
          var peg$f30 = function(tok) {
            return options.isEquals(tok);
          };
          var peg$f31 = function(tok) {
            return tok;
          };
          var peg$f32 = function(tok) {
            return options.isSubscript(tok);
          };
          var peg$f33 = function(tok) {
            return tok;
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsebody() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsecomment_only_line();
            if (s2 === peg$FAILED) {
              s2 = peg$parseline_with_sep();
              if (s2 === peg$FAILED) {
                s2 = peg$parsepartial_line_with_comment();
              }
            }
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsecomment_only_line();
              if (s2 === peg$FAILED) {
                s2 = peg$parseline_with_sep();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsepartial_line_with_comment();
                }
              }
            }
            s2 = peg$parseline_without_sep();
            if (s2 === peg$FAILED) {
              s2 = peg$parseEOL();
            }
            if (s2 !== peg$FAILED) {
              s0 = peg$f0(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseEOL();
              if (s1 !== peg$FAILED) {
                s1 = peg$f1();
              }
              s0 = s1;
            }
            return s0;
          }
          function peg$parseitem() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$parseoperation();
            if (s1 === peg$FAILED) {
              s1 = null;
            }
            s2 = [];
            s3 = peg$parse_();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parse_();
            }
            s3 = [];
            s4 = peg$parsenon_var_token();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsenon_var_token();
            }
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            s5 = peg$parsevar();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parse_();
              }
              s7 = [];
              s8 = peg$parsetoken();
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                s8 = peg$parsetoken();
              }
              s8 = [];
              s9 = peg$parse_();
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                s9 = peg$parse_();
              }
              s0 = peg$f3(s1, s3, s5, s7);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseoperation();
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              s3 = [];
              s4 = peg$parsenon_var_token();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsenon_var_token();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parse_();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parse_();
                }
                s0 = peg$f4(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            return s0;
          }
          function peg$parseline_with_sep() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parseline_without_sep();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsesep();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetrailing_comment();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                s0 = peg$f5(s1, s2, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsepartial_line_with_comment() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseline_without_sep();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetrailing_comment();
              if (s2 !== peg$FAILED) {
                s0 = peg$f6(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseline_without_sep() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            peg$silentFails--;
            if (s2 !== peg$FAILED) {
              peg$currPos = s1;
              s1 = void 0;
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseequation();
              s3 = peg$parseannotation();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = peg$f7(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseannotation() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parseat();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsenon_sep_token();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsenon_sep_token();
              }
              s0 = peg$f8(s1, s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseequation() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseitem();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseitem();
            }
            s2 = peg$parseequals();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s3 = [];
            s4 = peg$parsetoken();
            if (s4 === peg$FAILED) {
              s4 = peg$parseoperation();
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsetoken();
              if (s4 === peg$FAILED) {
                s4 = peg$parseoperation();
              }
            }
            s0 = peg$f9(s1, s2, s3);
            peg$silentFails--;
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
            return s0;
          }
          function peg$parsetrailing_comment() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            s2 = peg$parsesame_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f10(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            return s0;
          }
          function peg$parsecomment_only_line() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            s2 = peg$parseown_line_comment();
            if (s2 !== peg$FAILED) {
              s0 = peg$f11(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            return s0;
          }
          function peg$parsevar() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$parsevar_token();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parse_();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parse_();
              }
              s3 = peg$parsesubscript();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = peg$f12(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsenon_var_token() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            s2 = peg$parsevar();
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetoken();
              if (s2 !== peg$FAILED) {
                s0 = peg$f13(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            return s0;
          }
          function peg$parsenon_sep_token() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            s2 = peg$parsesep();
            if (s2 === peg$FAILED) {
              s2 = peg$parsetrailing_comment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseown_line_comment();
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f14(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsetoken() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            s2 = peg$parsesep();
            if (s2 === peg$FAILED) {
              s2 = peg$parseat();
              if (s2 === peg$FAILED) {
                s2 = peg$parseoperation();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseequals();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsetrailing_comment();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parseown_line_comment();
                    }
                  }
                }
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f15(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
            return s0;
          }
          function peg$parsesame_line_comment() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f16(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f17(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            return s0;
          }
          function peg$parseown_line_comment() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f18(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f19(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            return s0;
          }
          function peg$parse_() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f20(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f21(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesep() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f22(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f23(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            return s0;
          }
          function peg$parseat() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f24(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f25(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            return s0;
          }
          function peg$parsevar_token() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f26(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f27(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            return s0;
          }
          function peg$parseoperation() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              s4 = peg$f28(s2);
              if (s4) {
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s0 = peg$f29(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
            return s0;
          }
          function peg$parseequals() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f30(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f31(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            return s0;
          }
          function peg$parsesubscript() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f32(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f33(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseEOL() {
            var s0, s1;
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = void 0;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          if (!options.isWhitespace) {
            try {
              Object.assign(options, {
                isSep: (node) => node.type === "string" && node.content === ",",
                isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
                isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
                isEquals: (node) => node.type === "string" && node.content === "=",
                isAt: (node) => node.type === "string" && node.content === "@",
                isSubscript: (node) => node.content === "_",
                isWhitespace: (node) => node.type === "whitespace",
                isSameLineComment: (node) => node.type === "comment" && node.sameline,
                isOwnLineComment: (node) => node.type === "comment" && !node.sameline
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _GluePegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { root: peg$parseroot };
          var peg$startRuleFunction = peg$parseroot;
          var peg$c0 = "plus";
          var peg$c1 = "minus";
          var peg$c2 = "pt";
          var peg$c3 = "mm";
          var peg$c4 = "cm";
          var peg$c5 = "in";
          var peg$c6 = "ex";
          var peg$c7 = "em";
          var peg$c8 = "bp";
          var peg$c9 = "pc";
          var peg$c10 = "dd";
          var peg$c11 = "cc";
          var peg$c12 = "nd";
          var peg$c13 = "nc";
          var peg$c14 = "sp";
          var peg$c15 = "filll";
          var peg$c16 = "fill";
          var peg$c17 = "fil";
          var peg$c18 = ".";
          var peg$c19 = "+";
          var peg$c20 = "-";
          var peg$r0 = /^[0-9]/;
          var peg$e0 = peg$anyExpectation();
          var peg$e1 = peg$literalExpectation("plus", false);
          var peg$e2 = peg$literalExpectation("minus", false);
          var peg$e3 = peg$literalExpectation("pt", false);
          var peg$e4 = peg$literalExpectation("mm", false);
          var peg$e5 = peg$literalExpectation("cm", false);
          var peg$e6 = peg$literalExpectation("in", false);
          var peg$e7 = peg$literalExpectation("ex", false);
          var peg$e8 = peg$literalExpectation("em", false);
          var peg$e9 = peg$literalExpectation("bp", false);
          var peg$e10 = peg$literalExpectation("pc", false);
          var peg$e11 = peg$literalExpectation("dd", false);
          var peg$e12 = peg$literalExpectation("cc", false);
          var peg$e13 = peg$literalExpectation("nd", false);
          var peg$e14 = peg$literalExpectation("nc", false);
          var peg$e15 = peg$literalExpectation("sp", false);
          var peg$e16 = peg$literalExpectation("filll", false);
          var peg$e17 = peg$literalExpectation("fill", false);
          var peg$e18 = peg$literalExpectation("fil", false);
          var peg$e19 = peg$otherExpectation("number");
          var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
          var peg$e21 = peg$literalExpectation(".", false);
          var peg$e22 = peg$literalExpectation("+", false);
          var peg$e23 = peg$literalExpectation("-", false);
          var peg$f0 = function(b, st, sh) {
            return {
              type: "glue",
              fixed: b,
              stretchable: st,
              shrinkable: sh,
              position: location()
            };
          };
          var peg$f1 = function(glue) {
            return glue;
          };
          var peg$f2 = function(n, u) {
            return { type: "dim", value: n, unit: u };
          };
          var peg$f3 = function(n, u) {
            return { type: "dim", value: n, unit: u };
          };
          var peg$f4 = function(n, u) {
            return { type: "dim", value: n, unit: u };
          };
          var peg$f5 = function(n) {
            return parseFloat(n);
          };
          var peg$currPos = 0;
          var peg$savedPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function location() {
            return peg$computeLocation(peg$savedPos, peg$currPos);
          }
          function peg$literalExpectation(text2, ignoreCase) {
            return { type: "literal", text: text2, ignoreCase };
          }
          function peg$classExpectation(parts, inverted, ignoreCase) {
            return { type: "class", parts, inverted, ignoreCase };
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parseroot() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsebase();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsestretchable();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$parseshrinkable();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              peg$savedPos = s1;
              s1 = peg$f0(s2, s3, s4);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsebase() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsenumber();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseunit();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsestretchable() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c0) {
              s1 = peg$c0;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsenumber();
              if (s2 !== peg$FAILED) {
                s3 = peg$parserubber_unit();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseshrinkable() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c1) {
              s1 = peg$c1;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsenumber();
              if (s2 !== peg$FAILED) {
                s3 = peg$parserubber_unit();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f4(s2, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseunit() {
            var s0;
            if (input.substr(peg$currPos, 2) === peg$c2) {
              s0 = peg$c2;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c3) {
                s0 = peg$c3;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c4) {
                  s0 = peg$c4;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c5) {
                    s0 = peg$c5;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e6);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c6) {
                      s0 = peg$c6;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e7);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c7) {
                        s0 = peg$c7;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e8);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c8) {
                          s0 = peg$c8;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e9);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c9) {
                            s0 = peg$c9;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e10);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c10) {
                              s0 = peg$c10;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e11);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c11) {
                                s0 = peg$c11;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e12);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c12) {
                                  s0 = peg$c12;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e13);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c13) {
                                    s0 = peg$c13;
                                    peg$currPos += 2;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e14);
                                    }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c14) {
                                      s0 = peg$c14;
                                      peg$currPos += 2;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e15);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parserubber_unit() {
            var s0;
            s0 = peg$parseunit();
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c15) {
                s0 = peg$c15;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e16);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c16) {
                  s0 = peg$c16;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e17);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c17) {
                    s0 = peg$c17;
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e18);
                    }
                  }
                }
              }
            }
            return s0;
          }
          function peg$parsenumber() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = peg$parsesign();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s4 = peg$currPos;
            s5 = [];
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
            if (input.charCodeAt(peg$currPos) === 46) {
              s6 = peg$c18;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e21);
              }
            }
            if (s6 !== peg$FAILED) {
              s7 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              if (s8 !== peg$FAILED) {
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  if (peg$r0.test(input.charAt(peg$currPos))) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              } else {
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$r0.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = input.substring(s1, peg$currPos);
            } else {
              s1 = s2;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f5(s1);
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            return s0;
          }
          function peg$parsesign() {
            var s0;
            if (input.charCodeAt(peg$currPos) === 43) {
              s0 = peg$c19;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s0 = peg$c20;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
            }
            return s0;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var _TikzPegParser = (
      // Generated by Peggy 3.0.2.
      //
      // https://peggyjs.org/
      function() {
        function peg$subclass(child, parent) {
          function C() {
            this.constructor = child;
          }
          C.prototype = parent.prototype;
          child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
          var self2 = Error.call(this, message);
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
          }
          self2.expected = expected;
          self2.found = found;
          self2.location = location;
          self2.name = "SyntaxError";
          return self2;
        }
        peg$subclass(peg$SyntaxError, Error);
        function peg$padEnd(str, targetLength, padString) {
          padString = padString || " ";
          if (str.length > targetLength) {
            return str;
          }
          targetLength -= str.length;
          padString += padString.repeat(targetLength);
          return str + padString.slice(0, targetLength);
        }
        peg$SyntaxError.prototype.format = function(sources) {
          var str = "Error: " + this.message;
          if (this.location) {
            var src = null;
            var k;
            for (k = 0; k < sources.length; k++) {
              if (sources[k].source === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
              }
            }
            var s = this.location.start;
            var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
            var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
              var e = this.location.end;
              var filler = peg$padEnd("", offset_s.line.toString().length, " ");
              var line = src[s.line - 1];
              var last = s.line === e.line ? e.column : line.length + 1;
              var hatLen = last - s.column || 1;
              str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
            } else {
              str += "\n at " + loc;
            }
          }
          return str;
        };
        peg$SyntaxError.buildMessage = function(expected, found) {
          var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
              return '"' + literalEscape(expectation.text) + '"';
            },
            class: function(expectation) {
              var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
              });
              return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
            },
            any: function() {
              return "any character";
            },
            end: function() {
              return "end of input";
            },
            other: function(expectation) {
              return expectation.description;
            }
          };
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }
          function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
              return "\\x" + hex(ch);
            });
          }
          function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
          }
          function describeExpected(expected2) {
            var descriptions = expected2.map(describeExpectation);
            var i, j;
            descriptions.sort();
            if (descriptions.length > 0) {
              for (i = 1, j = 1; i < descriptions.length; i++) {
                if (descriptions[i - 1] !== descriptions[i]) {
                  descriptions[j] = descriptions[i];
                  j++;
                }
              }
              descriptions.length = j;
            }
            switch (descriptions.length) {
              case 1:
                return descriptions[0];
              case 2:
                return descriptions[0] + " or " + descriptions[1];
              default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
          }
          function describeFound(found2) {
            return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
          }
          return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
          options = options !== void 0 ? options : {};
          var peg$FAILED = {};
          var peg$source = options.grammarSource;
          var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
          var peg$startRuleFunction = peg$parsepath_spec;
          var peg$e0 = peg$anyExpectation();
          var peg$e3 = peg$otherExpectation("comment");
          var peg$e4 = peg$otherExpectation("floating comment");
          var peg$e5 = peg$otherExpectation("operation");
          var peg$e6 = peg$otherExpectation("=");
          var peg$f0 = function(v) {
            return v;
          };
          var peg$f1 = function(ops) {
            return { type: "path_spec", content: ops };
          };
          var peg$f2 = function(c1, op, comment) {
            return { op, comment };
          };
          var peg$f3 = function(c1, ops, c2, body) {
            const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
              (x) => x
            );
            const attribute = ops.map((x) => x.op.content.content).join(" ");
            return {
              type: "animation",
              comments,
              attribute,
              content: body.content
            };
          };
          var peg$f4 = function(start, b) {
            return { ...b, start, type: "foreach" };
          };
          var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
            const comments = [c1, c2, c3, c4].filter((x) => x);
            return {
              type: "foreach_body",
              variables,
              options: options2 && options2.content,
              list,
              command,
              comments
            };
          };
          var peg$f6 = function(c1, options2, c2, body) {
            const comments = [c1, c2].filter((x) => x);
            return {
              type: "svg_operation",
              options: options2 && options2.content,
              content: body,
              comments
            };
          };
          var peg$f7 = function(c1, c2, coord, c3, c4, x) {
            return { coord: x, comment: c4 };
          };
          var peg$f8 = function(c1, c2, coord, c3, a, c5) {
            const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
            return {
              type: "curve_to",
              controls: a ? [coord, a.coord] : [coord],
              comments
            };
          };
          var peg$f9 = function() {
            return { type: "line_to", command: "|-" };
          };
          var peg$f10 = function() {
            return { type: "line_to", command: "-|" };
          };
          var peg$f11 = function() {
            return { type: "line_to", command: "--" };
          };
          var peg$f12 = function(prefix, content) {
            return { type: "coordinate", content, prefix };
          };
          var peg$f13 = function(content) {
            return { type: "square_brace_group", content };
          };
          var peg$f14 = function(v) {
            return { type: "unknown", content: v };
          };
          var peg$f19 = function(tok) {
            return options.isComment(tok);
          };
          var peg$f20 = function(tok) {
            return tok;
          };
          var peg$f21 = function(tok) {
            return options.isWhitespace(tok);
          };
          var peg$f22 = function(tok) {
            return tok;
          };
          var peg$f23 = function(c) {
            return c;
          };
          var peg$f24 = function(tok) {
            return options.isOperation(tok);
          };
          var peg$f25 = function(tok) {
            return { type: "operation", content: tok };
          };
          var peg$f26 = function(tok) {
            return options.isChar(tok, "=");
          };
          var peg$f27 = function(tok) {
            return tok;
          };
          var peg$f28 = function(tok) {
            return options.isChar(tok, "[");
          };
          var peg$f29 = function(tok) {
            return tok;
          };
          var peg$f30 = function(tok) {
            return options.isChar(tok, "]");
          };
          var peg$f31 = function(tok) {
            return tok;
          };
          var peg$f32 = function(tok) {
            return options.isChar(tok, "(");
          };
          var peg$f33 = function(tok) {
            return tok;
          };
          var peg$f34 = function(tok) {
            return options.isChar(tok, ")");
          };
          var peg$f35 = function(tok) {
            return tok;
          };
          var peg$f36 = function(tok) {
            return options.isChar(tok, "+");
          };
          var peg$f37 = function(tok) {
            return tok;
          };
          var peg$f38 = function(tok) {
            return options.isChar(tok, "-");
          };
          var peg$f39 = function(tok) {
            return tok;
          };
          var peg$f40 = function(tok) {
            return options.isChar(tok, "|");
          };
          var peg$f41 = function(tok) {
            return tok;
          };
          var peg$f42 = function(tok) {
            return options.isChar(tok, ".");
          };
          var peg$f43 = function(tok) {
            return tok;
          };
          var peg$f44 = function(tok) {
            return options.isChar(tok, "controls");
          };
          var peg$f45 = function(tok) {
            return tok;
          };
          var peg$f46 = function(tok) {
            return options.isChar(tok, "and");
          };
          var peg$f47 = function(tok) {
            return tok;
          };
          var peg$f48 = function(tok) {
            return options.isChar(tok, "svg");
          };
          var peg$f49 = function(tok) {
            return tok;
          };
          var peg$f50 = function(tok) {
            return options.isGroup(tok);
          };
          var peg$f51 = function(tok) {
            return tok;
          };
          var peg$f52 = function(tok) {
            return options.isAnyMacro(tok);
          };
          var peg$f53 = function(tok) {
            return tok;
          };
          var peg$f54 = function(tok) {
            return options.isChar(tok, "foreach");
          };
          var peg$f55 = function(tok) {
            return tok;
          };
          var peg$f56 = function(tok) {
            return options.isMacro(tok, "foreach");
          };
          var peg$f57 = function(tok) {
            return tok;
          };
          var peg$f58 = function(tok) {
            return options.isChar(tok, "in");
          };
          var peg$f59 = function(tok) {
            return tok;
          };
          var peg$f60 = function(tok) {
            return options.isChar(tok, ":");
          };
          var peg$f61 = function(tok) {
            return tok;
          };
          var peg$currPos = 0;
          var peg$posDetailsCache = [{ line: 1, column: 1 }];
          var peg$maxFailPos = 0;
          var peg$maxFailExpected = [];
          var peg$silentFails = 0;
          var peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function peg$anyExpectation() {
            return { type: "any" };
          }
          function peg$endExpectation() {
            return { type: "end" };
          }
          function peg$otherExpectation(description) {
            return { type: "other", description };
          }
          function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos];
            var p;
            if (details) {
              return details;
            } else {
              p = pos - 1;
              while (!peg$posDetailsCache[p]) {
                p--;
              }
              details = peg$posDetailsCache[p];
              details = {
                line: details.line,
                column: details.column
              };
              while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                  details.line++;
                  details.column = 1;
                } else {
                  details.column++;
                }
                p++;
              }
              peg$posDetailsCache[pos] = details;
              return details;
            }
          }
          function peg$computeLocation(startPos, endPos, offset2) {
            var startPosDetails = peg$computePosDetails(startPos);
            var endPosDetails = peg$computePosDetails(endPos);
            var res = {
              source: peg$source,
              start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
              },
              end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
              }
            };
            if (offset2 && peg$source && typeof peg$source.offset === "function") {
              res.start = peg$source.offset(res.start);
              res.end = peg$source.offset(res.end);
            }
            return res;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildStructuredError(expected2, found, location2) {
            return new peg$SyntaxError(
              peg$SyntaxError.buildMessage(expected2, found),
              expected2,
              found,
              location2
            );
          }
          function peg$parsepath_spec() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parsesquare_brace_group();
            if (s3 === peg$FAILED) {
              s3 = peg$parsecoordinate();
              if (s3 === peg$FAILED) {
                s3 = peg$parsecurve_to();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseline_to();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsesvg();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseforeach();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseoperation();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parsecomment();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parseanimation();
                            if (s3 === peg$FAILED) {
                              s3 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              s2 = peg$f0(s3);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parsesquare_brace_group();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsecoordinate();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsecurve_to();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseline_to();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parsesvg();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseforeach();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parseoperation();
                            if (s3 === peg$FAILED) {
                              s3 = peg$parsecomment();
                              if (s3 === peg$FAILED) {
                                s3 = peg$parseanimation();
                                if (s3 === peg$FAILED) {
                                  s3 = peg$parseunknown();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parse_();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parse_();
                  }
                  s2 = peg$f0(s3);
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f1(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parseanimation() {
            var s0, s1, s2, s3, s4, s5, s6;
            s0 = peg$currPos;
            s1 = peg$parsecolon();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_comment_();
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                s4 = peg$f2(s2, s5, s6);
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$currPos;
                  s5 = peg$parseoperation();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_comment_();
                    s4 = peg$f2(s2, s5, s6);
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseequals();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_comment_();
                  s6 = peg$parsegroup();
                  if (s6 !== peg$FAILED) {
                    s0 = peg$f3(s2, s3, s5, s6);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseforeach() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseforeach_keyword();
            if (s1 === peg$FAILED) {
              s1 = peg$parseforeach_macro();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseforeach_body();
              if (s2 !== peg$FAILED) {
                s0 = peg$f4(s1, s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseforeach_body() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
            s0 = peg$currPos;
            s1 = peg$parse_comment_();
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parsein_keyword();
            if (s6 === peg$FAILED) {
              s6 = peg$parsesquare_brace_group();
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              s6 = peg$parsein_keyword();
              if (s6 === peg$FAILED) {
                s6 = peg$parsesquare_brace_group();
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
            s2 = input.substring(s2, peg$currPos);
            s3 = peg$parsesquare_brace_group();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s4 = peg$parse_comment_();
            s5 = peg$parsein_keyword();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$parsegroup();
              if (s7 === peg$FAILED) {
                s7 = peg$parsemacro();
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_comment_();
                s9 = peg$parseforeach();
                if (s9 === peg$FAILED) {
                  s9 = peg$parsegroup();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parsemacro();
                  }
                }
                if (s9 !== peg$FAILED) {
                  s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesvg() {
            var s0, s1, s2, s3, s4, s5;
            s0 = peg$currPos;
            s1 = peg$parsesvg_keyword();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_comment_();
              s3 = peg$parsesquare_brace_group();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s4 = peg$parse_comment_();
              s5 = peg$parsegroup();
              if (s5 !== peg$FAILED) {
                s0 = peg$f6(s2, s3, s4, s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecurve_to() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            s0 = peg$currPos;
            s1 = peg$parsedotdot();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_comment_();
              s3 = peg$parsecontrols_keyword();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_comment_();
                s5 = peg$parsecoordinate();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_comment_();
                  s7 = peg$currPos;
                  s8 = peg$parseand_keyword();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_comment_();
                    s10 = peg$parsecoordinate();
                    if (s10 !== peg$FAILED) {
                      s7 = peg$f7(s2, s4, s5, s6, s9, s10);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  s8 = peg$parse_comment_();
                  s9 = peg$parsedotdot();
                  if (s9 !== peg$FAILED) {
                    s0 = peg$f8(s2, s4, s5, s6, s7, s8);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseline_to() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsepipe();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseminus();
              if (s2 !== peg$FAILED) {
                s0 = peg$f9();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseminus();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepipe();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f10();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseminus();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseminus();
                  if (s2 !== peg$FAILED) {
                    s0 = peg$f11();
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
            return s0;
          }
          function peg$parsecoordinate() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = peg$parseplus();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseplus();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s1 = input.substring(s1, peg$currPos);
            s2 = peg$parseopen_paren();
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parseclose_paren();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parseclose_paren();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s3 = input.substring(s3, peg$currPos);
              s4 = peg$parseclose_paren();
              if (s4 !== peg$FAILED) {
                s0 = peg$f12(s1, s3);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesquare_brace_group() {
            var s0, s1, s2, s3, s4, s5, s6;
            s0 = peg$currPos;
            s1 = peg$parseopen_square_brace();
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              s6 = peg$parseclose_square_brace();
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$currPos;
                peg$silentFails++;
                s6 = peg$parseclose_square_brace();
                peg$silentFails--;
                if (s6 === peg$FAILED) {
                  s5 = void 0;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              s2 = input.substring(s2, peg$currPos);
              s3 = peg$parseclose_square_brace();
              if (s3 !== peg$FAILED) {
                s0 = peg$f13(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedotdot() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parsedot();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsedot();
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseunknown() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = peg$f14(s1);
            }
            s0 = s1;
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f19(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f20(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            return s0;
          }
          function peg$parse_() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f21(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f22(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parse_comment_() {
            var s0, s1, s2, s3, s4;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            s2 = peg$parsecomment();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s0 = peg$f23(s2);
            peg$silentFails--;
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
            return s0;
          }
          function peg$parseoperation() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f24(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f25(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            return s0;
          }
          function peg$parseequals() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f26(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f27(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            peg$silentFails--;
            if (s0 === peg$FAILED) {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            return s0;
          }
          function peg$parseopen_square_brace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f28(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f29(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseclose_square_brace() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f30(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f31(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseopen_paren() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f32(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f33(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseclose_paren() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f34(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f35(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseplus() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f36(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f37(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseminus() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f38(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f39(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsepipe() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f40(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f41(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsedot() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f42(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f43(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecontrols_keyword() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f44(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f45(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseand_keyword() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f46(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f47(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsesvg_keyword() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f48(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f49(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsegroup() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f50(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f51(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsemacro() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f52(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f53(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseforeach_keyword() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f54(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f55(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parseforeach_macro() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f56(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f57(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsein_keyword() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f58(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f59(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          function peg$parsecolon() {
            var s0, s1, s2;
            s0 = peg$currPos;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$f60(s1);
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = peg$f61(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            return s0;
          }
          if (!options.isWhitespace) {
            try {
              Object.assign(options, {
                isChar: (node, char) => node.type === "string" && node.content === char,
                isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
                isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
                isSameLineComment: (node) => node.type === "comment" && node.sameline,
                isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
                isComment: (node) => node.type === "comment",
                isGroup: (node) => node.type === "group",
                isMacro: (node, name) => node.type === "macro" && node.content === name,
                isAnyMacro: (node) => node.type === "macro"
              });
            } catch (e) {
              console.warn("Error when initializing parser", e);
            }
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail(peg$endExpectation());
            }
            throw peg$buildStructuredError(
              peg$maxFailExpected,
              peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
              peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
            );
          }
        }
        return {
          SyntaxError: peg$SyntaxError,
          parse: peg$parse
        };
      }()
    );
    var LatexPegParser = _LatexPegParser;
    var AlignEnvironmentPegParser = _AlignEnvironmentPegParser;
    var ArgSpecPegParser = _ArgSpecPegParser;
    var PgfkeysPegParser = _PgfkeysPegParser;
    var MacroSubstitutionPegParser = _MacroSubstitutionPegParser;
    var LigaturesPegParser = _LigaturesPegParser;
    var XColorPegParser = _XColorPegParser;
    var TabularPegParser = _TabularPegParser;
    var SystemePegParser = _SystemePegParser;
    var GluePegParser = _GluePegParser;
    var TikzPegParser = _TikzPegParser;
    exports.AlignEnvironmentPegParser = AlignEnvironmentPegParser;
    exports.ArgSpecPegParser = ArgSpecPegParser;
    exports.GluePegParser = GluePegParser;
    exports.LatexPegParser = LatexPegParser;
    exports.LigaturesPegParser = LigaturesPegParser;
    exports.MacroSubstitutionPegParser = MacroSubstitutionPegParser;
    exports.PgfkeysPegParser = PgfkeysPegParser;
    exports.SystemePegParser = SystemePegParser;
    exports.TabularPegParser = TabularPegParser;
    exports.TikzPegParser = TikzPegParser;
    exports.XColorPegParser = XColorPegParser;
    exports.decorateArrayForPegjs = decorateArrayForPegjs;
    exports.splitStringsIntoSingleChars = splitStringsIntoSingleChars;
  }
});

// node_modules/unicode2latex/tables/biblatex.json
var require_biblatex = __commonJS({
  "node_modules/unicode2latex/tables/biblatex.json"(exports, module) {
    module.exports = { base: { "#": { text: "\\#", math: "\\#" }, $: { text: "\\$", math: "\\$" }, "%": { text: "\\%", math: "\\%" }, "&": { text: "\\&", math: "\\&" }, _: { text: "\\_", math: "\\_" }, " ": { text: "~", math: "~" }, "£": { text: "\\pounds", math: "\\pounds", macrospacer: true }, "§": { text: "\\S", math: "\\S", macrospacer: true }, "©": { text: "\\copyright", math: "\\copyright", macrospacer: true, alt: ["textcomp"] }, "­": { text: "\\-", math: "\\-" }, "¶": { text: "\\P", math: "\\P", macrospacer: true, alt: ["textcomp"] }, "†": { text: "\\dag", math: "\\dag", macrospacer: true }, "‡": { text: "\\ddag", math: "\\ddag", macrospacer: true }, "…": { text: "\\dots", math: "\\dots", macrospacer: true }, " ": { text: "\\:", math: "\\:" }, "−": { text: "-", math: "-" }, "☿": { text: "\\mercury", math: "\\mercury", macrospacer: true }, "♃": { text: "\\jupiter", math: "\\jupiter", macrospacer: true }, "♄": { text: "\\saturn", math: "\\saturn", macrospacer: true }, "♅": { text: "\\uranus", math: "\\uranus", macrospacer: true }, "♆": { text: "\\neptune", math: "\\neptune", macrospacer: true }, "♇": { text: "\\pluto", math: "\\pluto", macrospacer: true }, "♈": { text: "\\aries", math: "\\aries", macrospacer: true }, "♉": { text: "\\taurus", math: "\\taurus", macrospacer: true }, "♊": { text: "\\gemini", math: "\\gemini", macrospacer: true }, "♋": { text: "\\cancer", math: "\\cancer", macrospacer: true }, "♌": { text: "\\leo", math: "\\leo", macrospacer: true }, "♍": { text: "\\virgo", math: "\\virgo", macrospacer: true }, "♎": { text: "\\libra", math: "\\libra", macrospacer: true }, "♏": { text: "\\scorpio", math: "\\scorpio", macrospacer: true }, "♐": { text: "\\sagittarius", math: "\\sagittarius", macrospacer: true }, "♑": { text: "\\capricornus", math: "\\capricornus", macrospacer: true }, "♒": { text: "\\aquarius", math: "\\aquarius", macrospacer: true }, "<": { math: "<" }, ">": { math: ">" }, "\\": { text: "\\textbackslash", math: "\\backslash", macrospacer: true }, "|": { text: "\\textbar", math: "\\vert", macrospacer: true }, "¬": { text: "\\textlnot", math: "\\lnot", macrospacer: true }, "°": { math: "^\\circ", alt: ["textcomp"] }, "±": { text: "\\textpm", math: "\\pm", macrospacer: true }, "²": { math: "^{2}" }, "³": { math: "^{3}" }, "·": { math: "\\cdot" }, "¹": { math: "^{1}" }, "¼": { math: "\\frac{1}{4}" }, "½": { math: "\\frac{1}{2}" }, "¾": { math: "\\frac{3}{4}" }, "×": { text: "\\texttimes", math: "\\times", macrospacer: true }, "÷": { text: "\\textdiv", math: "\\div", macrospacer: true }, ħ: { math: "\\hbar", alt: ["tipa"] }, ı: { text: "\\i", math: "\\imath", macrospacer: true }, ƒ: { text: "\\textflorin", math: "f", macrospacer: true }, "ȷ": { math: "\\jmath" }, ɛ: { math: "\\varepsilon" }, ɣ: { math: "\\gamma", alt: ["tipa"] }, ʰ: { text: "\\textsuperscript{h}", math: "^{h}" }, ʲ: { text: "\\textsuperscript{j}", math: "^{j}" }, ʳ: { text: "\\textsuperscript{r}", math: "^{r}" }, ʷ: { text: "\\textsuperscript{w}", math: "^{w}" }, ʸ: { text: "\\textsuperscript{y}", math: "^{y}" }, ˡ: { text: "\\textsuperscript{l}", math: "^{l}" }, ˢ: { text: "\\textsuperscript{s}", math: "^{s}" }, ˣ: { text: "\\textsuperscript{x}", math: "^{x}" }, "̅": { math: "\\overline" }, "̊": { text: "\\r", math: "\\mathring", macrospacer: true }, "̱": { math: "\\underbar", alt: ["tipa"] }, "̲": { math: "\\underline" }, "̸": { math: "\\not" }, Ύ: { math: "\\mathrm{'Y}" }, Ώ: { math: "\\mathrm{'\\Omega}" }, ΐ: { math: "\\acute{\\ddot{\\iota}}" }, Γ: { math: "\\Gamma", alt: ["unicode-math"] }, Δ: { math: "\\Delta", alt: ["unicode-math"] }, Θ: { math: "\\Theta", alt: ["unicode-math"] }, Λ: { math: "\\Lambda", alt: ["unicode-math"] }, Ξ: { math: "\\Xi" }, Π: { math: "\\Pi" }, Σ: { math: "\\Sigma" }, Υ: { math: "\\Upsilon" }, Φ: { math: "\\Phi" }, Ψ: { math: "\\Psi" }, Ω: { text: "\\textohm", math: "\\Omega", macrospacer: true }, Ϊ: { math: "\\mathrm{\\ddot{I}}" }, Ϋ: { math: "\\mathrm{\\ddot{Y}}" }, ά: { math: "\\acute{\\alpha}" }, έ: { math: "\\acute{\\epsilon}" }, ή: { math: "\\acute{\\eta}" }, ί: { math: "\\acute{\\iota}" }, ΰ: { math: "\\acute{\\ddot{\\upsilon}}" }, α: { math: "\\alpha", alt: ["textalpha"] }, β: { math: "\\beta" }, γ: { math: "\\gamma" }, δ: { math: "\\delta" }, ε: { math: "\\varepsilon" }, ζ: { math: "\\zeta" }, η: { math: "\\eta" }, θ: { text: "\\texttheta", math: "\\theta", macrospacer: true }, ι: { math: "\\iota" }, κ: { math: "\\kappa" }, λ: { math: "\\lambda" }, μ: { math: "\\mu" }, ν: { math: "\\nu" }, ξ: { math: "\\xi" }, π: { math: "\\pi" }, "𝜌": { math: "\\rho", alt: ["unicode-math"] }, ρ: { math: "\\rho" }, ς: { math: "\\varsigma" }, σ: { math: "\\sigma" }, τ: { math: "\\tau" }, υ: { math: "\\upsilon" }, φ: { math: "\\varphi" }, χ: { math: "\\chi" }, ψ: { math: "\\psi" }, ω: { math: "\\omega" }, ϊ: { math: "\\ddot{\\iota}" }, ϋ: { math: "\\ddot{\\upsilon}" }, ύ: { math: "\\acute{\\upsilon}" }, ώ: { math: "\\acute{\\omega}" }, ϑ: { text: "\\textvartheta", math: "\\vartheta", macrospacer: true }, ϒ: { math: "\\Upsilon" }, ϕ: { math: "\\phi" }, ϖ: { math: "\\varpi" }, "Ϙ": { math: "\\Qoppa" }, "ϙ": { math: "\\qoppa" }, Ϛ: { math: "\\Stigma" }, ϛ: { math: "\\stigma" }, Ϝ: { math: "\\Digamma" }, ϝ: { math: "\\digamma" }, Ϟ: { math: "\\Koppa" }, ϟ: { math: "\\koppa" }, Ϡ: { math: "\\Sampi" }, ϡ: { math: "\\sampi" }, ϱ: { math: "\\varrho" }, "ϴ": { text: "\\textTheta", math: "\\upvarTheta", macrospacer: true }, "ϵ": { math: "\\epsilon" }, "϶": { math: "\\backepsilon", alt: ["unicode-math"] }, "ࡱ": { math: "\\\\backslash" }, "ᵃ": { text: "\\textsuperscript{a}", math: "^{a}" }, "ᴬ": { text: "\\textsuperscript{A}", math: "^{A}" }, "ᵇ": { text: "\\textsuperscript{b}", math: "^{b}" }, "ᵈ": { text: "\\textsuperscript{d}", math: "^{d}" }, "ᵉ": { text: "\\textsuperscript{e}", math: "^{e}" }, "ᵍ": { text: "\\textsuperscript{g}", math: "^{g}" }, "ᵏ": { text: "\\textsuperscript{k}", math: "^{k}" }, "ᵐ": { text: "\\textsuperscript{m}", math: "^{m}" }, "ᵒ": { text: "\\textsuperscript{o}", math: "^{o}" }, "ᵖ": { text: "\\textsuperscript{p}", math: "^{p}" }, "ᵗ": { text: "\\textsuperscript{t}", math: "^{t}" }, "ᵘ": { text: "\\textsuperscript{u}", math: "^{u}" }, "ᵛ": { text: "\\textsuperscript{v}", math: "^{v}" }, "ᶜ": { text: "\\textsuperscript{c}", math: "^{c}" }, "ᶠ": { text: "\\textsuperscript{f}", math: "^{f}" }, "ᶻ": { text: "\\textsuperscript{z}", math: "^{z}" }, " ": { math: "\\quad" }, " ": { math: "\\mkern1mu" }, "•": { math: "\\bullet", alt: ["textcomp"] }, "′": { math: "\\prime" }, "″": { math: "{''}", alt: ["unicode-math"] }, "‴": { math: "{'''}", alt: ["unicode-math"] }, "⁗": { math: "''''", alt: ["unicode-math"] }, "⁰": { math: "^{0}" }, "ⁱ": { text: "\\textsuperscript{i}", math: "^{i}" }, "⁴": { math: "^{4}" }, "⁵": { math: "^{5}" }, "⁶": { math: "^{6}" }, "⁷": { math: "^{7}" }, "⁸": { math: "^{8}" }, "⁹": { math: "^{9}" }, "⁺": { math: "^{+}" }, "⁻": { math: "^{-}" }, "⁼": { math: "^{=}" }, "⁽": { math: "^{(}" }, "⁾": { math: "^{)}" }, ⁿ: { math: "^{n}" }, "₀": { math: "_{0}" }, "₁": { math: "_{1}" }, "₂": { math: "_{2}" }, "₃": { math: "_{3}" }, "₄": { math: "_{4}" }, "₅": { math: "_{5}" }, "₆": { math: "_{6}" }, "₇": { math: "_{7}" }, "₈": { math: "_{8}" }, "₉": { math: "_{9}" }, "₊": { math: "_{+}" }, "₋": { math: "_{-}" }, "₌": { math: "_{=}" }, "₍": { math: "_{(}" }, "₎": { math: "_{)}" }, "ₐ": { text: "\\textsubscript{a}", math: "_{a}" }, "ₑ": { text: "\\textsubscript{e}", math: "_{e}" }, "ₒ": { text: "\\textsubscript{o}", math: "_{o}" }, "ₓ": { text: "\\textsubscript{x}", math: "_{x}" }, "ₕ": { text: "\\textsubscript{h}", math: "_{h}" }, "ₖ": { text: "\\textsubscript{k}", math: "_{k}" }, "ₗ": { text: "\\textsubscript{l}", math: "_{l}" }, "ₘ": { text: "\\textsubscript{m}", math: "_{m}" }, "ₙ": { text: "\\textsubscript{n}", math: "_{n}" }, "ₚ": { text: "\\textsubscript{p}", math: "_{p}" }, "ₛ": { text: "\\textsubscript{s}", math: "_{s}" }, "ₜ": { text: "\\textsubscript{t}", math: "_{t}" }, "⃐": { math: "\\lvec" }, "⃖": { math: "\\LVec" }, ℂ: { math: "\\mathbb{C}" }, ℇ: { math: "\\Euler" }, ℋ: { math: "\\mathcal{H}", alt: ["mathrsfs"] }, ℌ: { math: "\\mathfrak{H}" }, ℍ: { math: "\\mathbb{H}" }, ℑ: { math: "\\mathfrak{I}" }, ℓ: { math: "\\ell" }, ℕ: { math: "\\mathbb{N}" }, "℘": { math: "\\wp" }, ℙ: { math: "\\mathbb{P}" }, ℚ: { math: "\\mathbb{Q}" }, ℜ: { math: "\\mathfrak{R}" }, ℝ: { math: "\\mathbb{R}" }, ℤ: { math: "\\mathbb{Z}" }, ℨ: { math: "\\mathfrak{Z}" }, Å: { text: "\\AA", math: "\\Angstroem", macrospacer: true }, ℭ: { math: "\\mathfrak{C}" }, ℵ: { math: "\\aleph" }, "ℼ": { math: "\\mathbb{\\pi}" }, "ℽ": { math: "\\mathbb{\\gamma}" }, "ℾ": { math: "\\mathbb{\\Gamma}" }, "ℿ": { math: "\\mathbb{\\Pi}" }, "⅀": { math: "\\mathbb{\\Sigma}" }, "ⅆ": { math: "\\DifferentialD" }, "ⅇ": { math: "\\ExponetialE" }, "ⅈ": { math: "\\ComplexI" }, "ⅉ": { math: "\\ComplexJ" }, "⅋": { math: "\\invamp" }, "⅐": { math: "\\frac{1}{7}" }, "⅑": { math: "\\frac{1}{9}" }, "⅒": { math: "\\frac{1}{10}" }, "⅓": { math: "\\frac{1}{3}" }, "⅔": { math: "\\frac{2}{3}" }, "⅕": { math: "\\frac{1}{5}" }, "⅖": { math: "\\frac{2}{5}" }, "⅗": { math: "\\frac{3}{5}" }, "⅘": { math: "\\frac{4}{5}" }, "⅙": { math: "\\frac{1}{6}" }, "⅚": { math: "\\frac{5}{6}" }, "⅛": { math: "\\frac{1}{8}" }, "⅜": { math: "\\frac{3}{8}" }, "⅝": { math: "\\frac{5}{8}" }, "⅞": { math: "\\frac{7}{8}" }, "⅟": { math: "\\frac{1}" }, "↉": { math: "\\frac{0}{3}" }, "←": { text: "\\textleftarrow", math: "\\leftarrow", macrospacer: true }, "↑": { math: "\\uparrow", alt: ["textcomp"] }, "→": { math: "\\rightarrow", alt: ["textcomp"] }, "↓": { text: "\\textdownarrow", math: "\\downarrow", macrospacer: true }, "↔": { math: "\\leftrightarrow" }, "↕": { math: "\\updownarrow" }, "↖": { math: "\\nwarrow" }, "↗": { math: "\\nearrow" }, "↘": { math: "\\searrow" }, "↙": { math: "\\swarrow" }, "↜": { math: "\\arrowwaveleft" }, "↝": { math: "\\arrowwaveright" }, "↦": { math: "\\mapsto" }, "↩": { math: "\\hookleftarrow" }, "↪": { math: "\\hookrightarrow" }, "↯": { math: "\\lightning" }, "↲": { math: "\\dlsh" }, "↻": { math: "\\circlearrowright" }, "↼": { math: "\\leftharpoonup" }, "↽": { math: "\\leftharpoondown" }, "⇀": { math: "\\rightharpoonup" }, "⇅": { math: "\\dblarrowupdown" }, "⇌": { math: "\\rightleftharpoons" }, "⇐": { math: "\\Leftarrow" }, "⇑": { math: "\\Uparrow" }, "⇒": { math: "\\Rightarrow" }, "⇓": { math: "\\Downarrow" }, "⇔": { math: "\\Leftrightarrow" }, "⇕": { math: "\\Updownarrow" }, "⇠": { math: "\\dashleftarrow" }, "⇢": { math: "\\dashrightarrow" }, "⇤": { math: "\\LeftArrowBar" }, "⇥": { math: "\\RightArrowBar" }, "⇵": { math: "\\DownArrowUpArrow" }, "⇸": { math: "\\pfun" }, "⇻": { math: "\\ffun" }, "∀": { math: "\\forall" }, "∂": { math: "\\partial" }, "∃": { math: "\\exists" }, "∈": { math: "\\in" }, "∉": { math: "\\notin" }, "∋": { math: "\\ni" }, "∌": { math: "\\not\\ni" }, "∏": { math: "\\prod" }, "∐": { math: "\\coprod" }, "∑": { math: "\\sum" }, "∓": { math: "\\mp" }, "∗": { math: "\\ast" }, "∘": { math: "\\circ" }, "∙": { math: "\\bullet" }, "∛": { math: "\\sqrt[3]" }, "∜": { math: "\\sqrt[4]" }, "∝": { math: "\\propto" }, "∞": { math: "\\infty" }, "∠": { math: "\\angle" }, "∣": { math: "\\mid" }, "∥": { math: "\\parallel" }, "∧": { math: "\\wedge" }, "∨": { math: "\\vee" }, "∩": { math: "\\cap" }, "∪": { math: "\\cup" }, "∫": { math: "\\int" }, "∬": { math: "{\\int\\!\\int}" }, "∭": { math: "{\\int\\!\\int\\!\\int}" }, "∮": { math: "\\oint" }, "∯": { math: "\\surfintegral" }, "∰": { math: "\\volintegral" }, "∱": { math: "\\clwintegral" }, "∶": { math: ":" }, "∺": { math: "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}" }, "∻": { math: "\\homothetic" }, "∼": { math: "\\sim" }, "∾": { math: "\\lazysinv" }, "∿": { math: "\\AC" }, "≀": { math: "\\wr" }, "≁": { math: "\\not\\sim" }, "≂̸": { math: "\\NotEqualTilde" }, "≃": { math: "\\simeq" }, "≄": { math: "\\not\\simeq" }, "≅": { math: "\\cong" }, "≆": { math: "\\approxnotequal" }, "≇": { math: "\\not\\cong" }, "≈": { math: "\\approx", alt: ["inputenx"] }, "≉": { math: "\\not\\approx" }, "≋": { math: "\\tildetrpl" }, "≋̸": { math: "\\not\\apid" }, "≌": { math: "\\allequal" }, "≍": { math: "\\asymp" }, "≎̸": { math: "\\NotHumpDownHump" }, "≏̸": { math: "\\NotHumpEqual" }, "≐": { math: "\\doteq" }, "≐̸": { math: "\\not\\doteq" }, "≑": { math: "\\doteqdot" }, "≔": { text: ":=", math: ":=", alt: ["unicode-math"] }, "≕": { math: "=:" }, "≙": { math: "\\estimates" }, "≛": { math: "\\starequal" }, "≠": { math: "\\neq" }, "≡": { math: "\\equiv" }, "≢": { math: "\\not\\equiv" }, "≤": { math: "\\leq" }, "≥": { math: "\\geq" }, "≦": { math: "\\leqq" }, "≧": { math: "\\geqq" }, "≨︀": { math: "\\lvertneqq" }, "≩︀": { math: "\\gvertneqq" }, "≪": { math: "\\ll" }, "≪̸": { math: "\\NotLessLess" }, "≫": { math: "\\gg" }, "≫̸": { math: "\\NotGreaterGreater" }, "≭": { math: "{\\not\\kern-0.3em\\times}", alt: ["unicode-math"] }, "≮": { math: "\\not<" }, "≯": { math: "\\not>" }, "≰": { math: "\\not\\leq" }, "≱": { math: "\\not\\geq" }, "≲": { math: "\\lessequivlnt" }, "≳": { math: "\\greaterequivlnt" }, "≸": { math: "\\notlessgreater" }, "≹": { math: "\\notgreaterless" }, "≺": { math: "\\prec" }, "≻": { math: "\\succ" }, "≾": { math: "\\precapprox" }, "≾̸": { math: "\\NotPrecedesTilde" }, "≿": { math: "\\succapprox" }, "≿̸": { math: "\\NotSucceedsTilde" }, "⊀": { math: "\\not\\prec" }, "⊁": { math: "\\not\\succ" }, "⊂": { math: "\\subset" }, "⊃": { math: "\\supset" }, "⊄": { math: "\\not\\subset" }, "⊅": { math: "\\not\\supset" }, "⊆": { math: "\\subseteq" }, "⊇": { math: "\\supseteq" }, "⊈": { math: "\\not\\subseteq" }, "⊉": { math: "\\not\\supseteq" }, "⊊︀": { math: "\\varsubsetneqq" }, "⊋︀": { math: "\\varsupsetneq" }, "⊎": { math: "\\uplus" }, "⊏̸": { math: "\\NotSquareSubset" }, "⊐̸": { math: "\\NotSquareSuperset" }, "⊑": { math: "\\sqsubseteq" }, "⊒": { math: "\\sqsupseteq" }, "⊓": { math: "\\sqcap" }, "⊔": { math: "\\sqcup" }, "⊕": { math: "\\oplus" }, "⊖": { math: "\\ominus" }, "⊗": { math: "\\otimes" }, "⊘": { math: "\\oslash" }, "⊙": { math: "\\odot" }, "⊢": { math: "\\vdash" }, "⊣": { math: "\\dashv" }, "⊤": { math: "\\top" }, "⊥": { math: "\\perp" }, "⊧": { math: "\\truestate" }, "⊨": { math: "\\forcesextra" }, "⊶": { math: "\\original" }, "⊷": { math: "\\image" }, "⊹": { math: "\\hermitconjmatrix" }, "⊾": { math: "\\rightanglearc" }, "⋀": { math: "\\bigwedge" }, "⋁": { math: "\\bigvee" }, "⋂": { math: "\\bigcap" }, "⋃": { math: "\\bigcup" }, "⋄": { math: "\\diamond" }, "⋅": { math: "\\cdot" }, "⋆": { math: "\\star" }, "⋈": { math: "\\bowtie" }, "⋘": { math: "\\verymuchless" }, "⋙": { math: "\\verymuchgreater" }, "⋢": { math: "\\not\\sqsubseteq" }, "⋣": { math: "\\not\\sqsupseteq" }, "⋪": { math: "\\ntriangleleft" }, "⋫": { math: "\\ntriangleright" }, "⋮": { math: "\\vdots" }, "⋯": { math: "\\cdots" }, "⋰": { math: "\\upslopeellipsis" }, "⋱": { math: "\\ddots" }, "⋶": { math: "\\barin" }, "⌆": { math: "\\perspcorrespond" }, "⌈": { math: "\\lceil" }, "⌉": { math: "\\rceil" }, "⌊": { math: "\\lfloor" }, "⌋": { math: "\\rfloor" }, "⌑": { math: "\\wasylozenge" }, "⌕": { math: "\\recorder" }, "⌖": { math: '{\\mathchar"2208}' }, "⌢": { math: "\\frown" }, "⌣": { math: "\\smile" }, "〈": { text: "\\textlangle", math: "\\langle", macrospacer: true }, "〉": { text: "\\textrangle", math: "\\rangle", macrospacer: true }, "⌹": { math: "\\APLinv" }, "⌿": { math: "\\notslash" }, "⍀": { math: "\\notbackslash" }, "⍇": { math: "\\APLleftarrowbox" }, "⍈": { math: "\\APLrightarrowbox" }, "⍉": { math: "\\invdiameter" }, "⍐": { math: "\\APLuparrowbox" }, "⍗": { math: "\\APLdownarrowbox" }, "⍝": { math: "\\APLcomment" }, "⍞": { math: "\\APLinput" }, "⍟": { math: "\\APLlog" }, "⎰": { math: "\\lmoustache" }, "⎱": { math: "\\rmoustache" }, "Ⓢ": { math: "\\circledS" }, "╱": { math: "\\diagup" }, "□": { math: "\\square" }, "▶": { math: "\\RHD" }, "▷": { math: "\\rhd" }, "▽": { math: "\\bigtriangledown" }, "◀": { math: "\\LHD" }, "◁": { math: "\\lhd" }, "◆": { text: "\\ding{117}", math: "\\Diamondblack" }, "◇": { math: "\\Diamond" }, "○": { math: "\\bigcirc" }, "●": { text: "\\ding{108}", math: "\\CIRCLE" }, "◯": { text: "\\textbigcircle", math: "\\bigcirc", macrospacer: true }, "☉": { math: "\\Sun" }, "☐": { math: "\\Square" }, "☑": { math: "\\CheckedBox" }, "☒": { math: "\\XBox" }, "☕": { math: "\\steaming" }, "☞": { text: "\\ding{43}", math: "\\pointright" }, "☠": { math: "\\skull" }, "☢": { math: "\\radiation" }, "☣": { math: "\\biohazard" }, "☯": { math: "\\yinyang" }, "☹": { math: "\\frownie" }, "☺": { math: "\\smiley" }, "♁": { math: "\\earth" }, "♠": { text: "\\ding{171}", math: "\\spadesuit" }, "♡": { math: "\\heartsuit" }, "♢": { math: "\\diamondsuit" }, "♣": { math: "\\clubsuit" }, "♭": { math: "\\flat" }, "♮": { math: "\\natural" }, "♯": { math: "\\sharp" }, "♻": { math: "\\recycle" }, "⚓": { math: "\\anchor" }, "⚔": { math: "\\swords" }, "⚠": { math: "\\warning" }, "⚪": { math: "\\medcirc" }, "⚫": { math: "\\medbullet" }, "✎": { text: "\\ding{46}", math: "\\pencil" }, "✗": { text: "\\ding{55}", math: "\\ballotx" }, "➢": { text: "\\ding{226}", math: "\\arrowbullet" }, "⟂": { math: "\\perp" }, "⟅": { math: "\\Lbag" }, "⟆": { math: "\\Rbag" }, "⟐": { math: "\\Diamonddot" }, "⟦": { math: "\\llbracket" }, "⟧": { math: "\\rrbracket" }, "⟨": { math: "\\langle" }, "⟩": { math: "\\rangle" }, "⟪": { math: "\\lang" }, "⟮": { math: "\\lgroup" }, "⟯": { math: "\\rgroup" }, "⟵": { math: "\\longleftarrow" }, "⟶": { math: "\\longrightarrow" }, "⟷": { math: "\\longleftrightarrow" }, "⟸": { math: "\\Longleftarrow" }, "⟹": { math: "\\Longrightarrow" }, "⟺": { math: "\\Longleftrightarrow" }, "⟼": { math: "\\longmapsto" }, "⤀": { math: "\\psur" }, "⤒": { math: "\\UpArrowBar" }, "⤓": { math: "\\DownArrowBar" }, "⤔": { math: "\\pinj" }, "⤕": { math: "\\finj" }, "⤖": { math: "\\bij" }, "⥀": { math: "\\Elolarr" }, "⥁": { math: "\\Elorarr" }, "⥊": { math: "\\leftrightharpoon" }, "⥋": { math: "\\rightleftharpoon" }, "⥏": { math: "\\RightUpDownVector" }, "⥑": { math: "\\LeftUpDownVector" }, "⥒": { math: "\\LeftVectorBar" }, "⥓": { math: "\\RightVectorBar" }, "⥔": { math: "\\RightUpVectorBar" }, "⥕": { math: "\\RightDownVectorBar" }, "⥖": { math: "\\DownLeftVectorBar" }, "⥗": { math: "\\DownRightVectorBar" }, "⥘": { math: "\\LeftUpVectorBar" }, "⥙": { math: "\\LeftDownVectorBar" }, "⥚": { math: "\\LeftTeeVector" }, "⥛": { math: "\\RightTeeVector" }, "⥜": { math: "\\RightUpTeeVector" }, "⥝": { math: "\\RightDownTeeVector" }, "⥞": { math: "\\DownLeftTeeVector" }, "⥟": { math: "\\DownRightTeeVector" }, "⥠": { math: "\\LeftUpTeeVector" }, "⥡": { math: "\\LeftDownTeeVector" }, "⥢": { math: "\\leftleftharpoons" }, "⥣": { math: "\\upupharpoons" }, "⥤": { math: "\\rightrightharpoons" }, "⥥": { math: "\\downdownharpoons" }, "⥪": { math: "\\leftbarharpoon" }, "⥫": { math: "\\barleftharpoon" }, "⥬": { math: "\\rightbarharpoon" }, "⥭": { math: "\\barrightharpoon" }, "⥮": { math: "\\UpEquilibrium" }, "⥯": { math: "\\ReverseUpEquilibrium" }, "⥰": { math: "\\RoundImplies" }, "⦈": { math: "\\rimg" }, "⦉": { math: "\\lblot" }, "⦊": { math: "\\rblot" }, "⦜": { math: "\\Angle" }, "⧄": { math: "\\boxslash" }, "⧏": { math: "\\LeftTriangleBar" }, "⧏̸": { math: "\\NotLeftTriangleBar" }, "⧐": { math: "\\RightTriangleBar" }, "⧐̸": { math: "\\NotRightTriangleBar" }, "⧟": { math: "\\multimapboth" }, "⧵": { math: "\\setminus" }, "⧹": { math: "\\zhide" }, "⨀": { math: "\\bigodot" }, "⨁": { math: "\\bigoplus" }, "⨂": { math: "\\bigotimes" }, "⨆": { math: "\\Elxsqcup" }, "⨉": { math: "\\varprod" }, "⨏": { math: "\\clockoint" }, "⨖": { math: "\\sqrint" }, "⨿": { math: "\\amalg" }, "⩖": { math: "\\ElOr" }, "⩮": { math: "\\stackrel{*}{=}" }, "⩵": { math: "\\Equal" }, "⩶": { math: "\\Same" }, "⩽": { math: "\\leq", alt: ["amssymb", "unicode-math"] }, "⪡": { math: "\\NestedLessLess" }, "⪡̸": { math: "\\NotNestedLessLess" }, "⪢": { math: "\\NestedGreaterGreater" }, "⪢̸": { math: "\\NotNestedGreaterGreater" }, "⪦": { math: "\\leftslice" }, "⪧": { math: "\\rightslice" }, "⪯": { math: "\\preceq" }, "⪯̸": { math: "\\not\\preceq" }, "⪰": { math: "\\succeq" }, "⪰̸": { math: "\\not\\succeq" }, "⪻": { math: "\\llcurly" }, "⪼": { math: "\\ggcurly" }, "⫅̸": { math: "\\nsubseteqq" }, "⫆̸": { math: "\\nsupseteqq" }, "⫝̸": { math: "\\forks", alt: ["unicode-math"] }, "⫪": { math: "\\Top" }, "⫽": { math: "{{/}\\!\\!{/}}" }, "⫽⃥": { math: "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}" }, "〔": { math: "\\lbrbrak" }, "〕": { math: "\\rbrbrak" }, "〚": { math: "\\openbracketleft" }, "〛": { math: "\\openbracketright" }, "𝐀": { math: "\\mathbf{A}", alt: ["unicode-math"] }, "𝐁": { math: "\\mathbf{B}", alt: ["unicode-math"] }, "𝐂": { math: "\\mathbf{C}", alt: ["unicode-math"] }, "𝐃": { math: "\\mathbf{D}", alt: ["unicode-math"] }, "𝐄": { math: "\\mathbf{E}", alt: ["unicode-math"] }, "𝐅": { math: "\\mathbf{F}", alt: ["unicode-math"] }, "𝐆": { math: "\\mathbf{G}", alt: ["unicode-math"] }, "𝐇": { math: "\\mathbf{H}", alt: ["unicode-math"] }, "𝐈": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝐉": { math: "\\mathbf{J}", alt: ["unicode-math"] }, "𝐊": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝐋": { math: "\\mathbf{L}", alt: ["unicode-math"] }, "𝐌": { math: "\\mathbf{M}", alt: ["unicode-math"] }, "𝐍": { math: "\\mathbf{N}", alt: ["unicode-math"] }, "𝐎": { math: "\\mathbf{O}", alt: ["unicode-math"] }, "𝐏": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝐐": { math: "\\mathbf{Q}", alt: ["unicode-math"] }, "𝐑": { math: "\\mathbf{R}", alt: ["unicode-math"] }, "𝐒": { math: "\\mathbf{S}", alt: ["unicode-math"] }, "𝐓": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝐔": { math: "\\mathbf{U}", alt: ["unicode-math"] }, "𝐕": { math: "\\mathbf{V}", alt: ["unicode-math"] }, "𝐖": { math: "\\mathbf{W}", alt: ["unicode-math"] }, "𝐗": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝐘": { math: "\\mathbf{Y}", alt: ["unicode-math"] }, "𝐙": { math: "\\mathbf{Z}", alt: ["unicode-math"] }, "𝐚": { math: "\\mathbf{a}", alt: ["unicode-math"] }, "𝐛": { math: "\\mathbf{b}", alt: ["unicode-math"] }, "𝐜": { math: "\\mathbf{c}", alt: ["unicode-math"] }, "𝐝": { math: "\\mathbf{d}", alt: ["unicode-math"] }, "𝐞": { math: "\\mathbf{e}", alt: ["unicode-math"] }, "𝐟": { math: "\\mathbf{f}", alt: ["unicode-math"] }, "𝐠": { math: "\\mathbf{g}", alt: ["unicode-math"] }, "𝐡": { math: "\\mathbf{h}", alt: ["unicode-math"] }, "𝐢": { math: "\\mathbf{i}", alt: ["unicode-math"] }, "𝐣": { math: "\\mathbf{j}", alt: ["unicode-math"] }, "𝐤": { math: "\\mathbf{k}", alt: ["unicode-math"] }, "𝐥": { math: "\\mathbf{l}", alt: ["unicode-math"] }, "𝐦": { math: "\\mathbf{m}", alt: ["unicode-math"] }, "𝐧": { math: "\\mathbf{n}", alt: ["unicode-math"] }, "𝐨": { math: "\\mathbf{o}", alt: ["unicode-math"] }, "𝐩": { math: "\\mathbf{p}", alt: ["unicode-math"] }, "𝐪": { math: "\\mathbf{q}", alt: ["unicode-math"] }, "𝐫": { math: "\\mathbf{r}", alt: ["unicode-math"] }, "𝐬": { math: "\\mathbf{s}", alt: ["unicode-math"] }, "𝐭": { math: "\\mathbf{t}", alt: ["unicode-math"] }, "𝐮": { math: "\\mathbf{u}", alt: ["unicode-math"] }, "𝐯": { math: "\\mathbf{v}", alt: ["unicode-math"] }, "𝐰": { math: "\\mathbf{w}", alt: ["unicode-math"] }, "𝐱": { math: "\\mathbf{x}", alt: ["unicode-math"] }, "𝐲": { math: "\\mathbf{y}", alt: ["unicode-math"] }, "𝐳": { math: "\\mathbf{z}", alt: ["unicode-math"] }, "𝐴": { math: "A", alt: ["unicode-math"] }, "𝐵": { math: "B", alt: ["unicode-math"] }, "𝐶": { math: "C", alt: ["unicode-math"] }, "𝐷": { math: "D", alt: ["unicode-math"] }, "𝐸": { math: "E", alt: ["unicode-math"] }, "𝐹": { math: "F", alt: ["unicode-math"] }, "𝐺": { math: "G", alt: ["unicode-math"] }, "𝐻": { math: "H", alt: ["unicode-math"] }, "𝐼": { math: "I", alt: ["unicode-math"] }, "𝐽": { math: "J", alt: ["unicode-math"] }, "𝐾": { math: "K", alt: ["unicode-math"] }, "𝐿": { math: "L", alt: ["unicode-math"] }, "𝑀": { math: "M", alt: ["unicode-math"] }, "𝑁": { math: "N", alt: ["unicode-math"] }, "𝑂": { math: "O", alt: ["unicode-math"] }, "𝑃": { math: "P", alt: ["unicode-math"] }, "𝑄": { math: "Q", alt: ["unicode-math"] }, "𝑅": { math: "R", alt: ["unicode-math"] }, "𝑆": { math: "S", alt: ["unicode-math"] }, "𝑇": { math: "T", alt: ["unicode-math"] }, "𝑈": { math: "U", alt: ["unicode-math"] }, "𝑉": { math: "V", alt: ["unicode-math"] }, "𝑊": { math: "W", alt: ["unicode-math"] }, "𝑋": { math: "X", alt: ["unicode-math"] }, "𝑌": { math: "Y", alt: ["unicode-math"] }, "𝑍": { math: "Z", alt: ["unicode-math"] }, "𝑎": { math: "a", alt: ["unicode-math"] }, "𝑏": { math: "b", alt: ["unicode-math"] }, "𝑐": { math: "c", alt: ["unicode-math"] }, "𝑑": { math: "d", alt: ["unicode-math"] }, "𝑒": { math: "e", alt: ["unicode-math"] }, "𝑓": { math: "f", alt: ["unicode-math"] }, "𝑔": { math: "g", alt: ["unicode-math"] }, "𝑖": { math: "i", alt: ["unicode-math"] }, "𝑗": { math: "j", alt: ["unicode-math"] }, "𝑘": { math: "k", alt: ["unicode-math"] }, "𝑙": { math: "l", alt: ["unicode-math"] }, "𝑚": { math: "m", alt: ["unicode-math"] }, "𝑛": { math: "n", alt: ["unicode-math"] }, "𝑜": { math: "o", alt: ["unicode-math"] }, "𝑝": { math: "p", alt: ["unicode-math"] }, "𝑞": { math: "q", alt: ["unicode-math"] }, "𝑟": { math: "r", alt: ["unicode-math"] }, "𝑠": { math: "s", alt: ["unicode-math"] }, "𝑡": { math: "t", alt: ["unicode-math"] }, "𝑢": { math: "u", alt: ["unicode-math"] }, "𝑣": { math: "v", alt: ["unicode-math"] }, "𝑤": { math: "w", alt: ["unicode-math"] }, "𝑥": { math: "x", alt: ["unicode-math"] }, "𝑦": { math: "y", alt: ["unicode-math"] }, "𝑧": { math: "z", alt: ["unicode-math"] }, "𝑨": { math: "\\mathbit{A}", alt: ["unicode-math"] }, "𝑩": { math: "\\mathbit{B}", alt: ["unicode-math"] }, "𝑪": { math: "\\mathbit{C}", alt: ["unicode-math"] }, "𝑫": { math: "\\mathbit{D}", alt: ["unicode-math"] }, "𝑬": { math: "\\mathbit{E}", alt: ["unicode-math"] }, "𝑭": { math: "\\mathbit{F}", alt: ["unicode-math"] }, "𝑮": { math: "\\mathbit{G}", alt: ["unicode-math"] }, "𝑯": { math: "\\mathbit{H}", alt: ["unicode-math"] }, "𝑰": { math: "\\mathbit{I}", alt: ["unicode-math"] }, "𝑱": { math: "\\mathbit{J}", alt: ["unicode-math"] }, "𝑲": { math: "\\mathbit{K}", alt: ["unicode-math"] }, "𝑳": { math: "\\mathbit{L}", alt: ["unicode-math"] }, "𝑴": { math: "\\mathbit{M}", alt: ["unicode-math"] }, "𝑵": { math: "\\mathbit{N}", alt: ["unicode-math"] }, "𝑶": { math: "\\mathbit{O}", alt: ["unicode-math"] }, "𝑷": { math: "\\mathbit{P}", alt: ["unicode-math"] }, "𝑸": { math: "\\mathbit{Q}", alt: ["unicode-math"] }, "𝑹": { math: "\\mathbit{R}", alt: ["unicode-math"] }, "𝑺": { math: "\\mathbit{S}", alt: ["unicode-math"] }, "𝑻": { math: "\\mathbit{T}", alt: ["unicode-math"] }, "𝑼": { math: "\\mathbit{U}", alt: ["unicode-math"] }, "𝑽": { math: "\\mathbit{V}", alt: ["unicode-math"] }, "𝑾": { math: "\\mathbit{W}", alt: ["unicode-math"] }, "𝑿": { math: "\\mathbit{X}", alt: ["unicode-math"] }, "𝒀": { math: "\\mathbit{Y}", alt: ["unicode-math"] }, "𝒁": { math: "\\mathbit{Z}", alt: ["unicode-math"] }, "𝒂": { math: "\\mathbit{a}", alt: ["unicode-math"] }, "𝒃": { math: "\\mathbit{b}", alt: ["unicode-math"] }, "𝒄": { math: "\\mathbit{c}", alt: ["unicode-math"] }, "𝒅": { math: "\\mathbit{d}", alt: ["unicode-math"] }, "𝒆": { math: "\\mathbit{e}", alt: ["unicode-math"] }, "𝒇": { math: "\\mathbit{f}", alt: ["unicode-math"] }, "𝒈": { math: "\\mathbit{g}", alt: ["unicode-math"] }, "𝒉": { math: "\\mathbit{h}", alt: ["unicode-math"] }, "𝒊": { math: "\\mathbit{i}", alt: ["unicode-math"] }, "𝒋": { math: "\\mathbit{j}", alt: ["unicode-math"] }, "𝒌": { math: "\\mathbit{k}", alt: ["unicode-math"] }, "𝒍": { math: "\\mathbit{l}", alt: ["unicode-math"] }, "𝒎": { math: "\\mathbit{m}", alt: ["unicode-math"] }, "𝒏": { math: "\\mathbit{n}", alt: ["unicode-math"] }, "𝒐": { math: "\\mathbit{o}", alt: ["unicode-math"] }, "𝒑": { math: "\\mathbit{p}", alt: ["unicode-math"] }, "𝒒": { math: "\\mathbit{q}", alt: ["unicode-math"] }, "𝒓": { math: "\\mathbit{r}", alt: ["unicode-math"] }, "𝒔": { math: "\\mathbit{s}", alt: ["unicode-math"] }, "𝒕": { math: "\\mathbit{t}", alt: ["unicode-math"] }, "𝒖": { math: "\\mathbit{u}", alt: ["unicode-math"] }, "𝒗": { math: "\\mathbit{v}", alt: ["unicode-math"] }, "𝒘": { math: "\\mathbit{w}", alt: ["unicode-math"] }, "𝒙": { math: "\\mathbit{x}", alt: ["unicode-math"] }, "𝒚": { math: "\\mathbit{y}", alt: ["unicode-math"] }, "𝒛": { math: "\\mathbit{z}", alt: ["unicode-math"] }, "𝓐": { math: "\\mathmit{A}", alt: ["unicode-math"] }, "𝓑": { math: "\\mathmit{B}", alt: ["unicode-math"] }, "𝓒": { math: "\\mathmit{C}", alt: ["unicode-math"] }, "𝓓": { math: "\\mathmit{D}", alt: ["unicode-math"] }, "𝓔": { math: "\\mathmit{E}", alt: ["unicode-math"] }, "𝓕": { math: "\\mathmit{F}", alt: ["unicode-math"] }, "𝓖": { math: "\\mathmit{G}", alt: ["unicode-math"] }, "𝓗": { math: "\\mathmit{H}", alt: ["unicode-math"] }, "𝓘": { math: "\\mathmit{I}", alt: ["unicode-math"] }, "𝓙": { math: "\\mathmit{J}", alt: ["unicode-math"] }, "𝓚": { math: "\\mathmit{K}", alt: ["unicode-math"] }, "𝓛": { math: "\\mathmit{L}", alt: ["unicode-math"] }, "𝓜": { math: "\\mathmit{M}", alt: ["unicode-math"] }, "𝓝": { math: "\\mathmit{N}", alt: ["unicode-math"] }, "𝓞": { math: "\\mathmit{O}", alt: ["unicode-math"] }, "𝓟": { math: "\\mathmit{P}", alt: ["unicode-math"] }, "𝓠": { math: "\\mathmit{Q}", alt: ["unicode-math"] }, "𝓡": { math: "\\mathmit{R}", alt: ["unicode-math"] }, "𝓢": { math: "\\mathmit{S}", alt: ["unicode-math"] }, "𝓣": { math: "\\mathmit{T}", alt: ["unicode-math"] }, "𝓤": { math: "\\mathmit{U}", alt: ["unicode-math"] }, "𝓥": { math: "\\mathmit{V}", alt: ["unicode-math"] }, "𝓦": { math: "\\mathmit{W}", alt: ["unicode-math"] }, "𝓧": { math: "\\mathmit{X}", alt: ["unicode-math"] }, "𝓨": { math: "\\mathmit{Y}", alt: ["unicode-math"] }, "𝓩": { math: "\\mathmit{Z}", alt: ["unicode-math"] }, "𝓪": { math: "\\mathmit{a}", alt: ["unicode-math"] }, "𝓫": { math: "\\mathmit{b}", alt: ["unicode-math"] }, "𝓬": { math: "\\mathmit{c}", alt: ["unicode-math"] }, "𝓭": { math: "\\mathmit{d}", alt: ["unicode-math"] }, "𝓮": { math: "\\mathmit{e}", alt: ["unicode-math"] }, "𝓯": { math: "\\mathmit{f}", alt: ["unicode-math"] }, "𝓰": { math: "\\mathmit{g}", alt: ["unicode-math"] }, "𝓱": { math: "\\mathmit{h}", alt: ["unicode-math"] }, "𝓲": { math: "\\mathmit{i}", alt: ["unicode-math"] }, "𝓳": { math: "\\mathmit{j}", alt: ["unicode-math"] }, "𝓴": { math: "\\mathmit{k}", alt: ["unicode-math"] }, "𝓵": { math: "\\mathmit{l}", alt: ["unicode-math"] }, "𝓶": { math: "\\mathmit{m}", alt: ["unicode-math"] }, "𝓷": { math: "\\mathmit{n}", alt: ["unicode-math"] }, "𝓸": { math: "\\mathmit{o}", alt: ["unicode-math"] }, "𝓹": { math: "\\mathmit{p}", alt: ["unicode-math"] }, "𝓺": { math: "\\mathmit{q}", alt: ["unicode-math"] }, "𝓻": { math: "\\mathmit{r}", alt: ["unicode-math"] }, "𝓼": { math: "\\mathmit{s}", alt: ["unicode-math"] }, "𝓽": { math: "\\mathmit{t}", alt: ["unicode-math"] }, "𝓾": { math: "\\mathmit{u}", alt: ["unicode-math"] }, "𝓿": { math: "\\mathmit{v}", alt: ["unicode-math"] }, "𝔀": { math: "\\mathmit{w}", alt: ["unicode-math"] }, "𝔁": { math: "\\mathmit{x}", alt: ["unicode-math"] }, "𝔂": { math: "\\mathmit{y}", alt: ["unicode-math"] }, "𝔃": { math: "\\mathmit{z}", alt: ["unicode-math"] }, "𝔄": { math: "\\mathfrak{A}", alt: ["unicode-math"] }, "𝔅": { math: "\\mathfrak{B}", alt: ["unicode-math"] }, "𝔇": { math: "\\mathfrak{D}", alt: ["unicode-math"] }, "𝔈": { math: "\\mathfrak{E}", alt: ["unicode-math"] }, "𝔉": { math: "\\mathfrak{F}", alt: ["unicode-math"] }, "𝔊": { math: "\\mathfrak{G}", alt: ["unicode-math"] }, "𝔍": { math: "\\mathfrak{J}", alt: ["unicode-math"] }, "𝔎": { math: "\\mathfrak{K}", alt: ["unicode-math"] }, "𝔏": { math: "\\mathfrak{L}", alt: ["unicode-math"] }, "𝔐": { math: "\\mathfrak{M}", alt: ["unicode-math"] }, "𝔑": { math: "\\mathfrak{N}", alt: ["unicode-math"] }, "𝔒": { math: "\\mathfrak{O}", alt: ["unicode-math"] }, "𝔓": { math: "\\mathfrak{P}", alt: ["unicode-math"] }, "𝔔": { math: "\\mathfrak{Q}", alt: ["unicode-math"] }, "𝔖": { math: "\\mathfrak{S}", alt: ["unicode-math"] }, "𝔗": { math: "\\mathfrak{T}", alt: ["unicode-math"] }, "𝔘": { math: "\\mathfrak{U}", alt: ["unicode-math"] }, "𝔙": { math: "\\mathfrak{V}", alt: ["unicode-math"] }, "𝔚": { math: "\\mathfrak{W}", alt: ["unicode-math"] }, "𝔛": { math: "\\mathfrak{X}", alt: ["unicode-math"] }, "𝔜": { math: "\\mathfrak{Y}", alt: ["unicode-math"] }, "𝔞": { math: "\\mathfrak{a}", alt: ["unicode-math"] }, "𝔟": { math: "\\mathfrak{b}", alt: ["unicode-math"] }, "𝔠": { math: "\\mathfrak{c}", alt: ["unicode-math"] }, "𝔡": { math: "\\mathfrak{d}", alt: ["unicode-math"] }, "𝔢": { math: "\\mathfrak{e}", alt: ["unicode-math"] }, "𝔣": { math: "\\mathfrak{f}", alt: ["unicode-math"] }, "𝔤": { math: "\\mathfrak{g}", alt: ["unicode-math"] }, "𝔥": { math: "\\mathfrak{h}", alt: ["unicode-math"] }, "𝔦": { math: "\\mathfrak{i}", alt: ["unicode-math"] }, "𝔧": { math: "\\mathfrak{j}", alt: ["unicode-math"] }, "𝔨": { math: "\\mathfrak{k}", alt: ["unicode-math"] }, "𝔩": { math: "\\mathfrak{l}", alt: ["unicode-math"] }, "𝔪": { math: "\\mathfrak{m}", alt: ["unicode-math"] }, "𝔫": { math: "\\mathfrak{n}", alt: ["unicode-math"] }, "𝔬": { math: "\\mathfrak{o}", alt: ["unicode-math"] }, "𝔭": { math: "\\mathfrak{p}", alt: ["unicode-math"] }, "𝔮": { math: "\\mathfrak{q}", alt: ["unicode-math"] }, "𝔯": { math: "\\mathfrak{r}", alt: ["unicode-math"] }, "𝔰": { math: "\\mathfrak{s}", alt: ["unicode-math"] }, "𝔱": { math: "\\mathfrak{t}", alt: ["unicode-math"] }, "𝔲": { math: "\\mathfrak{u}", alt: ["unicode-math"] }, "𝔳": { math: "\\mathfrak{v}", alt: ["unicode-math"] }, "𝔴": { math: "\\mathfrak{w}", alt: ["unicode-math"] }, "𝔵": { math: "\\mathfrak{x}", alt: ["unicode-math"] }, "𝔶": { math: "\\mathfrak{y}", alt: ["unicode-math"] }, "𝔷": { math: "\\mathfrak{z}", alt: ["unicode-math"] }, "𝔸": { math: "\\mathbb{A}", alt: ["unicode-math"] }, "𝔹": { math: "\\mathbb{B}", alt: ["unicode-math"] }, "𝔻": { math: "\\mathbb{D}", alt: ["unicode-math"] }, "𝔼": { math: "\\mathbb{E}", alt: ["unicode-math"] }, "𝔽": { math: "\\mathbb{F}", alt: ["unicode-math"] }, "𝔾": { math: "\\mathbb{G}", alt: ["unicode-math"] }, "𝕀": { math: "\\mathbb{I}", alt: ["unicode-math"] }, "𝕁": { math: "\\mathbb{J}", alt: ["unicode-math"] }, "𝕂": { math: "\\mathbb{K}", alt: ["unicode-math"] }, "𝕃": { math: "\\mathbb{L}", alt: ["unicode-math"] }, "𝕄": { math: "\\mathbb{M}", alt: ["unicode-math"] }, "𝕆": { math: "\\mathbb{O}", alt: ["unicode-math"] }, "𝕊": { math: "\\mathbb{S}", alt: ["unicode-math"] }, "𝕋": { math: "\\mathbb{T}", alt: ["unicode-math"] }, "𝕌": { math: "\\mathbb{U}", alt: ["unicode-math"] }, "𝕍": { math: "\\mathbb{V}", alt: ["unicode-math"] }, "𝕎": { math: "\\mathbb{W}", alt: ["unicode-math"] }, "𝕏": { math: "\\mathbb{X}", alt: ["unicode-math"] }, "𝕐": { math: "\\mathbb{Y}", alt: ["unicode-math"] }, "𝕒": { math: "\\mathbb{a}", alt: ["unicode-math"] }, "𝕓": { math: "\\mathbb{b}", alt: ["unicode-math"] }, "𝕔": { math: "\\mathbb{c}", alt: ["unicode-math"] }, "𝕕": { math: "\\mathbb{d}", alt: ["unicode-math"] }, "𝕖": { math: "\\mathbb{e}", alt: ["unicode-math"] }, "𝕗": { math: "\\mathbb{f}", alt: ["unicode-math"] }, "𝕘": { math: "\\mathbb{g}", alt: ["unicode-math"] }, "𝕙": { math: "\\mathbb{h}", alt: ["unicode-math"] }, "𝕚": { math: "\\mathbb{i}", alt: ["unicode-math"] }, "𝕛": { math: "\\mathbb{j}", alt: ["unicode-math"] }, "𝕜": { math: "\\mathbb{k}", alt: ["unicode-math"] }, "𝕝": { math: "\\mathbb{l}", alt: ["unicode-math"] }, "𝕞": { math: "\\mathbb{m}", alt: ["unicode-math"] }, "𝕟": { math: "\\mathbb{n}", alt: ["unicode-math"] }, "𝕠": { math: "\\mathbb{o}", alt: ["unicode-math"] }, "𝕡": { math: "\\mathbb{p}", alt: ["unicode-math"] }, "𝕢": { math: "\\mathbb{q}", alt: ["unicode-math"] }, "𝕣": { math: "\\mathbb{r}", alt: ["unicode-math"] }, "𝕤": { math: "\\mathbb{s}", alt: ["unicode-math"] }, "𝕥": { math: "\\mathbb{t}", alt: ["unicode-math"] }, "𝕦": { math: "\\mathbb{u}", alt: ["unicode-math"] }, "𝕧": { math: "\\mathbb{v}", alt: ["unicode-math"] }, "𝕨": { math: "\\mathbb{w}", alt: ["unicode-math"] }, "𝕩": { math: "\\mathbb{x}", alt: ["unicode-math"] }, "𝕪": { math: "\\mathbb{y}", alt: ["unicode-math"] }, "𝕫": { math: "\\mathbb{z}", alt: ["unicode-math"] }, "𝕬": { math: "A", alt: ["unicode-math"] }, "𝕭": { math: "B", alt: ["unicode-math"] }, "𝕮": { math: "C", alt: ["unicode-math"] }, "𝕯": { math: "D", alt: ["unicode-math"] }, "𝕰": { math: "E", alt: ["unicode-math"] }, "𝕱": { math: "F", alt: ["unicode-math"] }, "𝕲": { math: "G", alt: ["unicode-math"] }, "𝕳": { math: "H", alt: ["unicode-math"] }, "𝕴": { math: "I", alt: ["unicode-math"] }, "𝕵": { math: "J", alt: ["unicode-math"] }, "𝕶": { math: "K", alt: ["unicode-math"] }, "𝕷": { math: "L", alt: ["unicode-math"] }, "𝕸": { math: "M", alt: ["unicode-math"] }, "𝕹": { math: "N", alt: ["unicode-math"] }, "𝕺": { math: "O", alt: ["unicode-math"] }, "𝕻": { math: "P", alt: ["unicode-math"] }, "𝕼": { math: "Q", alt: ["unicode-math"] }, "𝕽": { math: "R", alt: ["unicode-math"] }, "𝕾": { math: "S", alt: ["unicode-math"] }, "𝕿": { math: "T", alt: ["unicode-math"] }, "𝖀": { math: "U", alt: ["unicode-math"] }, "𝖁": { math: "V", alt: ["unicode-math"] }, "𝖂": { math: "W", alt: ["unicode-math"] }, "𝖃": { math: "X", alt: ["unicode-math"] }, "𝖄": { math: "Y", alt: ["unicode-math"] }, "𝖅": { math: "Z", alt: ["unicode-math"] }, "𝖆": { math: "a", alt: ["unicode-math"] }, "𝖇": { math: "b", alt: ["unicode-math"] }, "𝖈": { math: "c", alt: ["unicode-math"] }, "𝖉": { math: "d", alt: ["unicode-math"] }, "𝖊": { math: "e", alt: ["unicode-math"] }, "𝖋": { math: "f", alt: ["unicode-math"] }, "𝖌": { math: "g", alt: ["unicode-math"] }, "𝖍": { math: "h", alt: ["unicode-math"] }, "𝖎": { math: "i", alt: ["unicode-math"] }, "𝖏": { math: "j", alt: ["unicode-math"] }, "𝖐": { math: "k", alt: ["unicode-math"] }, "𝖑": { math: "l", alt: ["unicode-math"] }, "𝖒": { math: "m", alt: ["unicode-math"] }, "𝖓": { math: "n", alt: ["unicode-math"] }, "𝖔": { math: "o", alt: ["unicode-math"] }, "𝖕": { math: "p", alt: ["unicode-math"] }, "𝖖": { math: "q", alt: ["unicode-math"] }, "𝖗": { math: "r", alt: ["unicode-math"] }, "𝖘": { math: "s", alt: ["unicode-math"] }, "𝖙": { math: "t", alt: ["unicode-math"] }, "𝖚": { math: "u", alt: ["unicode-math"] }, "𝖛": { math: "v", alt: ["unicode-math"] }, "𝖜": { math: "w", alt: ["unicode-math"] }, "𝖝": { math: "x", alt: ["unicode-math"] }, "𝖞": { math: "y", alt: ["unicode-math"] }, "𝖟": { math: "z", alt: ["unicode-math"] }, "𝖠": { math: "\\mathsf{A}", alt: ["unicode-math"] }, "𝖡": { math: "\\mathsf{B}", alt: ["unicode-math"] }, "𝖢": { math: "\\mathsf{C}", alt: ["unicode-math"] }, "𝖣": { math: "\\mathsf{D}", alt: ["unicode-math"] }, "𝖤": { math: "\\mathsf{E}", alt: ["unicode-math"] }, "𝖥": { math: "\\mathsf{F}", alt: ["unicode-math"] }, "𝖦": { math: "\\mathsf{G}", alt: ["unicode-math"] }, "𝖧": { math: "\\mathsf{H}", alt: ["unicode-math"] }, "𝖨": { math: "\\mathsf{I}", alt: ["unicode-math"] }, "𝖩": { math: "\\mathsf{J}", alt: ["unicode-math"] }, "𝖪": { math: "\\mathsf{K}", alt: ["unicode-math"] }, "𝖫": { math: "\\mathsf{L}", alt: ["unicode-math"] }, "𝖬": { math: "\\mathsf{M}", alt: ["unicode-math"] }, "𝖭": { math: "\\mathsf{N}", alt: ["unicode-math"] }, "𝖮": { math: "\\mathsf{O}", alt: ["unicode-math"] }, "𝖯": { math: "\\mathsf{P}", alt: ["unicode-math"] }, "𝖰": { math: "\\mathsf{Q}", alt: ["unicode-math"] }, "𝖱": { math: "\\mathsf{R}", alt: ["unicode-math"] }, "𝖲": { math: "\\mathsf{S}", alt: ["unicode-math"] }, "𝖳": { math: "\\mathsf{T}", alt: ["unicode-math"] }, "𝖴": { math: "\\mathsf{U}", alt: ["unicode-math"] }, "𝖵": { math: "\\mathsf{V}", alt: ["unicode-math"] }, "𝖶": { math: "\\mathsf{W}", alt: ["unicode-math"] }, "𝖷": { math: "\\mathsf{X}", alt: ["unicode-math"] }, "𝖸": { math: "\\mathsf{Y}", alt: ["unicode-math"] }, "𝖹": { math: "\\mathsf{Z}", alt: ["unicode-math"] }, "𝖺": { math: "\\mathsf{a}", alt: ["unicode-math"] }, "𝖻": { math: "\\mathsf{b}", alt: ["unicode-math"] }, "𝖼": { math: "\\mathsf{c}", alt: ["unicode-math"] }, "𝖽": { math: "\\mathsf{d}", alt: ["unicode-math"] }, "𝖾": { math: "\\mathsf{e}", alt: ["unicode-math"] }, "𝖿": { math: "\\mathsf{f}", alt: ["unicode-math"] }, "𝗀": { math: "\\mathsf{g}", alt: ["unicode-math"] }, "𝗁": { math: "\\mathsf{h}", alt: ["unicode-math"] }, "𝗂": { math: "\\mathsf{i}", alt: ["unicode-math"] }, "𝗃": { math: "\\mathsf{j}", alt: ["unicode-math"] }, "𝗄": { math: "\\mathsf{k}", alt: ["unicode-math"] }, "𝗅": { math: "\\mathsf{l}", alt: ["unicode-math"] }, "𝗆": { math: "\\mathsf{m}", alt: ["unicode-math"] }, "𝗇": { math: "\\mathsf{n}", alt: ["unicode-math"] }, "𝗈": { math: "\\mathsf{o}", alt: ["unicode-math"] }, "𝗉": { math: "\\mathsf{p}", alt: ["unicode-math"] }, "𝗊": { math: "\\mathsf{q}", alt: ["unicode-math"] }, "𝗋": { math: "\\mathsf{r}", alt: ["unicode-math"] }, "𝗌": { math: "\\mathsf{s}", alt: ["unicode-math"] }, "𝗍": { math: "\\mathsf{t}", alt: ["unicode-math"] }, "𝗎": { math: "\\mathsf{u}", alt: ["unicode-math"] }, "𝗏": { math: "\\mathsf{v}", alt: ["unicode-math"] }, "𝗐": { math: "\\mathsf{w}", alt: ["unicode-math"] }, "𝗑": { math: "\\mathsf{x}", alt: ["unicode-math"] }, "𝗒": { math: "\\mathsf{y}", alt: ["unicode-math"] }, "𝗓": { math: "\\mathsf{z}", alt: ["unicode-math"] }, "𝗔": { math: "\\mathsfbf{A}", alt: ["unicode-math"] }, "𝗕": { math: "\\mathsfbf{B}", alt: ["unicode-math"] }, "𝗖": { math: "\\mathsfbf{C}", alt: ["unicode-math"] }, "𝗗": { math: "\\mathsfbf{D}", alt: ["unicode-math"] }, "𝗘": { math: "\\mathsfbf{E}", alt: ["unicode-math"] }, "𝗙": { math: "\\mathsfbf{F}", alt: ["unicode-math"] }, "𝗚": { math: "\\mathsfbf{G}", alt: ["unicode-math"] }, "𝗛": { math: "\\mathsfbf{H}", alt: ["unicode-math"] }, "𝗜": { math: "\\mathsfbf{I}", alt: ["unicode-math"] }, "𝗝": { math: "\\mathsfbf{J}", alt: ["unicode-math"] }, "𝗞": { math: "\\mathsfbf{K}", alt: ["unicode-math"] }, "𝗟": { math: "\\mathsfbf{L}", alt: ["unicode-math"] }, "𝗠": { math: "\\mathsfbf{M}", alt: ["unicode-math"] }, "𝗡": { math: "\\mathsfbf{N}", alt: ["unicode-math"] }, "𝗢": { math: "\\mathsfbf{O}", alt: ["unicode-math"] }, "𝗣": { math: "\\mathsfbf{P}", alt: ["unicode-math"] }, "𝗤": { math: "\\mathsfbf{Q}", alt: ["unicode-math"] }, "𝗥": { math: "\\mathsfbf{R}", alt: ["unicode-math"] }, "𝗦": { math: "\\mathsfbf{S}", alt: ["unicode-math"] }, "𝗧": { math: "\\mathsfbf{T}", alt: ["unicode-math"] }, "𝗨": { math: "\\mathsfbf{U}", alt: ["unicode-math"] }, "𝗩": { math: "\\mathsfbf{V}", alt: ["unicode-math"] }, "𝗪": { math: "\\mathsfbf{W}", alt: ["unicode-math"] }, "𝗫": { math: "\\mathsfbf{X}", alt: ["unicode-math"] }, "𝗬": { math: "\\mathsfbf{Y}", alt: ["unicode-math"] }, "𝗭": { math: "\\mathsfbf{Z}", alt: ["unicode-math"] }, "𝗮": { math: "\\mathsfbf{a}", alt: ["unicode-math"] }, "𝗯": { math: "\\mathsfbf{b}", alt: ["unicode-math"] }, "𝗰": { math: "\\mathsfbf{c}", alt: ["unicode-math"] }, "𝗱": { math: "\\mathsfbf{d}", alt: ["unicode-math"] }, "𝗲": { math: "\\mathsfbf{e}", alt: ["unicode-math"] }, "𝗳": { math: "\\mathsfbf{f}", alt: ["unicode-math"] }, "𝗴": { math: "\\mathsfbf{g}", alt: ["unicode-math"] }, "𝗵": { math: "\\mathsfbf{h}", alt: ["unicode-math"] }, "𝗶": { math: "\\mathsfbf{i}", alt: ["unicode-math"] }, "𝗷": { math: "\\mathsfbf{j}", alt: ["unicode-math"] }, "𝗸": { math: "\\mathsfbf{k}", alt: ["unicode-math"] }, "𝗹": { math: "\\mathsfbf{l}", alt: ["unicode-math"] }, "𝗺": { math: "\\mathsfbf{m}", alt: ["unicode-math"] }, "𝗻": { math: "\\mathsfbf{n}", alt: ["unicode-math"] }, "𝗼": { math: "\\mathsfbf{o}", alt: ["unicode-math"] }, "𝗽": { math: "\\mathsfbf{p}", alt: ["unicode-math"] }, "𝗾": { math: "\\mathsfbf{q}", alt: ["unicode-math"] }, "𝗿": { math: "\\mathsfbf{r}", alt: ["unicode-math"] }, "𝘀": { math: "\\mathsfbf{s}", alt: ["unicode-math"] }, "𝘁": { math: "\\mathsfbf{t}", alt: ["unicode-math"] }, "𝘂": { math: "\\mathsfbf{u}", alt: ["unicode-math"] }, "𝘃": { math: "\\mathsfbf{v}", alt: ["unicode-math"] }, "𝘄": { math: "\\mathsfbf{w}", alt: ["unicode-math"] }, "𝘅": { math: "\\mathsfbf{x}", alt: ["unicode-math"] }, "𝘆": { math: "\\mathsfbf{y}", alt: ["unicode-math"] }, "𝘇": { math: "\\mathsfbf{z}", alt: ["unicode-math"] }, "𝘈": { math: "\\mathsfsl{A}", alt: ["unicode-math"] }, "𝘉": { math: "\\mathsfsl{B}", alt: ["unicode-math"] }, "𝘊": { math: "\\mathsfsl{C}", alt: ["unicode-math"] }, "𝘋": { math: "\\mathsfsl{D}", alt: ["unicode-math"] }, "𝘌": { math: "\\mathsfsl{E}", alt: ["unicode-math"] }, "𝘍": { math: "\\mathsfsl{F}", alt: ["unicode-math"] }, "𝘎": { math: "\\mathsfsl{G}", alt: ["unicode-math"] }, "𝘏": { math: "\\mathsfsl{H}", alt: ["unicode-math"] }, "𝘐": { math: "\\mathsfsl{I}", alt: ["unicode-math"] }, "𝘑": { math: "\\mathsfsl{J}", alt: ["unicode-math"] }, "𝘒": { math: "\\mathsfsl{K}", alt: ["unicode-math"] }, "𝘓": { math: "\\mathsfsl{L}", alt: ["unicode-math"] }, "𝘔": { math: "\\mathsfsl{M}", alt: ["unicode-math"] }, "𝘕": { math: "\\mathsfsl{N}", alt: ["unicode-math"] }, "𝘖": { math: "\\mathsfsl{O}", alt: ["unicode-math"] }, "𝘗": { math: "\\mathsfsl{P}", alt: ["unicode-math"] }, "𝘘": { math: "\\mathsfsl{Q}", alt: ["unicode-math"] }, "𝘙": { math: "\\mathsfsl{R}", alt: ["unicode-math"] }, "𝘚": { math: "\\mathsfsl{S}", alt: ["unicode-math"] }, "𝘛": { math: "\\mathsfsl{T}", alt: ["unicode-math"] }, "𝘜": { math: "\\mathsfsl{U}", alt: ["unicode-math"] }, "𝘝": { math: "\\mathsfsl{V}", alt: ["unicode-math"] }, "𝘞": { math: "\\mathsfsl{W}", alt: ["unicode-math"] }, "𝘟": { math: "\\mathsfsl{X}", alt: ["unicode-math"] }, "𝘠": { math: "\\mathsfsl{Y}", alt: ["unicode-math"] }, "𝘡": { math: "\\mathsfsl{Z}", alt: ["unicode-math"] }, "𝘢": { math: "\\mathsfsl{a}", alt: ["unicode-math"] }, "𝘣": { math: "\\mathsfsl{b}", alt: ["unicode-math"] }, "𝘤": { math: "\\mathsfsl{c}", alt: ["unicode-math"] }, "𝘥": { math: "\\mathsfsl{d}", alt: ["unicode-math"] }, "𝘦": { math: "\\mathsfsl{e}", alt: ["unicode-math"] }, "𝘧": { math: "\\mathsfsl{f}", alt: ["unicode-math"] }, "𝘨": { math: "\\mathsfsl{g}", alt: ["unicode-math"] }, "𝘩": { math: "\\mathsfsl{h}", alt: ["unicode-math"] }, "𝘪": { math: "\\mathsfsl{i}", alt: ["unicode-math"] }, "𝘫": { math: "\\mathsfsl{j}", alt: ["unicode-math"] }, "𝘬": { math: "\\mathsfsl{k}", alt: ["unicode-math"] }, "𝘭": { math: "\\mathsfsl{l}", alt: ["unicode-math"] }, "𝘮": { math: "\\mathsfsl{m}", alt: ["unicode-math"] }, "𝘯": { math: "\\mathsfsl{n}", alt: ["unicode-math"] }, "𝘰": { math: "\\mathsfsl{o}", alt: ["unicode-math"] }, "𝘱": { math: "\\mathsfsl{p}", alt: ["unicode-math"] }, "𝘲": { math: "\\mathsfsl{q}", alt: ["unicode-math"] }, "𝘳": { math: "\\mathsfsl{r}", alt: ["unicode-math"] }, "𝘴": { math: "\\mathsfsl{s}", alt: ["unicode-math"] }, "𝘵": { math: "\\mathsfsl{t}", alt: ["unicode-math"] }, "𝘶": { math: "\\mathsfsl{u}", alt: ["unicode-math"] }, "𝘷": { math: "\\mathsfsl{v}", alt: ["unicode-math"] }, "𝘸": { math: "\\mathsfsl{w}", alt: ["unicode-math"] }, "𝘹": { math: "\\mathsfsl{x}", alt: ["unicode-math"] }, "𝘺": { math: "\\mathsfsl{y}", alt: ["unicode-math"] }, "𝘻": { math: "\\mathsfsl{z}", alt: ["unicode-math"] }, "𝘼": { math: "\\mathsfbfsl{A}", alt: ["unicode-math"] }, "𝘽": { math: "\\mathsfbfsl{B}", alt: ["unicode-math"] }, "𝘾": { math: "\\mathsfbfsl{C}", alt: ["unicode-math"] }, "𝘿": { math: "\\mathsfbfsl{D}", alt: ["unicode-math"] }, "𝙀": { math: "\\mathsfbfsl{E}", alt: ["unicode-math"] }, "𝙁": { math: "\\mathsfbfsl{F}", alt: ["unicode-math"] }, "𝙂": { math: "\\mathsfbfsl{G}", alt: ["unicode-math"] }, "𝙃": { math: "\\mathsfbfsl{H}", alt: ["unicode-math"] }, "𝙄": { math: "\\mathsfbfsl{I}", alt: ["unicode-math"] }, "𝙅": { math: "\\mathsfbfsl{J}", alt: ["unicode-math"] }, "𝙆": { math: "\\mathsfbfsl{K}", alt: ["unicode-math"] }, "𝙇": { math: "\\mathsfbfsl{L}", alt: ["unicode-math"] }, "𝙈": { math: "\\mathsfbfsl{M}", alt: ["unicode-math"] }, "𝙉": { math: "\\mathsfbfsl{N}", alt: ["unicode-math"] }, "𝙊": { math: "\\mathsfbfsl{O}", alt: ["unicode-math"] }, "𝙋": { math: "\\mathsfbfsl{P}", alt: ["unicode-math"] }, "𝙌": { math: "\\mathsfbfsl{Q}", alt: ["unicode-math"] }, "𝙍": { math: "\\mathsfbfsl{R}", alt: ["unicode-math"] }, "𝙎": { math: "\\mathsfbfsl{S}", alt: ["unicode-math"] }, "𝙏": { math: "\\mathsfbfsl{T}", alt: ["unicode-math"] }, "𝙐": { math: "\\mathsfbfsl{U}", alt: ["unicode-math"] }, "𝙑": { math: "\\mathsfbfsl{V}", alt: ["unicode-math"] }, "𝙒": { math: "\\mathsfbfsl{W}", alt: ["unicode-math"] }, "𝙓": { math: "\\mathsfbfsl{X}", alt: ["unicode-math"] }, "𝙔": { math: "\\mathsfbfsl{Y}", alt: ["unicode-math"] }, "𝙕": { math: "\\mathsfbfsl{Z}", alt: ["unicode-math"] }, "𝙖": { math: "\\mathsfbfsl{a}", alt: ["unicode-math"] }, "𝙗": { math: "\\mathsfbfsl{b}", alt: ["unicode-math"] }, "𝙘": { math: "\\mathsfbfsl{c}", alt: ["unicode-math"] }, "𝙙": { math: "\\mathsfbfsl{d}", alt: ["unicode-math"] }, "𝙚": { math: "\\mathsfbfsl{e}", alt: ["unicode-math"] }, "𝙛": { math: "\\mathsfbfsl{f}", alt: ["unicode-math"] }, "𝙜": { math: "\\mathsfbfsl{g}", alt: ["unicode-math"] }, "𝙝": { math: "\\mathsfbfsl{h}", alt: ["unicode-math"] }, "𝙞": { math: "\\mathsfbfsl{i}", alt: ["unicode-math"] }, "𝙟": { math: "\\mathsfbfsl{j}", alt: ["unicode-math"] }, "𝙠": { math: "\\mathsfbfsl{k}", alt: ["unicode-math"] }, "𝙡": { math: "\\mathsfbfsl{l}", alt: ["unicode-math"] }, "𝙢": { math: "\\mathsfbfsl{m}", alt: ["unicode-math"] }, "𝙣": { math: "\\mathsfbfsl{n}", alt: ["unicode-math"] }, "𝙤": { math: "\\mathsfbfsl{o}", alt: ["unicode-math"] }, "𝙥": { math: "\\mathsfbfsl{p}", alt: ["unicode-math"] }, "𝙦": { math: "\\mathsfbfsl{q}", alt: ["unicode-math"] }, "𝙧": { math: "\\mathsfbfsl{r}", alt: ["unicode-math"] }, "𝙨": { math: "\\mathsfbfsl{s}", alt: ["unicode-math"] }, "𝙩": { math: "\\mathsfbfsl{t}", alt: ["unicode-math"] }, "𝙪": { math: "\\mathsfbfsl{u}", alt: ["unicode-math"] }, "𝙫": { math: "\\mathsfbfsl{v}", alt: ["unicode-math"] }, "𝙬": { math: "\\mathsfbfsl{w}", alt: ["unicode-math"] }, "𝙭": { math: "\\mathsfbfsl{x}", alt: ["unicode-math"] }, "𝙮": { math: "\\mathsfbfsl{y}", alt: ["unicode-math"] }, "𝙯": { math: "\\mathsfbfsl{z}", alt: ["unicode-math"] }, "𝙰": { math: "\\mathtt{A}", alt: ["unicode-math"] }, "𝙱": { math: "\\mathtt{B}", alt: ["unicode-math"] }, "𝙲": { math: "\\mathtt{C}", alt: ["unicode-math"] }, "𝙳": { math: "\\mathtt{D}", alt: ["unicode-math"] }, "𝙴": { math: "\\mathtt{E}", alt: ["unicode-math"] }, "𝙵": { math: "\\mathtt{F}", alt: ["unicode-math"] }, "𝙶": { math: "\\mathtt{G}", alt: ["unicode-math"] }, "𝙷": { math: "\\mathtt{H}", alt: ["unicode-math"] }, "𝙸": { math: "\\mathtt{I}", alt: ["unicode-math"] }, "𝙹": { math: "\\mathtt{J}", alt: ["unicode-math"] }, "𝙺": { math: "\\mathtt{K}", alt: ["unicode-math"] }, "𝙻": { math: "\\mathtt{L}", alt: ["unicode-math"] }, "𝙼": { math: "\\mathtt{M}", alt: ["unicode-math"] }, "𝙽": { math: "\\mathtt{N}", alt: ["unicode-math"] }, "𝙾": { math: "\\mathtt{O}", alt: ["unicode-math"] }, "𝙿": { math: "\\mathtt{P}", alt: ["unicode-math"] }, "𝚀": { math: "\\mathtt{Q}", alt: ["unicode-math"] }, "𝚁": { math: "\\mathtt{R}", alt: ["unicode-math"] }, "𝚂": { math: "\\mathtt{S}", alt: ["unicode-math"] }, "𝚃": { math: "\\mathtt{T}", alt: ["unicode-math"] }, "𝚄": { math: "\\mathtt{U}", alt: ["unicode-math"] }, "𝚅": { math: "\\mathtt{V}", alt: ["unicode-math"] }, "𝚆": { math: "\\mathtt{W}", alt: ["unicode-math"] }, "𝚇": { math: "\\mathtt{X}", alt: ["unicode-math"] }, "𝚈": { math: "\\mathtt{Y}", alt: ["unicode-math"] }, "𝚉": { math: "\\mathtt{Z}", alt: ["unicode-math"] }, "𝚊": { math: "\\mathtt{a}", alt: ["unicode-math"] }, "𝚋": { math: "\\mathtt{b}", alt: ["unicode-math"] }, "𝚌": { math: "\\mathtt{c}", alt: ["unicode-math"] }, "𝚍": { math: "\\mathtt{d}", alt: ["unicode-math"] }, "𝚎": { math: "\\mathtt{e}", alt: ["unicode-math"] }, "𝚏": { math: "\\mathtt{f}", alt: ["unicode-math"] }, "𝚐": { math: "\\mathtt{g}", alt: ["unicode-math"] }, "𝚑": { math: "\\mathtt{h}", alt: ["unicode-math"] }, "𝚒": { math: "\\mathtt{i}", alt: ["unicode-math"] }, "𝚓": { math: "\\mathtt{j}", alt: ["unicode-math"] }, "𝚔": { math: "\\mathtt{k}", alt: ["unicode-math"] }, "𝚕": { math: "\\mathtt{l}", alt: ["unicode-math"] }, "𝚖": { math: "\\mathtt{m}", alt: ["unicode-math"] }, "𝚗": { math: "\\mathtt{n}", alt: ["unicode-math"] }, "𝚘": { math: "\\mathtt{o}", alt: ["unicode-math"] }, "𝚙": { math: "\\mathtt{p}", alt: ["unicode-math"] }, "𝚚": { math: "\\mathtt{q}", alt: ["unicode-math"] }, "𝚛": { math: "\\mathtt{r}", alt: ["unicode-math"] }, "𝚜": { math: "\\mathtt{s}", alt: ["unicode-math"] }, "𝚝": { math: "\\mathtt{t}", alt: ["unicode-math"] }, "𝚞": { math: "\\mathtt{u}", alt: ["unicode-math"] }, "𝚟": { math: "\\mathtt{v}", alt: ["unicode-math"] }, "𝚠": { math: "\\mathtt{w}", alt: ["unicode-math"] }, "𝚡": { math: "\\mathtt{x}", alt: ["unicode-math"] }, "𝚢": { math: "\\mathtt{y}", alt: ["unicode-math"] }, "𝚣": { math: "\\mathtt{z}", alt: ["unicode-math"] }, "𝚤": { math: "\\imath", alt: ["unicode-math"] }, "𝚥": { math: "\\jmath", alt: ["unicode-math"] }, "𝚨": { math: "\\mathbf{A}", alt: ["unicode-math"] }, "𝚩": { math: "\\mathbf{B}", alt: ["unicode-math"] }, "𝚪": { math: "\\mathbf{\\Gamma}", alt: ["unicode-math"] }, "𝚫": { math: "\\mathbf{\\Delta}", alt: ["unicode-math"] }, "𝚬": { math: "\\mathbf{E}", alt: ["unicode-math"] }, "𝚭": { math: "\\mathbf{Z}", alt: ["unicode-math"] }, "𝚮": { math: "\\mathbf{H}", alt: ["unicode-math"] }, "𝚯": { math: "\\mathbf{\\Theta}", alt: ["unicode-math"] }, "𝚰": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝚱": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝚲": { math: "\\mathbf{\\Lambda}", alt: ["unicode-math"] }, "𝚳": { math: "M", alt: ["unicode-math"] }, "𝚴": { math: "N", alt: ["unicode-math"] }, "𝚵": { math: "\\mathbf{\\Xi}", alt: ["unicode-math"] }, "𝚶": { math: "O", alt: ["unicode-math"] }, "𝚷": { math: "\\mathbf{\\Pi}", alt: ["unicode-math"] }, "𝚸": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝚹": { math: "\\mathbf{\\vartheta}", alt: ["unicode-math"] }, "𝚺": { math: "\\mathbf{\\Sigma}", alt: ["unicode-math"] }, "𝚻": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝚼": { math: "\\mathbf{\\Upsilon}", alt: ["unicode-math"] }, "𝚽": { math: "\\mathbf{\\Phi}", alt: ["unicode-math"] }, "𝚾": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝚿": { math: "\\mathbf{\\Psi}", alt: ["unicode-math"] }, "𝛀": { math: "\\mathbf{\\Omega}", alt: ["unicode-math"] }, "𝛁": { math: "\\mathbf{\\nabla}", alt: ["unicode-math"] }, "𝛂": { math: "\\mathbf{\\alpha}", alt: ["unicode-math"] }, "𝛃": { math: "\\mathbf{\\beta}", alt: ["unicode-math"] }, "𝛄": { math: "\\mathbf{\\gamma}", alt: ["unicode-math"] }, "𝛅": { math: "\\mathbf{\\delta}", alt: ["unicode-math"] }, "𝛆": { math: "\\mathbf{\\epsilon}", alt: ["unicode-math"] }, "𝛇": { math: "\\mathbf{\\zeta}", alt: ["unicode-math"] }, "𝛈": { math: "\\mathbf{\\eta}", alt: ["unicode-math"] }, "𝛉": { math: "\\mathbf{\\theta}", alt: ["unicode-math"] }, "𝛊": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝛋": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝛌": { math: "\\mathbf{\\lambda}", alt: ["unicode-math"] }, "𝛍": { math: "m", alt: ["unicode-math"] }, "𝛎": { math: "v", alt: ["unicode-math"] }, "𝛏": { math: "\\mathbf{\\xi}", alt: ["unicode-math"] }, "𝛐": { math: "O", alt: ["unicode-math"] }, "𝛑": { math: "\\mathbf{\\pi}", alt: ["unicode-math"] }, "𝛒": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝛓": { math: "\\mathbf{\\varsigma}", alt: ["unicode-math"] }, "𝛔": { math: "\\mathbf{\\sigma}", alt: ["unicode-math"] }, "𝛕": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝛖": { math: "\\mathbf{\\upsilon}", alt: ["unicode-math"] }, "𝛗": { math: "\\mathbf{\\phi}", alt: ["unicode-math"] }, "𝛘": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝛙": { math: "\\mathbf{\\psi}", alt: ["unicode-math"] }, "𝛚": { math: "\\mathbf{\\omega}", alt: ["unicode-math"] }, "𝛛": { math: "\\partial", alt: ["unicode-math"] }, "𝛜": { math: "\\in", alt: ["unicode-math"] }, "𝛝": { math: "\\mathbf{\\vartheta}", alt: ["unicode-math"] }, "𝛞": { math: "\\mathbf{\\varkappa}", alt: ["unicode-math"] }, "𝛟": { math: "\\mathbf{\\phi}", alt: ["unicode-math"] }, "𝛠": { math: "\\mathbf{\\varrho}", alt: ["unicode-math"] }, "𝛡": { math: "\\mathbf{\\varpi}", alt: ["unicode-math"] }, "𝛢": { math: "A", alt: ["unicode-math"] }, "𝛣": { math: "B", alt: ["unicode-math"] }, "𝛤": { math: "\\Gamma", alt: ["unicode-math"] }, "𝛥": { math: "\\Delta", alt: ["unicode-math"] }, "𝛦": { math: "E", alt: ["unicode-math"] }, "𝛧": { math: "Z", alt: ["unicode-math"] }, "𝛨": { math: "H", alt: ["unicode-math"] }, "𝛩": { math: "\\Theta", alt: ["unicode-math"] }, "𝛪": { math: "I", alt: ["unicode-math"] }, "𝛫": { math: "K", alt: ["unicode-math"] }, "𝛬": { math: "\\Lambda", alt: ["unicode-math"] }, "𝛭": { math: "M", alt: ["unicode-math"] }, "𝛮": { math: "N", alt: ["unicode-math"] }, "𝛯": { math: "\\Xi", alt: ["unicode-math"] }, "𝛰": { math: "O", alt: ["unicode-math"] }, "𝛱": { math: "\\Pi", alt: ["unicode-math"] }, "𝛲": { math: "P", alt: ["unicode-math"] }, "𝛳": { math: "\\Theta", alt: ["unicode-math"] }, "𝛴": { math: "\\Sigma", alt: ["unicode-math"] }, "𝛵": { math: "T", alt: ["unicode-math"] }, "𝛶": { math: "\\Upsilon", alt: ["unicode-math"] }, "𝛷": { math: "\\Phi", alt: ["unicode-math"] }, "𝛸": { math: "X", alt: ["unicode-math"] }, "𝛹": { math: "\\Psi", alt: ["unicode-math"] }, "𝛺": { math: "\\Omega", alt: ["unicode-math"] }, "𝛻": { math: "\\nabla", alt: ["unicode-math"] }, "𝛼": { math: "A", alt: ["unicode-math"] }, "𝛽": { math: "B", alt: ["unicode-math"] }, "𝛾": { math: "\\gamma", alt: ["unicode-math"] }, "𝛿": { math: "\\delta", alt: ["unicode-math"] }, "𝜀": { math: "E", alt: ["unicode-math"] }, "𝜁": { math: "Z", alt: ["unicode-math"] }, "𝜂": { math: "H", alt: ["unicode-math"] }, "𝜃": { math: "\\theta", alt: ["unicode-math"] }, "𝜄": { math: "I", alt: ["unicode-math"] }, "𝜅": { math: "K", alt: ["unicode-math"] }, "𝜆": { math: "\\lambda", alt: ["unicode-math"] }, "𝜇": { math: "\\mu", alt: ["unicode-math"] }, "𝜈": { math: "\\nu", alt: ["unicode-math"] }, "𝜉": { math: "\\xi", alt: ["unicode-math"] }, "𝜊": { math: "o", alt: ["unicode-math"] }, "𝜋": { math: "\\pi", alt: ["unicode-math"] }, "𝜍": { math: "\\varsigma", alt: ["unicode-math"] }, "𝜎": { math: "\\sigma", alt: ["unicode-math"] }, "𝜏": { math: "T", alt: ["unicode-math"] }, "𝜐": { math: "\\upsilon", alt: ["unicode-math"] }, "𝜑": { math: "\\varphi", alt: ["unicode-math"] }, "𝜒": { math: "X", alt: ["unicode-math"] }, "𝜓": { math: "\\psi", alt: ["unicode-math"] }, "𝜔": { math: "\\omega", alt: ["unicode-math"] }, "𝜕": { math: "\\partial", alt: ["unicode-math"] }, "𝜖": { math: "\\in", alt: ["unicode-math"] }, "𝜗": { math: "\\vartheta", alt: ["unicode-math"] }, "𝜘": { math: "\\varkappa", alt: ["unicode-math"] }, "𝜙": { math: "\\phi", alt: ["unicode-math"] }, "𝜚": { math: "\\varrho", alt: ["unicode-math"] }, "𝜛": { math: "\\varpi", alt: ["unicode-math"] }, "𝜜": { math: "\\mathbit{A}", alt: ["unicode-math"] }, "𝜝": { math: "\\mathbit{B}", alt: ["unicode-math"] }, "𝜞": { math: "\\mathbit{\\Gamma}", alt: ["unicode-math"] }, "𝜟": { math: "\\mathbit{\\Delta}", alt: ["unicode-math"] }, "𝜠": { math: "\\mathbit{E}", alt: ["unicode-math"] }, "𝜡": { math: "\\mathbit{Z}", alt: ["unicode-math"] }, "𝜢": { math: "\\mathbit{H}", alt: ["unicode-math"] }, "𝜣": { math: "\\mathbit{\\Theta}", alt: ["unicode-math"] }, "𝜤": { math: "\\mathbit{I}", alt: ["unicode-math"] }, "𝜥": { math: "\\mathbit{K}", alt: ["unicode-math"] }, "𝜦": { math: "\\mathbit{\\Lambda}", alt: ["unicode-math"] }, "𝜧": { math: "M", alt: ["unicode-math"] }, "𝜨": { math: "N", alt: ["unicode-math"] }, "𝜩": { math: "\\mathbit{\\Xi}", alt: ["unicode-math"] }, "𝜪": { math: "O", alt: ["unicode-math"] }, "𝜫": { math: "\\mathbit{\\Pi}", alt: ["unicode-math"] }, "𝜬": { math: "\\mathbit{P}", alt: ["unicode-math"] }, "𝜭": { math: "\\mathbit{O}", alt: ["unicode-math"] }, "𝜮": { math: "\\mathbit{\\Sigma}", alt: ["unicode-math"] }, "𝜯": { math: "\\mathbit{T}", alt: ["unicode-math"] }, "𝜰": { math: "\\mathbit{\\Upsilon}", alt: ["unicode-math"] }, "𝜱": { math: "\\mathbit{\\Phi}", alt: ["unicode-math"] }, "𝜲": { math: "\\mathbit{X}", alt: ["unicode-math"] }, "𝜳": { math: "\\mathbit{\\Psi}", alt: ["unicode-math"] }, "𝜴": { math: "\\mathbit{\\Omega}", alt: ["unicode-math"] }, "𝜵": { math: "\\mathbit{\\nabla}", alt: ["unicode-math"] }, "𝜶": { math: "\\mathbit{\\alpha}", alt: ["unicode-math"] }, "𝜷": { math: "\\mathbit{\\beta}", alt: ["unicode-math"] }, "𝜸": { math: "\\mathbit{\\gamma}", alt: ["unicode-math"] }, "𝜹": { math: "\\mathbit{\\delta}", alt: ["unicode-math"] }, "𝜺": { math: "\\mathbit{\\epsilon}", alt: ["unicode-math"] }, "𝜻": { math: "\\mathbit{\\zeta}", alt: ["unicode-math"] }, "𝜼": { math: "\\mathbit{\\eta}", alt: ["unicode-math"] }, "𝜽": { math: "\\mathbit{\\theta}", alt: ["unicode-math"] }, "𝜾": { math: "\\mathbit{\\imath}", alt: ["unicode-math"] }, "𝜿": { math: "\\mathbit{\\kappa}", alt: ["unicode-math"] }, "𝝀": { math: "\\mathbit{\\lambda}", alt: ["unicode-math"] }, "𝝁": { math: "\\mu", alt: ["unicode-math"] }, "𝝂": { math: "v", alt: ["unicode-math"] }, "𝝃": { math: "\\mathbit{\\xi}", alt: ["unicode-math"] }, "𝝄": { math: "O", alt: ["unicode-math"] }, "𝝅": { math: "\\mathbit{\\pi}", alt: ["unicode-math"] }, "𝝆": { math: "\\mathbit{\\rho}", alt: ["unicode-math"] }, "𝝇": { math: "\\mathbit{\\varsigma}", alt: ["unicode-math"] }, "𝝈": { math: "\\mathbit{\\sigma}", alt: ["unicode-math"] }, "𝝉": { math: "\\mathbit{\\tau}", alt: ["unicode-math"] }, "𝝊": { math: "\\mathbit{\\upsilon}", alt: ["unicode-math"] }, "𝝋": { math: "\\mathbit{\\varphi}", alt: ["unicode-math"] }, "𝝌": { math: "\\mathbit{\\chi}", alt: ["unicode-math"] }, "𝝍": { math: "\\mathbit{\\psi}", alt: ["unicode-math"] }, "𝝎": { math: "\\mathbit{\\omega}", alt: ["unicode-math"] }, "𝝏": { math: "\\partial", alt: ["unicode-math"] }, "𝝐": { math: "\\in", alt: ["unicode-math"] }, "𝝑": { math: "\\mathbit{\\vartheta}", alt: ["unicode-math"] }, "𝝒": { math: "\\mathbit{\\varkappa}", alt: ["unicode-math"] }, "𝝓": { math: "\\mathbit{\\phi}", alt: ["unicode-math"] }, "𝝔": { math: "\\mathbit{\\varrho}", alt: ["unicode-math"] }, "𝝕": { math: "\\mathbit{\\varpi}", alt: ["unicode-math"] }, "𝝖": { math: "\\mathsfbf{A}", alt: ["unicode-math"] }, "𝝗": { math: "\\mathsfbf{B}", alt: ["unicode-math"] }, "𝝘": { math: "\\mathsfbf{\\Gamma}", alt: ["unicode-math"] }, "𝝙": { math: "\\mathsfbf{\\Delta}", alt: ["unicode-math"] }, "𝝚": { math: "\\mathsfbf{E}", alt: ["unicode-math"] }, "𝝛": { math: "\\mathsfbf{Z}", alt: ["unicode-math"] }, "𝝜": { math: "\\mathsfbf{H}", alt: ["unicode-math"] }, "𝝝": { math: "\\mathsfbf{\\Theta}", alt: ["unicode-math"] }, "𝝞": { math: "\\mathsfbf{I}", alt: ["unicode-math"] }, "𝝟": { math: "\\mathsfbf{K}", alt: ["unicode-math"] }, "𝝠": { math: "\\mathsfbf{\\Lambda}", alt: ["unicode-math"] }, "𝝡": { math: "M", alt: ["unicode-math"] }, "𝝢": { math: "N", alt: ["unicode-math"] }, "𝝣": { math: "\\mathsfbf{\\Xi}", alt: ["unicode-math"] }, "𝝤": { math: "O", alt: ["unicode-math"] }, "𝝥": { math: "\\mathsfbf{\\Pi}", alt: ["unicode-math"] }, "𝝦": { math: "\\mathsfbf{P}", alt: ["unicode-math"] }, "𝝧": { math: "\\mathsfbf{\\Theta}", alt: ["unicode-math"] }, "𝝨": { math: "\\mathsfbf{\\Sigma}", alt: ["unicode-math"] }, "𝝩": { math: "\\mathsfbf{T}", alt: ["unicode-math"] }, "𝝪": { math: "\\mathsfbf{\\Upsilon}", alt: ["unicode-math"] }, "𝝫": { math: "\\mathsfbf{\\Phi}", alt: ["unicode-math"] }, "𝝬": { math: "\\mathsfbf{X}", alt: ["unicode-math"] }, "𝝭": { math: "\\mathsfbf{\\Psi}", alt: ["unicode-math"] }, "𝝮": { math: "\\mathsfbf{\\Omega}", alt: ["unicode-math"] }, "𝝯": { math: "\\mathsfbf{\\nabla}", alt: ["unicode-math"] }, "𝝰": { math: "\\mathsfbf{\\alpha}", alt: ["unicode-math"] }, "𝝱": { math: "\\mathsfbf{\\beta}", alt: ["unicode-math"] }, "𝝲": { math: "\\mathsfbf{\\gamma}", alt: ["unicode-math"] }, "𝝳": { math: "\\mathsfbf{\\delta}", alt: ["unicode-math"] }, "𝝴": { math: "\\mathsfbf{\\varepsilon}", alt: ["unicode-math"] }, "𝝵": { math: "\\mathsfbf{\\zeta}", alt: ["unicode-math"] }, "𝝶": { math: "\\mathsfbf{\\eta}", alt: ["unicode-math"] }, "𝝷": { math: "\\mathsfbf{\\theta}", alt: ["unicode-math"] }, "𝝸": { math: "\\mathsfbf{\\imath}", alt: ["unicode-math"] }, "𝝹": { math: "\\mathsfbf{\\kappa}", alt: ["unicode-math"] }, "𝝺": { math: "\\mathsfbf{\\lambda}", alt: ["unicode-math"] }, "𝝻": { math: "\\mu", alt: ["unicode-math"] }, "𝝼": { math: "\\nu", alt: ["unicode-math"] }, "𝝽": { math: "\\mathsfbf{\\xi}", alt: ["unicode-math"] }, "𝝾": { math: "o", alt: ["unicode-math"] }, "𝝿": { math: "\\mathsfbf{\\pi}", alt: ["unicode-math"] }, "𝞀": { math: "\\mathsfbf{\\rho}", alt: ["unicode-math"] }, "𝞁": { math: "\\mathsfbf{\\varsigma}", alt: ["unicode-math"] }, "𝞂": { math: "\\mathsfbf{\\sigma}", alt: ["unicode-math"] }, "𝞃": { math: "\\mathsfbf{\\tau}", alt: ["unicode-math"] }, "𝞄": { math: "\\mathsfbf{\\upsilon}", alt: ["unicode-math"] }, "𝞅": { math: "\\mathsfbf{\\varphi}", alt: ["unicode-math"] }, "𝞆": { math: "\\mathsfbf{\\chi}", alt: ["unicode-math"] }, "𝞇": { math: "\\mathsfbf{\\psi}", alt: ["unicode-math"] }, "𝞈": { math: "\\mathsfbf{\\omega}", alt: ["unicode-math"] }, "𝞉": { math: "\\partial", alt: ["unicode-math"] }, "𝞊": { math: "\\in", alt: ["unicode-math"] }, "𝞋": { math: "\\mathsfbf{\\vartheta}", alt: ["unicode-math"] }, "𝞌": { math: "\\mathsfbf{\\varkappa}", alt: ["unicode-math"] }, "𝞍": { math: "\\mathsfbf{\\phi}", alt: ["unicode-math"] }, "𝞎": { math: "\\mathsfbf{\\varrho}", alt: ["unicode-math"] }, "𝞏": { math: "\\mathsfbf{\\varpi}", alt: ["unicode-math"] }, "𝞐": { math: "\\mathsfbfsl{A}", alt: ["unicode-math"] }, "𝞑": { math: "\\mathsfbfsl{B}", alt: ["unicode-math"] }, "𝞒": { math: "\\mathsfbfsl{\\Gamma}", alt: ["unicode-math"] }, "𝞓": { math: "\\mathsfbfsl{\\Delta}", alt: ["unicode-math"] }, "𝞔": { math: "\\mathsfbfsl{E}", alt: ["unicode-math"] }, "𝞕": { math: "\\mathsfbfsl{Z}", alt: ["unicode-math"] }, "𝞖": { math: "\\mathsfbfsl{H}", alt: ["unicode-math"] }, "𝞗": { math: "\\mathsfbfsl{\\Theta}", alt: ["unicode-math"] }, "𝞘": { math: "\\mathsfbfsl{I}", alt: ["unicode-math"] }, "𝞙": { math: "\\mathsfbfsl{K}", alt: ["unicode-math"] }, "𝞚": { math: "\\mathsfbfsl{\\Lambda}", alt: ["unicode-math"] }, "𝞛": { math: "\\mathsfbfsl{M}", alt: ["unicode-math"] }, "𝞜": { math: "\\mathsfbfsl{N}", alt: ["unicode-math"] }, "𝞝": { math: "\\mathsfbfsl{\\Xi}", alt: ["unicode-math"] }, "𝞞": { math: "\\mathsfbfsl{O}", alt: ["unicode-math"] }, "𝞟": { math: "\\mathsfbfsl{\\Pi}", alt: ["unicode-math"] }, "𝞠": { math: "\\mathsfbfsl{P}", alt: ["unicode-math"] }, "𝞡": { math: "\\mathsfbfsl{\\Theta}", alt: ["unicode-math"] }, "𝞢": { math: "\\mathsfbfsl{\\Sigma}", alt: ["unicode-math"] }, "𝞣": { math: "\\mathsfbfsl{T}", alt: ["unicode-math"] }, "𝞤": { math: "\\mathsfbfsl{\\Upsilon}", alt: ["unicode-math"] }, "𝞥": { math: "\\mathsfbfsl{\\Phi}", alt: ["unicode-math"] }, "𝞦": { math: "\\mathsfbfsl{X}", alt: ["unicode-math"] }, "𝞧": { math: "\\mathsfbfsl{\\Psi}", alt: ["unicode-math"] }, "𝞨": { math: "\\mathsfbfsl{\\Omega}", alt: ["unicode-math"] }, "𝞩": { math: "\\mathsfbfsl{\\nabla}", alt: ["unicode-math"] }, "𝞪": { math: "\\mathsfbfsl{\\alpha}", alt: ["unicode-math"] }, "𝞫": { math: "\\mathsfbfsl{\\beta}", alt: ["unicode-math"] }, "𝞬": { math: "\\mathsfbfsl{\\gamma}", alt: ["unicode-math"] }, "𝞭": { math: "\\mathsfbfsl{\\delta}", alt: ["unicode-math"] }, "𝞮": { math: "\\mathsfbfsl{\\varepsilon}", alt: ["unicode-math"] }, "𝞯": { math: "\\mathsfbfsl{\\zeta}", alt: ["unicode-math"] }, "𝞰": { math: "\\mathsfbfsl{\\eta}", alt: ["unicode-math"] }, "𝞱": { math: "\\mathsfbfsl{\\theta}", alt: ["unicode-math"] }, "𝞲": { math: "\\mathsfbfsl{\\imath}", alt: ["unicode-math"] }, "𝞳": { math: "\\mathsfbfsl{\\kappa}", alt: ["unicode-math"] }, "𝞴": { math: "\\mathsfbfsl{\\lambda}", alt: ["unicode-math"] }, "𝞵": { math: "\\mu", alt: ["unicode-math"] }, "𝞶": { math: "\\nu", alt: ["unicode-math"] }, "𝞷": { math: "\\mathsfbfsl{\\xi}", alt: ["unicode-math"] }, "𝞸": { math: "o", alt: ["unicode-math"] }, "𝞹": { math: "\\mathsfbfsl{\\pi}", alt: ["unicode-math"] }, "𝞺": { math: "\\mathsfbfsl{\\rho}", alt: ["unicode-math"] }, "𝞻": { math: "\\mathsfbfsl{\\varsigma}", alt: ["unicode-math"] }, "𝞼": { math: "\\mathsfbfsl{\\sigma}", alt: ["unicode-math"] }, "𝞽": { math: "\\mathsfbfsl{\\tau}", alt: ["unicode-math"] }, "𝞾": { math: "\\mathsfbfsl{\\upsilon}", alt: ["unicode-math"] }, "𝞿": { math: "\\mathsfbfsl{\\varphi}", alt: ["unicode-math"] }, "𝟀": { math: "\\mathsfbfsl{\\chi}", alt: ["unicode-math"] }, "𝟁": { math: "\\mathsfbfsl{\\psi}", alt: ["unicode-math"] }, "𝟂": { math: "\\mathsfbfsl{\\omega}", alt: ["unicode-math"] }, "𝟃": { math: "\\partial", alt: ["unicode-math"] }, "𝟄": { math: "\\in", alt: ["unicode-math"] }, "𝟅": { math: "\\mathsfbfsl{\\vartheta}", alt: ["unicode-math"] }, "𝟆": { math: "\\mathsfbfsl{\\varkappa}", alt: ["unicode-math"] }, "𝟇": { math: "\\mathsfbfsl{\\phi}", alt: ["unicode-math"] }, "𝟈": { math: "\\mathsfbfsl{\\varrho}", alt: ["unicode-math"] }, "𝟉": { math: "\\mathsfbfsl{\\varpi}", alt: ["unicode-math"] }, "𝟊": { math: "\\mbfDigamma", alt: ["unicode-math"] }, "𝟋": { math: "\\mbfdigamma", alt: ["unicode-math"] }, "𝟎": { math: "\\mathbf{0}", alt: ["unicode-math"] }, "𝟏": { math: "\\mathbf{1}", alt: ["unicode-math"] }, "𝟐": { math: "\\mathbf{2}", alt: ["unicode-math"] }, "𝟑": { math: "\\mathbf{3}", alt: ["unicode-math"] }, "𝟒": { math: "\\mathbf{4}", alt: ["unicode-math"] }, "𝟓": { math: "\\mathbf{5}", alt: ["unicode-math"] }, "𝟔": { math: "\\mathbf{6}", alt: ["unicode-math"] }, "𝟕": { math: "\\mathbf{7}", alt: ["unicode-math"] }, "𝟖": { math: "\\mathbf{8}", alt: ["unicode-math"] }, "𝟗": { math: "\\mathbf{9}", alt: ["unicode-math"] }, "𝟘": { math: "\\mathbb{0}", alt: ["unicode-math"] }, "𝟙": { math: "\\mathbb{1}", alt: ["unicode-math"] }, "𝟚": { math: "\\mathbb{2}", alt: ["unicode-math"] }, "𝟛": { math: "\\mathbb{3}", alt: ["unicode-math"] }, "𝟜": { math: "\\mathbb{4}", alt: ["unicode-math"] }, "𝟝": { math: "\\mathbb{5}", alt: ["unicode-math"] }, "𝟞": { math: "\\mathbb{6}", alt: ["unicode-math"] }, "𝟟": { math: "\\mathbb{7}", alt: ["unicode-math"] }, "𝟠": { math: "\\mathbb{8}", alt: ["unicode-math"] }, "𝟡": { math: "\\mathbb{9}", alt: ["unicode-math"] }, "𝟢": { math: "\\mathsf{0}", alt: ["unicode-math"] }, "𝟣": { math: "\\mathsf{1}", alt: ["unicode-math"] }, "𝟤": { math: "\\mathsf{2}", alt: ["unicode-math"] }, "𝟥": { math: "\\mathsf{3}", alt: ["unicode-math"] }, "𝟦": { math: "\\mathsf{4}", alt: ["unicode-math"] }, "𝟧": { math: "\\mathsf{5}", alt: ["unicode-math"] }, "𝟨": { math: "\\mathsf{6}", alt: ["unicode-math"] }, "𝟩": { math: "\\mathsf{7}", alt: ["unicode-math"] }, "𝟪": { math: "\\mathsf{8}", alt: ["unicode-math"] }, "𝟫": { math: "\\mathsf{9}", alt: ["unicode-math"] }, "𝟬": { math: "\\mathsfbf{0}", alt: ["unicode-math"] }, "𝟭": { math: "\\mathsfbf{1}", alt: ["unicode-math"] }, "𝟮": { math: "\\mathsfbf{2}", alt: ["unicode-math"] }, "𝟯": { math: "\\mathsfbf{3}", alt: ["unicode-math"] }, "𝟰": { math: "\\mathsfbf{4}", alt: ["unicode-math"] }, "𝟱": { math: "\\mathsfbf{5}", alt: ["unicode-math"] }, "𝟲": { math: "\\mathsfbf{6}", alt: ["unicode-math"] }, "𝟳": { math: "\\mathsfbf{7}", alt: ["unicode-math"] }, "𝟴": { math: "\\mathsfbf{8}", alt: ["unicode-math"] }, "𝟵": { math: "\\mathsfbf{9}", alt: ["unicode-math"] }, "𝟶": { math: "\\mathtt{0}", alt: ["unicode-math"] }, "𝟷": { math: "\\mathtt{1}", alt: ["unicode-math"] }, "𝟸": { math: "\\mathtt{2}", alt: ["unicode-math"] }, "𝟹": { math: "\\mathtt{3}", alt: ["unicode-math"] }, "𝟺": { math: "\\mathtt{4}", alt: ["unicode-math"] }, "𝟻": { math: "\\mathtt{5}", alt: ["unicode-math"] }, "𝟼": { math: "\\mathtt{6}", alt: ["unicode-math"] }, "𝟽": { math: "\\mathtt{7}", alt: ["unicode-math"] }, "𝟾": { math: "\\mathtt{8}", alt: ["unicode-math"] }, "𝟿": { math: "\\mathtt{9}", alt: ["unicode-math"] }, " ͚": { math: "_\\infty" }, "\u2029": { text: "\\par", macrospacer: true }, "/​": { text: "\\slash", macrospacer: true }, "^": { text: "\\textasciicircum", macrospacer: true }, i︠a︡: { text: "\\t{ia}" }, "{": { text: "\\{" }, "}": { text: "\\}" }, "~": { text: "\\textasciitilde", macrospacer: true }, "¡": { text: "\\textexclamdown", macrospacer: true }, "€": { text: "\\texteuro", macrospacer: true, alt: ["unicode-math"] }, "¨": { text: "\\textasciidieresis", macrospacer: true }, "«": { text: "<<" }, "®": { text: "\\textregistered", macrospacer: true }, "¯": { text: "\\textasciimacron", macrospacer: true }, "´": { text: "\\textasciiacute", macrospacer: true }, µ: { text: "\\textmu", macrospacer: true }, "¸": { text: "\\c", macrospacer: true }, "»": { text: ">>" }, "¿": { text: "\\textquestiondown", macrospacer: true }, Æ: { text: "\\AE", macrospacer: true }, Ð: { text: "\\DH", macrospacer: true }, Ø: { text: "\\O", macrospacer: true }, Þ: { text: "\\TH", macrospacer: true }, ß: { text: "\\ss", macrospacer: true }, å: { text: "\\aa", macrospacer: true }, æ: { text: "\\ae", macrospacer: true }, ð: { text: "\\dh", macrospacer: true, alt: ["amssymb", "arevmath", "textcomp"] }, ø: { text: "\\o", macrospacer: true }, þ: { text: "\\th", macrospacer: true }, Đ: { text: "\\DJ", macrospacer: true }, đ: { text: "\\dj", macrospacer: true }, ĭ: { text: "{\\u \\i}" }, Ĳ: { text: "\\IJ", macrospacer: true }, ĳ: { text: "\\ij", macrospacer: true }, ĵ: { text: "\\^\\j", macrospacer: true }, ĸ: { text: "K", alt: ["xecjk"] }, Ł: { text: "\\L", macrospacer: true }, ł: { text: "\\l", macrospacer: true }, ŉ: { text: "'n" }, Ŋ: { text: "\\NG", macrospacer: true }, ŋ: { text: "\\ng", macrospacer: true }, Œ: { text: "\\OE", macrospacer: true }, œ: { text: "\\oe", macrospacer: true }, ſ: { text: "s" }, ƪ: { text: "\\textesh", macrospacer: true }, ǂ: { text: "\\textdoublepipe", macrospacer: true, alt: ["tipa"] }, ɡ: { text: "g" }, "ʹ": { text: "'" }, ʻ: { text: "'" }, ʼ: { text: "'" }, ʽ: { text: "'" }, "ˆ": { text: "\\textasciicircum", macrospacer: true }, "ˇ": { text: "\\textasciicaron", macrospacer: true }, "ˉ": { text: "-" }, "˘": { text: "\\textasciibreve", macrospacer: true }, "˚": { text: "\\r{}" }, "˛": { text: "\\k{}" }, "˜": { text: "\\texttildelow", macrospacer: true }, "˝": { text: "\\textacutedbl", macrospacer: true }, "̀": { text: "\\`", macrospacer: true, alt: ["unicode-math"] }, "́": { text: "\\'", macrospacer: true, alt: ["unicode-math"] }, "̂": { text: "\\^", macrospacer: true }, "̃": { text: "\\~", macrospacer: true, alt: ["unicode-math"] }, "̄": { text: "\\=", macrospacer: true }, "̆": { text: "\\u", macrospacer: true, alt: ["unicode-math"] }, "̇": { text: "\\.", macrospacer: true, alt: ["unicode-math"] }, "̈": { text: '\\"', macrospacer: true, alt: ["unicode-math"] }, "̋": { text: "\\H", macrospacer: true }, "̌": { text: "\\v", macrospacer: true, alt: ["unicode-math"] }, "̏": { text: "\\textdoublegrave", macrospacer: true }, "̖": { text: "\\textsubgrave", macrospacer: true }, "̣": { text: "\\d", macrospacer: true }, "̦": { text: "\\textcommabelow", macrospacer: true }, "̧": { text: "\\c", macrospacer: true }, "̨": { text: "\\k", macrospacer: true }, "͵": { text: "," }, ";": { text: ";" }, Ί: { text: "{\\'{}I}" }, Ό: { text: "{\\'{}O}" }, ϐ: { text: "\\Pisymbol{ppi022}{87}", alt: ["MinionPro", "unicode-math"] }, ѫ: { text: "\\cyrchar\\cyrbyus", macrospacer: true }, ѳ: { text: "\\cyrchar\\cyrfita", macrospacer: true }, ѵ: { text: "\\cyrchar\\cyrizh", macrospacer: true }, "Ӆ": { text: "\\cyrchar\\CYRLDSC", macrospacer: true }, "ӆ": { text: "\\cyrchar\\cyrldsc", macrospacer: true }, "Ӎ": { text: "\\cyrchar\\CYRMDSC", macrospacer: true }, "ӎ": { text: "\\cyrchar\\cyrmdsc", macrospacer: true }, ѣ: { text: "\\cyrchar\\cyryat", macrospacer: true }, Ё: { text: "\\cyrchar\\CYRYO", macrospacer: true }, Ђ: { text: "\\cyrchar\\CYRDJE", macrospacer: true }, Ѓ: { text: "\\cyrchar{\\'\\CYRG}" }, Є: { text: "\\cyrchar\\CYRIE", macrospacer: true }, Ѕ: { text: "\\cyrchar\\CYRDZE", macrospacer: true }, І: { text: "\\cyrchar\\CYRII", macrospacer: true }, Ї: { text: "\\cyrchar\\CYRYI", macrospacer: true }, Ј: { text: "\\cyrchar\\CYRJE", macrospacer: true }, Љ: { text: "\\cyrchar\\CYRLJE", macrospacer: true }, Њ: { text: "\\cyrchar\\CYRNJE", macrospacer: true }, Ћ: { text: "\\cyrchar\\CYRTSHE", macrospacer: true }, Ќ: { text: "\\cyrchar{\\'\\CYRK}" }, Ў: { text: "\\cyrchar\\CYRUSHRT", macrospacer: true }, Џ: { text: "\\cyrchar\\CYRDZHE", macrospacer: true }, А: { text: "\\cyrchar\\CYRA", macrospacer: true }, Б: { text: "\\cyrchar\\CYRB", macrospacer: true }, В: { text: "\\cyrchar\\CYRV", macrospacer: true }, Г: { text: "\\cyrchar\\CYRG", macrospacer: true }, Д: { text: "\\cyrchar\\CYRD", macrospacer: true }, Е: { text: "\\cyrchar\\CYRE", macrospacer: true }, Ж: { text: "\\cyrchar\\CYRZH", macrospacer: true }, З: { text: "\\cyrchar\\CYRZ", macrospacer: true }, И: { text: "\\cyrchar\\CYRI", macrospacer: true }, Й: { text: "\\cyrchar\\CYRISHRT", macrospacer: true }, К: { text: "\\cyrchar\\CYRK", macrospacer: true }, Л: { text: "\\cyrchar\\CYRL", macrospacer: true }, М: { text: "\\cyrchar\\CYRM", macrospacer: true }, Н: { text: "\\cyrchar\\CYRN", macrospacer: true }, О: { text: "\\cyrchar\\CYRO", macrospacer: true }, П: { text: "\\cyrchar\\CYRP", macrospacer: true }, Р: { text: "\\cyrchar\\CYRR", macrospacer: true }, С: { text: "\\cyrchar\\CYRS", macrospacer: true }, Т: { text: "\\cyrchar\\CYRT", macrospacer: true }, У: { text: "\\cyrchar\\CYRU", macrospacer: true }, Ф: { text: "\\cyrchar\\CYRF", macrospacer: true }, Х: { text: "\\cyrchar\\CYRH", macrospacer: true }, Ц: { text: "\\cyrchar\\CYRC", macrospacer: true }, Ч: { text: "\\cyrchar\\CYRCH", macrospacer: true }, Ш: { text: "\\cyrchar\\CYRSH", macrospacer: true }, Щ: { text: "\\cyrchar\\CYRSHCH", macrospacer: true }, Ъ: { text: "\\cyrchar\\CYRHRDSN", macrospacer: true }, Ы: { text: "\\cyrchar\\CYRERY", macrospacer: true }, Ь: { text: "\\cyrchar\\CYRSFTSN", macrospacer: true }, Э: { text: "\\cyrchar\\CYREREV", macrospacer: true }, Ю: { text: "\\cyrchar\\CYRYU", macrospacer: true }, Я: { text: "\\cyrchar\\CYRYA", macrospacer: true }, а: { text: "\\cyrchar\\cyra", macrospacer: true }, б: { text: "\\cyrchar\\cyrb", macrospacer: true }, в: { text: "\\cyrchar\\cyrv", macrospacer: true }, г: { text: "\\cyrchar\\cyrg", macrospacer: true }, д: { text: "\\cyrchar\\cyrd", macrospacer: true }, е: { text: "\\cyrchar\\cyre", macrospacer: true }, ж: { text: "\\cyrchar\\cyrzh", macrospacer: true }, з: { text: "\\cyrchar\\cyrz", macrospacer: true }, и: { text: "\\cyrchar\\cyri", macrospacer: true }, й: { text: "\\cyrchar\\cyrishrt", macrospacer: true }, к: { text: "\\cyrchar\\cyrk", macrospacer: true }, л: { text: "\\cyrchar\\cyrl", macrospacer: true }, м: { text: "\\cyrchar\\cyrm", macrospacer: true }, н: { text: "\\cyrchar\\cyrn", macrospacer: true }, о: { text: "\\cyrchar\\cyro", macrospacer: true }, п: { text: "\\cyrchar\\cyrp", macrospacer: true }, р: { text: "\\cyrchar\\cyrr", macrospacer: true }, с: { text: "\\cyrchar\\cyrs", macrospacer: true }, т: { text: "\\cyrchar\\cyrt", macrospacer: true }, у: { text: "\\cyrchar\\cyru", macrospacer: true }, ф: { text: "\\cyrchar\\cyrf", macrospacer: true }, х: { text: "\\cyrchar\\cyrh", macrospacer: true }, ц: { text: "\\cyrchar\\cyrc", macrospacer: true }, ч: { text: "\\cyrchar\\cyrch", macrospacer: true }, ш: { text: "\\cyrchar\\cyrsh", macrospacer: true }, щ: { text: "\\cyrchar\\cyrshch", macrospacer: true }, ъ: { text: "\\cyrchar\\cyrhrdsn", macrospacer: true }, ы: { text: "\\cyrchar\\cyrery", macrospacer: true }, ь: { text: "\\cyrchar\\cyrsftsn", macrospacer: true }, э: { text: "\\cyrchar\\cyrerev", macrospacer: true }, ю: { text: "\\cyrchar\\cyryu", macrospacer: true }, я: { text: "\\cyrchar\\cyrya", macrospacer: true }, ё: { text: "\\cyrchar\\cyryo", macrospacer: true }, ђ: { text: "\\cyrchar\\cyrdje", macrospacer: true }, ѓ: { text: "\\cyrchar{\\'\\cyrg}" }, є: { text: "\\cyrchar\\cyrie", macrospacer: true }, ѕ: { text: "\\cyrchar\\cyrdze", macrospacer: true }, і: { text: "\\cyrchar\\cyrii", macrospacer: true }, ї: { text: "\\cyrchar\\cyryi", macrospacer: true }, ј: { text: "\\cyrchar\\cyrje", macrospacer: true }, љ: { text: "\\cyrchar\\cyrlje", macrospacer: true }, њ: { text: "\\cyrchar\\cyrnje", macrospacer: true }, ћ: { text: "\\cyrchar\\cyrtshe", macrospacer: true }, ќ: { text: "\\cyrchar{\\'\\cyrk}" }, ў: { text: "\\cyrchar\\cyrushrt", macrospacer: true }, џ: { text: "\\cyrchar\\cyrdzhe", macrospacer: true }, Ѡ: { text: "\\cyrchar\\CYROMEGA", macrospacer: true }, ѡ: { text: "\\cyrchar\\cyromega", macrospacer: true }, Ѣ: { text: "\\cyrchar\\CYRYAT", macrospacer: true }, Ѥ: { text: "\\cyrchar\\CYRIOTE", macrospacer: true }, ѥ: { text: "\\cyrchar\\cyriote", macrospacer: true }, Ѧ: { text: "\\cyrchar\\CYRLYUS", macrospacer: true }, ѧ: { text: "\\cyrchar\\cyrlyus", macrospacer: true }, Ѩ: { text: "\\cyrchar\\CYRIOTLYUS", macrospacer: true }, ѩ: { text: "\\cyrchar\\cyriotlyus", macrospacer: true }, Ѫ: { text: "\\cyrchar\\CYRBYUS", macrospacer: true }, Ѭ: { text: "\\cyrchar\\CYRIOTBYUS", macrospacer: true }, ѭ: { text: "\\cyrchar\\cyriotbyus", macrospacer: true }, Ѯ: { text: "\\cyrchar\\CYRKSI", macrospacer: true }, ѯ: { text: "\\cyrchar\\cyrksi", macrospacer: true }, Ѱ: { text: "\\cyrchar\\CYRPSI", macrospacer: true }, ѱ: { text: "\\cyrchar\\cyrpsi", macrospacer: true }, Ѳ: { text: "\\cyrchar\\CYRFITA", macrospacer: true }, Ѵ: { text: "\\cyrchar\\CYRIZH", macrospacer: true }, Ѹ: { text: "\\cyrchar\\CYRUK", macrospacer: true }, ѹ: { text: "\\cyrchar\\cyruk", macrospacer: true }, Ѻ: { text: "\\cyrchar\\CYROMEGARND", macrospacer: true }, ѻ: { text: "\\cyrchar\\cyromegarnd", macrospacer: true }, Ѽ: { text: "\\cyrchar\\CYROMEGATITLO", macrospacer: true }, ѽ: { text: "\\cyrchar\\cyromegatitlo", macrospacer: true }, Ѿ: { text: "\\cyrchar\\CYROT", macrospacer: true }, ѿ: { text: "\\cyrchar\\cyrot", macrospacer: true }, Ҁ: { text: "\\cyrchar\\CYRKOPPA", macrospacer: true }, ҁ: { text: "\\cyrchar\\cyrkoppa", macrospacer: true }, "҂": { text: "\\cyrchar\\cyrthousands", macrospacer: true }, "҈": { text: "\\cyrchar\\cyrhundredthousands", macrospacer: true }, "҉": { text: "\\cyrchar\\cyrmillions", macrospacer: true }, Ҍ: { text: "\\cyrchar\\CYRSEMISFTSN", macrospacer: true }, ҍ: { text: "\\cyrchar\\cyrsemisftsn", macrospacer: true }, Ҏ: { text: "\\cyrchar\\CYRRTICK", macrospacer: true }, ҏ: { text: "\\cyrchar\\cyrrtick", macrospacer: true }, Ґ: { text: "\\cyrchar\\CYRGUP", macrospacer: true }, ґ: { text: "\\cyrchar\\cyrgup", macrospacer: true }, Ғ: { text: "\\cyrchar\\CYRGHCRS", macrospacer: true }, ғ: { text: "\\cyrchar\\cyrghcrs", macrospacer: true }, Ҕ: { text: "\\cyrchar\\CYRGHK", macrospacer: true }, ҕ: { text: "\\cyrchar\\cyrghk", macrospacer: true }, Җ: { text: "\\cyrchar\\CYRZHDSC", macrospacer: true }, җ: { text: "\\cyrchar\\cyrzhdsc", macrospacer: true }, Ҙ: { text: "\\cyrchar\\CYRZDSC", macrospacer: true }, ҙ: { text: "\\cyrchar\\cyrzdsc", macrospacer: true }, Қ: { text: "\\cyrchar\\CYRKDSC", macrospacer: true }, қ: { text: "\\cyrchar\\cyrkdsc", macrospacer: true }, Ҝ: { text: "\\cyrchar\\CYRKVCRS", macrospacer: true }, ҝ: { text: "\\cyrchar\\cyrkvcrs", macrospacer: true }, Ҟ: { text: "\\cyrchar\\CYRKHCRS", macrospacer: true }, ҟ: { text: "\\cyrchar\\cyrkhcrs", macrospacer: true }, Ҡ: { text: "\\cyrchar\\CYRKBEAK", macrospacer: true }, ҡ: { text: "\\cyrchar\\cyrkbeak", macrospacer: true }, Ң: { text: "\\cyrchar\\CYRNDSC", macrospacer: true }, ң: { text: "\\cyrchar\\cyrndsc", macrospacer: true }, Ҥ: { text: "\\cyrchar\\CYRNG", macrospacer: true }, ҥ: { text: "\\cyrchar\\cyrng", macrospacer: true }, Ҧ: { text: "\\cyrchar\\CYRPHK", macrospacer: true }, ҧ: { text: "\\cyrchar\\cyrphk", macrospacer: true }, Ҩ: { text: "\\cyrchar\\CYRABHHA", macrospacer: true }, ҩ: { text: "\\cyrchar\\cyrabhha", macrospacer: true }, Ҫ: { text: "\\cyrchar\\CYRSDSC", macrospacer: true }, ҫ: { text: "\\cyrchar\\cyrsdsc", macrospacer: true }, Ҭ: { text: "\\cyrchar\\CYRTDSC", macrospacer: true }, ҭ: { text: "\\cyrchar\\cyrtdsc", macrospacer: true }, Ү: { text: "\\cyrchar\\CYRY", macrospacer: true }, ү: { text: "\\cyrchar\\cyry", macrospacer: true }, Ұ: { text: "\\cyrchar\\CYRYHCRS", macrospacer: true }, ұ: { text: "\\cyrchar\\cyryhcrs", macrospacer: true }, Ҳ: { text: "\\cyrchar\\CYRHDSC", macrospacer: true }, ҳ: { text: "\\cyrchar\\cyrhdsc", macrospacer: true }, Ҵ: { text: "\\cyrchar\\CYRTETSE", macrospacer: true }, ҵ: { text: "\\cyrchar\\cyrtetse", macrospacer: true }, Ҷ: { text: "\\cyrchar\\CYRCHRDSC", macrospacer: true }, ҷ: { text: "\\cyrchar\\cyrchrdsc", macrospacer: true }, Ҹ: { text: "\\cyrchar\\CYRCHVCRS", macrospacer: true }, ҹ: { text: "\\cyrchar\\cyrchvcrs", macrospacer: true }, Һ: { text: "\\cyrchar\\CYRSHHA", macrospacer: true }, һ: { text: "\\cyrchar\\cyrshha", macrospacer: true }, Ҽ: { text: "\\cyrchar\\CYRABHCH", macrospacer: true }, ҽ: { text: "\\cyrchar\\cyrabhch", macrospacer: true }, Ҿ: { text: "\\cyrchar\\CYRABHCHDSC", macrospacer: true }, ҿ: { text: "\\cyrchar\\cyrabhchdsc", macrospacer: true }, Ӏ: { text: "\\cyrchar\\CYRpalochka", macrospacer: true }, Ӄ: { text: "\\cyrchar\\CYRKHK", macrospacer: true }, ӄ: { text: "\\cyrchar\\cyrkhk", macrospacer: true }, Ӈ: { text: "\\cyrchar\\CYRNHK", macrospacer: true }, ӈ: { text: "\\cyrchar\\cyrnhk", macrospacer: true }, Ӌ: { text: "\\cyrchar\\CYRCHLDSC", macrospacer: true }, ӌ: { text: "\\cyrchar\\cyrchldsc", macrospacer: true }, Ӕ: { text: "\\cyrchar\\CYRAE", macrospacer: true }, ӕ: { text: "\\cyrchar\\cyrae", macrospacer: true }, Ә: { text: "\\cyrchar\\CYRSCHWA", macrospacer: true }, ә: { text: "\\cyrchar\\cyrschwa", macrospacer: true }, Ӡ: { text: "\\cyrchar\\CYRABHDZE", macrospacer: true }, ӡ: { text: "\\cyrchar\\cyrabhdze", macrospacer: true }, Ө: { text: "\\cyrchar\\CYROTLD", macrospacer: true }, ө: { text: "\\cyrchar\\cyrotld", macrospacer: true }, Ḝ: { text: "\\c{\\u{E}}" }, ḝ: { text: "\\c{\\u{e}}" }, " ": { text: "\\enspace", macrospacer: true }, "  ": { text: "\\qquad", macrospacer: true }, " ": { text: "\\;" }, " ": { text: "\\>" }, " ": { text: "\\hspace{0.166em}" }, " ": { text: "\\hphantom{0}" }, " ": { text: "\\hphantom{,}" }, " ": { text: "\\," }, "​": { text: "\\hspace{0pt}" }, "‌": { text: "\\null", macrospacer: true }, "‐": { text: "-", alt: ["unicode-math"] }, "‑": { text: "-" }, "‒": { text: "-" }, "–": { text: "--" }, "—": { text: "---" }, "―": { text: "\\texthorizontalbar", macrospacer: true, alt: ["unicode-math"] }, "‖": { text: "\\textbardbl", macrospacer: true }, "‘": { text: "`" }, "’": { text: "'" }, "‚": { text: "\\quotesinglbase", macrospacer: true }, "“": { text: "``" }, "”": { text: "''" }, "„": { text: ",," }, "‟": { text: "\\quotedblbase", macrospacer: true }, "‣": { text: ">" }, "․": { text: "." }, "‥": { text: "..", alt: ["unicode-math"] }, "‧": { text: "-" }, " ": { text: "\\," }, "‹": { text: "\\guilsinglleft", macrospacer: true }, "›": { text: "\\guilsinglright", macrospacer: true }, "‾": { text: "-" }, "⁄": { text: "\\textfractionsolidus", macrospacer: true, alt: ["unicode-math"] }, "⁈": { text: "?!" }, "⁉": { text: "!?" }, "⁊": { text: "7" }, "⁠": { text: "\\nolinebreak", macrospacer: true }, "℀": { text: "a/c" }, "℁": { text: "a/s" }, "℃": { text: "\\textcelsius", macrospacer: true }, "℅": { text: "c/o" }, "℆": { text: "c/u" }, "℉": { text: "F" }, "№": { text: "\\textnumero", macrospacer: true }, "℗": { text: "\\textcircledP", macrospacer: true }, "℠": { text: "\\textservicemark", macrospacer: true }, "℡": { text: "TEL" }, "℧": { text: "\\textmho", macrospacer: true, alt: ["unicode-math"] }, "℩": { text: "\\textriota", macrospacer: true, alt: ["unicode-math"] }, "℮": { text: "\\textestimated", macrospacer: true }, "Ⅰ": { text: "I" }, "Ⅱ": { text: "II" }, "Ⅲ": { text: "III" }, "Ⅳ": { text: "IV" }, "Ⅴ": { text: "V" }, "Ⅵ": { text: "VI" }, "Ⅶ": { text: "VII" }, "Ⅷ": { text: "VIII" }, "Ⅸ": { text: "IX" }, "Ⅹ": { text: "X" }, "Ⅺ": { text: "XI" }, "Ⅻ": { text: "XII" }, "Ⅼ": { text: "L" }, "Ⅽ": { text: "C" }, "Ⅾ": { text: "D" }, "Ⅿ": { text: "M" }, "ⅰ": { text: "i" }, "ⅱ": { text: "ii" }, "ⅲ": { text: "iii" }, "ⅳ": { text: "iv" }, "ⅴ": { text: "v" }, "ⅵ": { text: "vi" }, "ⅶ": { text: "vii" }, "ⅷ": { text: "viii" }, "ⅸ": { text: "ix" }, "ⅹ": { text: "x" }, "ⅺ": { text: "xi" }, "ⅻ": { text: "xii" }, "ⅼ": { text: "l" }, "ⅽ": { text: "c" }, "ⅾ": { text: "d" }, "ⅿ": { text: "m" }, "∕": { text: "/", alt: ["unicode-math"] }, "√": { text: "\\textsurd", macrospacer: true, alt: ["unicode-math"] }, "␢": { text: "\\textblank", macrospacer: true, alt: ["unicode-math"] }, "①": { text: "\\ding{172}" }, "②": { text: "\\ding{173}" }, "③": { text: "\\ding{174}" }, "④": { text: "\\ding{175}" }, "⑤": { text: "\\ding{176}" }, "⑥": { text: "\\ding{177}" }, "⑦": { text: "\\ding{178}" }, "⑧": { text: "\\ding{179}" }, "⑨": { text: "\\ding{180}" }, "⑩": { text: "\\ding{181}" }, "⑪": { text: "(11)" }, "⑫": { text: "(12)" }, "⑬": { text: "(13)" }, "⑭": { text: "(14)" }, "⑮": { text: "(15)" }, "⑯": { text: "(16)" }, "⑰": { text: "(17)" }, "⑱": { text: "(18)" }, "⑲": { text: "(19)" }, "⑳": { text: "(20)" }, "⑴": { text: "(1)" }, "⑵": { text: "(2)" }, "⑶": { text: "(3)" }, "⑷": { text: "(4)" }, "⑸": { text: "(5)" }, "⑹": { text: "(6)" }, "⑺": { text: "(7)" }, "⑻": { text: "(8)" }, "⑼": { text: "(9)" }, "⑽": { text: "(10)" }, "⑾": { text: "(11)" }, "⑿": { text: "(12)" }, "⒀": { text: "(13)" }, "⒁": { text: "(14)" }, "⒂": { text: "(15)" }, "⒃": { text: "(16)" }, "⒄": { text: "(17)" }, "⒅": { text: "(18)" }, "⒆": { text: "(19)" }, "⒇": { text: "(20)" }, "⒈": { text: "1." }, "⒉": { text: "2." }, "⒊": { text: "3." }, "⒋": { text: "4." }, "⒌": { text: "5." }, "⒍": { text: "6." }, "⒎": { text: "7." }, "⒏": { text: "8." }, "⒐": { text: "9." }, "⒑": { text: "10." }, "⒒": { text: "11." }, "⒓": { text: "12." }, "⒔": { text: "13." }, "⒕": { text: "14." }, "⒖": { text: "15." }, "⒗": { text: "16." }, "⒘": { text: "17." }, "⒙": { text: "18." }, "⒚": { text: "19." }, "⒛": { text: "20." }, "⒜": { text: "(a)" }, "⒝": { text: "(b)" }, "⒞": { text: "(c)" }, "⒟": { text: "(d)" }, "⒠": { text: "(e)" }, "⒡": { text: "(f)" }, "⒢": { text: "(g)" }, "⒣": { text: "(h)" }, "⒤": { text: "(i)" }, "⒥": { text: "(j)" }, "⒦": { text: "(k)" }, "⒧": { text: "(l)" }, "⒨": { text: "(m)" }, "⒩": { text: "(n)" }, "⒪": { text: "(o)" }, "⒫": { text: "(p)" }, "⒬": { text: "(q)" }, "⒭": { text: "(r)" }, "⒮": { text: "(s)" }, "⒯": { text: "(t)" }, "⒰": { text: "(u)" }, "⒱": { text: "(v)" }, "⒲": { text: "(w)" }, "⒳": { text: "(x)" }, "⒴": { text: "(y)" }, "⒵": { text: "(z)" }, "─": { text: "-", alt: ["pmboxdraw"] }, "┄": { text: "-" }, "┈": { text: "-" }, "╌": { text: "-" }, "╲": { text: "\\" }, "╳": { text: "X" }, "╼": { text: "-", alt: ["pmboxdraw"] }, "╾": { text: "-", alt: ["pmboxdraw"] }, "■": { text: "\\ding{110}", alt: ["unicode-math"] }, "▲": { text: "\\ding{115}", alt: ["unicode-math"] }, "▼": { text: "\\ding{116}", alt: ["unicode-math"] }, "◗": { text: "\\ding{119}", alt: ["unicode-math"] }, "◦": { text: "\\textopenbullet", macrospacer: true, alt: ["unicode-math"] }, "★": { text: "\\ding{72}", alt: ["unicode-math"] }, "☆": { text: "\\ding{73}", alt: ["unicode-math"] }, "☎": { text: "\\ding{37}" }, "☓": { text: "X" }, "☛": { text: "\\ding{42}" }, "♀": { text: "\\venus", macrospacer: true, alt: ["unicode-math"] }, "♥": { text: "\\ding{170}", alt: ["unicode-math"] }, "♦": { text: "\\ding{169}", alt: ["unicode-math"] }, "♪": { text: "\\textmusicalnote", macrospacer: true, alt: ["unicode-math"] }, "✁": { text: "\\ding{33}" }, "✂": { text: "\\ding{34}" }, "✃": { text: "\\ding{35}" }, "✄": { text: "\\ding{36}" }, "✆": { text: "\\ding{38}" }, "✇": { text: "\\ding{39}" }, "✈": { text: "\\ding{40}" }, "✉": { text: "\\ding{41}" }, "✌": { text: "\\ding{44}" }, "✍": { text: "\\ding{45}" }, "✏": { text: "\\ding{47}" }, "✐": { text: "\\ding{48}" }, "✑": { text: "\\ding{49}" }, "✒": { text: "\\ding{50}" }, "✓": { text: "\\ding{51}", alt: ["unicode-math"] }, "✔": { text: "\\ding{52}" }, "✕": { text: "\\ding{53}" }, "✖": { text: "\\ding{54}" }, "✘": { text: "\\ding{56}" }, "✙": { text: "\\ding{57}" }, "✚": { text: "\\ding{58}" }, "✛": { text: "\\ding{59}" }, "✜": { text: "\\ding{60}" }, "✝": { text: "\\ding{61}" }, "✞": { text: "\\ding{62}" }, "✟": { text: "\\ding{63}" }, "✠": { text: "\\ding{64}", alt: ["unicode-math"] }, "✡": { text: "\\ding{65}" }, "✢": { text: "\\ding{66}" }, "✣": { text: "\\ding{67}" }, "✤": { text: "\\ding{68}" }, "✥": { text: "\\ding{69}" }, "✦": { text: "\\ding{70}" }, "✧": { text: "\\ding{71}" }, "✩": { text: "\\ding{73}" }, "✪": { text: "\\ding{74}", alt: ["unicode-math"] }, "✫": { text: "\\ding{75}" }, "✬": { text: "\\ding{76}" }, "✭": { text: "\\ding{77}" }, "✮": { text: "\\ding{78}" }, "✯": { text: "\\ding{79}" }, "✰": { text: "\\ding{80}" }, "✱": { text: "\\ding{81}" }, "✲": { text: "\\ding{82}" }, "✳": { text: "\\ding{83}" }, "✴": { text: "\\ding{84}" }, "✵": { text: "\\ding{85}" }, "✶": { text: "\\ding{86}", alt: ["unicode-math"] }, "✷": { text: "\\ding{87}" }, "✸": { text: "\\ding{88}" }, "✹": { text: "\\ding{89}" }, "✺": { text: "\\ding{90}" }, "✻": { text: "\\ding{91}" }, "✼": { text: "\\ding{92}" }, "✽": { text: "\\ding{93}", alt: ["unicode-math"] }, "✾": { text: "\\ding{94}" }, "✿": { text: "\\ding{95}" }, "❀": { text: "\\ding{96}" }, "❁": { text: "\\ding{97}" }, "❂": { text: "\\ding{98}" }, "❃": { text: "\\ding{99}" }, "❄": { text: "\\ding{100}" }, "❅": { text: "\\ding{101}" }, "❆": { text: "\\ding{102}" }, "❇": { text: "\\ding{103}" }, "❈": { text: "\\ding{104}" }, "❉": { text: "\\ding{105}" }, "❊": { text: "\\ding{106}" }, "❋": { text: "\\ding{107}" }, "❍": { text: "\\ding{109}" }, "❏": { text: "\\ding{111}" }, "❐": { text: "\\ding{112}" }, "❑": { text: "\\ding{113}" }, "❒": { text: "\\ding{114}" }, "❖": { text: "\\ding{118}" }, "❘": { text: "\\ding{120}" }, "❙": { text: "\\ding{121}" }, "❚": { text: "\\ding{122}" }, "❛": { text: "\\ding{123}" }, "❜": { text: "\\ding{124}" }, "❝": { text: "\\ding{125}" }, "❞": { text: "\\ding{126}" }, "❡": { text: "\\ding{161}" }, "❢": { text: "\\ding{162}" }, "❣": { text: "\\ding{163}" }, "❤": { text: "\\ding{164}" }, "❥": { text: "\\ding{165}" }, "❦": { text: "\\ding{166}" }, "❧": { text: "\\ding{167}" }, "❶": { text: "\\ding{182}" }, "❷": { text: "\\ding{183}" }, "❸": { text: "\\ding{184}" }, "❹": { text: "\\ding{185}" }, "❺": { text: "\\ding{186}" }, "❻": { text: "\\ding{187}" }, "❼": { text: "\\ding{188}" }, "❽": { text: "\\ding{189}" }, "❾": { text: "\\ding{190}" }, "❿": { text: "\\ding{191}" }, "➀": { text: "\\ding{192}" }, "➁": { text: "\\ding{193}" }, "➂": { text: "\\ding{194}" }, "➃": { text: "\\ding{195}" }, "➄": { text: "\\ding{196}" }, "➅": { text: "\\ding{197}" }, "➆": { text: "\\ding{198}" }, "➇": { text: "\\ding{199}" }, "➈": { text: "\\ding{200}" }, "➉": { text: "\\ding{201}" }, "➊": { text: "\\ding{202}" }, "➋": { text: "\\ding{203}" }, "➌": { text: "\\ding{204}" }, "➍": { text: "\\ding{205}" }, "➎": { text: "\\ding{206}" }, "➏": { text: "\\ding{207}" }, "➐": { text: "\\ding{208}" }, "➑": { text: "\\ding{209}" }, "➒": { text: "\\ding{210}" }, "➓": { text: "\\ding{211}" }, "➔": { text: "\\ding{212}" }, "➘": { text: "\\ding{216}" }, "➙": { text: "\\ding{217}" }, "➚": { text: "\\ding{218}" }, "➛": { text: "\\ding{219}", alt: ["unicode-math"] }, "➜": { text: "\\ding{220}" }, "➝": { text: "\\ding{221}" }, "➞": { text: "\\ding{222}" }, "➟": { text: "\\ding{223}" }, "➠": { text: "\\ding{224}" }, "➡": { text: "\\ding{225}" }, "➣": { text: "\\ding{227}" }, "➤": { text: "\\ding{228}" }, "➥": { text: "\\ding{229}" }, "➦": { text: "\\ding{230}" }, "➧": { text: "\\ding{231}" }, "➨": { text: "\\ding{232}" }, "➩": { text: "\\ding{233}" }, "➪": { text: "\\ding{234}" }, "➫": { text: "\\ding{235}" }, "➬": { text: "\\ding{236}" }, "➭": { text: "\\ding{237}" }, "➮": { text: "\\ding{238}" }, "➯": { text: "\\ding{239}" }, "➱": { text: "\\ding{241}" }, "➲": { text: "\\ding{242}" }, "➳": { text: "\\ding{243}" }, "➴": { text: "\\ding{244}" }, "➵": { text: "\\ding{245}" }, "➶": { text: "\\ding{246}" }, "➷": { text: "\\ding{247}" }, "➸": { text: "\\ding{248}" }, "➹": { text: "\\ding{249}" }, "➺": { text: "\\ding{250}" }, "➻": { text: "\\ding{251}" }, "➼": { text: "\\ding{252}" }, "➽": { text: "\\ding{253}" }, "➾": { text: "\\ding{254}" }, ﬀ: { text: "ff" }, ﬁ: { text: "fi" }, ﬂ: { text: "fl" }, ﬃ: { text: "ffi" }, ﬄ: { text: "ffl" }, ﬅ: { text: "st" }, ﬆ: { text: "st" }, "�": { text: "\\dbend", macrospacer: true }, "⁒": { text: "\\textdiscount", macrospacer: true }, "‽": { text: "\\textinterrobang", macrospacer: true }, "※": { text: "\\textreferencemark", macrospacer: true }, Ŧ: { text: "\\textTstroke", macrospacer: true }, ŧ: { text: "\\texttstroke", macrospacer: true }, "ˋ": { text: "\\textasciigrave", macrospacer: true }, Α: { math: "A", alt: ["unicode-math"] }, Β: { math: "B", alt: ["unicode-math"] }, Ε: { math: "E", alt: ["unicode-math"] }, Ζ: { math: "Z", alt: ["unicode-math"] }, Η: { math: "H", alt: ["unicode-math"] }, Ι: { math: "I", alt: ["unicode-math"] }, Κ: { math: "K", alt: ["unicode-math"] }, Μ: { math: "M", alt: ["unicode-math"] }, Ν: { math: "N", alt: ["unicode-math"] }, Ο: { math: "O", alt: ["unicode-math"] }, Ρ: { math: "P", alt: ["unicode-math"] }, Τ: { math: "T", alt: ["unicode-math"] }, Χ: { math: "X", alt: ["unicode-math"] }, ο: { math: "o", alt: ["unicode-math"] }, ℊ: { math: "g", alt: ["mathrsfs"] }, ℐ: { math: "I", alt: ["mathrsfs"] }, ℒ: { math: "L", alt: ["mathrsfs", "unicode-math"] }, ℛ: { math: "R", alt: ["mathrsfs", "unicode-math"] }, ℬ: { math: "B", alt: ["mathrsfs"] }, ℯ: { math: "e", alt: ["mathrsfs"] }, ℰ: { math: "E", alt: ["mathrsfs"] }, ℱ: { math: "F", alt: ["mathrsfs"] }, ℳ: { math: "M", alt: ["mathrsfs"] }, ℴ: { math: "o", alt: ["mathrsfs"] }, "𝒜": { math: "A", alt: ["mathrsfs", "unicode-math"] }, "𝒞": { math: "C", alt: ["mathrsfs", "unicode-math"] }, "𝒟": { math: "D", alt: ["mathrsfs", "unicode-math"] }, "𝒢": { math: "G", alt: ["mathrsfs", "unicode-math"] }, "𝒥": { math: "J", alt: ["mathrsfs", "unicode-math"] }, "𝒦": { math: "K", alt: ["mathrsfs", "unicode-math"] }, "𝒩": { math: "N", alt: ["mathrsfs", "unicode-math"] }, "𝒪": { math: "O", alt: ["mathrsfs", "unicode-math"] }, "𝒫": { math: "P", alt: ["mathrsfs", "unicode-math"] }, "𝒬": { math: "Q", alt: ["mathrsfs", "unicode-math"] }, "𝒮": { math: "S", alt: ["mathrsfs", "unicode-math"] }, "𝒯": { math: "T", alt: ["mathrsfs", "unicode-math"] }, "𝒰": { math: "U", alt: ["mathrsfs", "unicode-math"] }, "𝒱": { math: "V", alt: ["mathrsfs", "unicode-math"] }, "𝒲": { math: "W", alt: ["mathrsfs", "unicode-math"] }, "𝒳": { math: "X", alt: ["mathrsfs", "unicode-math"] }, "𝒴": { math: "Y", alt: ["mathrsfs", "unicode-math"] }, "𝒵": { math: "Z", alt: ["mathrsfs", "unicode-math"] }, "𝒶": { math: "a", alt: ["mathrsfs", "unicode-math"] }, "𝒷": { math: "b", alt: ["mathrsfs", "unicode-math"] }, "𝒸": { math: "c", alt: ["mathrsfs", "unicode-math"] }, "𝒹": { math: "d", alt: ["mathrsfs", "unicode-math"] }, "𝒻": { math: "f", alt: ["mathrsfs", "unicode-math"] }, "𝒽": { math: "h", alt: ["mathrsfs", "unicode-math"] }, "𝒾": { math: "i", alt: ["mathrsfs", "unicode-math"] }, "𝒿": { math: "j", alt: ["mathrsfs", "unicode-math"] }, "𝓀": { math: "k", alt: ["mathrsfs", "unicode-math"] }, "𝓁": { math: "l", alt: ["mathrsfs", "unicode-math"] }, "𝓂": { math: "m", alt: ["mathrsfs", "unicode-math"] }, "𝓃": { math: "n", alt: ["mathrsfs", "unicode-math"] }, "𝓅": { math: "p", alt: ["mathrsfs", "unicode-math"] }, "𝓆": { math: "q", alt: ["mathrsfs", "unicode-math"] }, "𝓇": { math: "r", alt: ["mathrsfs", "unicode-math"] }, "𝓈": { math: "s", alt: ["mathrsfs", "unicode-math"] }, "𝓉": { math: "t", alt: ["mathrsfs", "unicode-math"] }, "𝓊": { math: "u", alt: ["mathrsfs", "unicode-math"] }, "𝓋": { math: "v", alt: ["mathrsfs", "unicode-math"] }, "𝓌": { math: "w", alt: ["mathrsfs", "unicode-math"] }, "𝓍": { math: "x", alt: ["mathrsfs", "unicode-math"] }, "𝓎": { math: "y", alt: ["mathrsfs", "unicode-math"] }, "𝓏": { math: "z", alt: ["mathrsfs", "unicode-math"] }, "Ⓐ": { text: "(A)" }, "Ⓑ": { text: "(B)" }, "Ⓒ": { text: "(C)" }, "Ⓓ": { text: "(D)" }, "Ⓔ": { text: "(E)" }, "Ⓕ": { text: "(F)" }, "Ⓖ": { text: "(G)" }, "Ⓗ": { text: "(H)" }, "Ⓘ": { text: "(I)" }, "Ⓙ": { text: "(J)" }, "Ⓚ": { text: "(K)" }, "Ⓛ": { text: "(L)" }, "Ⓜ": { text: "(M)" }, "Ⓝ": { text: "(N)" }, "Ⓞ": { text: "(O)" }, "Ⓟ": { text: "(P)" }, "Ⓠ": { text: "(Q)" }, "Ⓡ": { text: "(R)" }, "Ⓣ": { text: "(T)" }, "Ⓤ": { text: "(U)" }, "Ⓥ": { text: "(V)" }, "Ⓦ": { text: "(W)" }, "Ⓧ": { text: "(X)" }, "Ⓨ": { text: "(Y)" }, "Ⓩ": { text: "(Z)" }, "ⓐ": { text: "(a)" }, "ⓑ": { text: "(b)" }, "ⓒ": { text: "(c)" }, "ⓓ": { text: "(d)" }, "ⓔ": { text: "(e)" }, "ⓕ": { text: "(f)" }, "ⓖ": { text: "(g)" }, "ⓗ": { text: "(h)" }, "ⓘ": { text: "(i)" }, "ⓙ": { text: "(j)" }, "ⓚ": { text: "(k)" }, "ⓛ": { text: "(l)" }, "ⓜ": { text: "(m)" }, "ⓝ": { text: "(n)" }, "ⓞ": { text: "(o)" }, "ⓟ": { text: "(p)" }, "ⓠ": { text: "(q)" }, "ⓡ": { text: "(r)" }, "ⓢ": { text: "(s)" }, "ⓣ": { text: "(t)" }, "ⓤ": { text: "(u)" }, "ⓥ": { text: "(v)" }, "ⓦ": { text: "(w)" }, "ⓧ": { text: "(x)" }, "ⓨ": { text: "(y)" }, "ⓩ": { text: "(z)" }, "⓪": { text: "(0)" }, "━": { text: "=", alt: ["pmboxdraw"] }, "│": { text: "|", alt: ["pmboxdraw"] }, "┃": { text: "|", alt: ["pmboxdraw"] }, "┅": { text: "=" }, "┇": { text: "|" }, "┉": { text: "=" }, "┊": { text: "|" }, "┋": { text: "|" }, "╍": { text: "=" }, "╎": { text: "|" }, "╏": { text: "|" }, "═": { text: "=", alt: ["pmboxdraw"] }, "║": { text: "|", alt: ["pmboxdraw"] }, "╽": { text: "|", alt: ["pmboxdraw"] }, "╿": { text: "|", alt: ["pmboxdraw"] } }, package: { wasysym: { "♓": { text: "\\pisces", math: "\\pisces", macrospacer: true }, "☽": { text: "\\rightmoon", macrospacer: true }, "☾": { text: "\\leftmoon", macrospacer: true } }, "unicode-math": { "€": { math: "\\euro" }, "̀": { math: "\\grave" }, "́": { math: "\\acute" }, "̃": { math: "\\tilde" }, "̆": { math: "\\breve" }, "̇": { math: "\\dot" }, "̈": { math: "\\ddot" }, "̉": { math: "\\ovhook" }, "̌": { math: "\\check" }, "̐": { math: "\\candra" }, "̒": { math: "\\oturnedcomma" }, "̕": { math: "\\ocommatopright" }, "̚": { math: "\\droang" }, "͍": { math: "\\underleftrightarrow" }, Α: { math: "\\mupAlpha" }, Β: { math: "\\mupBeta" }, Γ: { math: "\\mupGamma" }, Δ: { math: "\\mupDelta" }, Ε: { math: "\\mupEpsilon" }, Ζ: { math: "\\mupZeta" }, Η: { math: "\\mupEta" }, Θ: { math: "\\mupTheta" }, Ι: { math: "\\mupIota" }, Κ: { math: "\\mupKappa" }, Λ: { math: "\\mupLambda" }, Μ: { math: "\\mupMu" }, Ν: { math: "\\mupNu" }, Ο: { math: "\\mupOmicron" }, Ρ: { math: "\\mupRho" }, Τ: { math: "\\mupTau" }, Χ: { math: "\\mupChi" }, ο: { math: "\\mupomicron" }, ϐ: { math: "\\varbeta" }, ϰ: { math: "\\varkappa" }, "϶": { math: "\\upbackepsilon" }, "𝐀": { math: "\\mbfA" }, "𝐁": { math: "\\mbfB" }, "𝐂": { math: "\\mbfC" }, "𝐃": { math: "\\mbfD" }, "𝐄": { math: "\\mbfE" }, "𝐅": { math: "\\mbfF" }, "𝐆": { math: "\\mbfG" }, "𝐇": { math: "\\mbfH" }, "𝐈": { math: "\\mbfI" }, "𝐉": { math: "\\mbfJ" }, "𝐊": { math: "\\mbfK" }, "𝐋": { math: "\\mbfL" }, "𝐌": { math: "\\mbfM" }, "𝐍": { math: "\\mbfN" }, "𝐎": { math: "\\mbfO" }, "𝐏": { math: "\\mbfP" }, "𝐐": { math: "\\mbfQ" }, "𝐑": { math: "\\mbfR" }, "𝐒": { math: "\\mbfS" }, "𝐓": { math: "\\mbfT" }, "𝐔": { math: "\\mbfU" }, "𝐕": { math: "\\mbfV" }, "𝐖": { math: "\\mbfW" }, "𝐗": { math: "\\mbfX" }, "𝐘": { math: "\\mbfY" }, "𝐙": { math: "\\mbfZ" }, "𝐚": { math: "\\mbfa" }, "𝐛": { math: "\\mbfb" }, "𝐜": { math: "\\mbfc" }, "𝐝": { math: "\\mbfd" }, "𝐞": { math: "\\mbfe" }, "𝐟": { math: "\\mbff" }, "𝐠": { math: "\\mbfg" }, "𝐡": { math: "\\mbfh" }, "𝐢": { math: "\\mbfi" }, "𝐣": { math: "\\mbfj" }, "𝐤": { math: "\\mbfk" }, "𝐥": { math: "\\mbfl" }, "𝐦": { math: "\\mbfm" }, "𝐧": { math: "\\mbfn" }, "𝐨": { math: "\\mbfo" }, "𝐩": { math: "\\mbfp" }, "𝐪": { math: "\\mbfq" }, "𝐫": { math: "\\mbfr" }, "𝐬": { math: "\\mbfs" }, "𝐭": { math: "\\mbft" }, "𝐮": { math: "\\mbfu" }, "𝐯": { math: "\\mbfv" }, "𝐰": { math: "\\mbfw" }, "𝐱": { math: "\\mbfx" }, "𝐲": { math: "\\mbfy" }, "𝐳": { math: "\\mbfz" }, "𝐴": { math: "\\mitA" }, "𝐵": { math: "\\mitB" }, "𝐶": { math: "\\mitC" }, "𝐷": { math: "\\mitD" }, "𝐸": { math: "\\mitE" }, "𝐹": { math: "\\mitF" }, "𝐺": { math: "\\mitG" }, "𝐻": { math: "\\mitH" }, "𝐼": { math: "\\mitI" }, "𝐽": { math: "\\mitJ" }, "𝐾": { math: "\\mitK" }, "𝐿": { math: "\\mitL" }, "𝑀": { math: "\\mitM" }, "𝑁": { math: "\\mitN" }, "𝑂": { math: "\\mitO" }, "𝑃": { math: "\\mitP" }, "𝑄": { math: "\\mitQ" }, "𝑅": { math: "\\mitR" }, "𝑆": { math: "\\mitS" }, "𝑇": { math: "\\mitT" }, "𝑈": { math: "\\mitU" }, "𝑉": { math: "\\mitV" }, "𝑊": { math: "\\mitW" }, "𝑋": { math: "\\mitX" }, "𝑌": { math: "\\mitY" }, "𝑍": { math: "\\mitZ" }, "𝑎": { math: "\\mita" }, "𝑏": { math: "\\mitb" }, "𝑐": { math: "\\mitc" }, "𝑑": { math: "\\mitd" }, "𝑒": { math: "\\mite" }, "𝑓": { math: "\\mitf" }, "𝑔": { math: "\\mitg" }, "𝑖": { math: "\\miti" }, "𝑗": { math: "\\mitj" }, "𝑘": { math: "\\mitk" }, "𝑙": { math: "\\mitl" }, "𝑚": { math: "\\mitm" }, "𝑛": { math: "\\mitn" }, "𝑜": { math: "\\mito" }, "𝑝": { math: "\\mitp" }, "𝑞": { math: "\\mitq" }, "𝑟": { math: "\\mitr" }, "𝑠": { math: "\\mits" }, "𝑡": { math: "\\mitt" }, "𝑢": { math: "\\mitu" }, "𝑣": { math: "\\mitv" }, "𝑤": { math: "\\mitw" }, "𝑥": { math: "\\mitx" }, "𝑦": { math: "\\mity" }, "𝑧": { math: "\\mitz" }, "𝑨": { math: "\\mbfitA" }, "𝑩": { math: "\\mbfitB" }, "𝑪": { math: "\\mbfitC" }, "𝑫": { math: "\\mbfitD" }, "𝑬": { math: "\\mbfitE" }, "𝑭": { math: "\\mbfitF" }, "𝑮": { math: "\\mbfitG" }, "𝑯": { math: "\\mbfitH" }, "𝑰": { math: "\\mbfitI" }, "𝑱": { math: "\\mbfitJ" }, "𝑲": { math: "\\mbfitK" }, "𝑳": { math: "\\mbfitL" }, "𝑴": { math: "\\mbfitM" }, "𝑵": { math: "\\mbfitN" }, "𝑶": { math: "\\mbfitO" }, "𝑷": { math: "\\mbfitP" }, "𝑸": { math: "\\mbfitQ" }, "𝑹": { math: "\\mbfitR" }, "𝑺": { math: "\\mbfitS" }, "𝑻": { math: "\\mbfitT" }, "𝑼": { math: "\\mbfitU" }, "𝑽": { math: "\\mbfitV" }, "𝑾": { math: "\\mbfitW" }, "𝑿": { math: "\\mbfitX" }, "𝒀": { math: "\\mbfitY" }, "𝒁": { math: "\\mbfitZ" }, "𝒂": { math: "\\mbfita" }, "𝒃": { math: "\\mbfitb" }, "𝒄": { math: "\\mbfitc" }, "𝒅": { math: "\\mbfitd" }, "𝒆": { math: "\\mbfite" }, "𝒇": { math: "\\mbfitf" }, "𝒈": { math: "\\mbfitg" }, "𝒉": { math: "\\mbfith" }, "𝒊": { math: "\\mbfiti" }, "𝒋": { math: "\\mbfitj" }, "𝒌": { math: "\\mbfitk" }, "𝒍": { math: "\\mbfitl" }, "𝒎": { math: "\\mbfitm" }, "𝒏": { math: "\\mbfitn" }, "𝒐": { math: "\\mbfito" }, "𝒑": { math: "\\mbfitp" }, "𝒒": { math: "\\mbfitq" }, "𝒓": { math: "\\mbfitr" }, "𝒔": { math: "\\mbfits" }, "𝒕": { math: "\\mbfitt" }, "𝒖": { math: "\\mbfitu" }, "𝒗": { math: "\\mbfitv" }, "𝒘": { math: "\\mbfitw" }, "𝒙": { math: "\\mbfitx" }, "𝒚": { math: "\\mbfity" }, "𝒛": { math: "\\mbfitz" }, "𝒜": { math: "\\mscrA" }, "𝒞": { math: "\\mscrC" }, "𝒟": { math: "\\mscrD" }, "𝒢": { math: "\\mscrG" }, "𝒥": { math: "\\mscrJ" }, "𝒦": { math: "\\mscrK" }, "𝒩": { math: "\\mscrN" }, "𝒪": { math: "\\mscrO" }, "𝒫": { math: "\\mscrP" }, "𝒬": { math: "\\mscrQ" }, "𝒮": { math: "\\mscrS" }, "𝒯": { math: "\\mscrT" }, "𝒰": { math: "\\mscrU" }, "𝒱": { math: "\\mscrV" }, "𝒲": { math: "\\mscrW" }, "𝒳": { math: "\\mscrX" }, "𝒴": { math: "\\mscrY" }, "𝒵": { math: "\\mscrZ" }, "𝒶": { math: "\\mscra" }, "𝒷": { math: "\\mscrb" }, "𝒸": { math: "\\mscrc" }, "𝒹": { math: "\\mscrd" }, "𝒻": { math: "\\mscrf" }, "𝒽": { math: "\\mscrh" }, "𝒾": { math: "\\mscri" }, "𝒿": { math: "\\mscrj" }, "𝓀": { math: "\\mscrk" }, "𝓁": { math: "\\mscrl" }, "𝓂": { math: "\\mscrm" }, "𝓃": { math: "\\mscrn" }, "𝓅": { math: "\\mscrp" }, "𝓆": { math: "\\mscrq" }, "𝓇": { math: "\\mscrr" }, "𝓈": { math: "\\mscrs" }, "𝓉": { math: "\\mscrt" }, "𝓊": { math: "\\mscru" }, "𝓋": { math: "\\mscrv" }, "𝓌": { math: "\\mscrw" }, "𝓍": { math: "\\mscrx" }, "𝓎": { math: "\\mscry" }, "𝓏": { math: "\\mscrz" }, "𝓐": { math: "\\mbfscrA" }, "𝓑": { math: "\\mbfscrB" }, "𝓒": { math: "\\mbfscrC" }, "𝓓": { math: "\\mbfscrD" }, "𝓔": { math: "\\mbfscrE" }, "𝓕": { math: "\\mbfscrF" }, "𝓖": { math: "\\mbfscrG" }, "𝓗": { math: "\\mbfscrH" }, "𝓘": { math: "\\mbfscrI" }, "𝓙": { math: "\\mbfscrJ" }, "𝓚": { math: "\\mbfscrK" }, "𝓛": { math: "\\mbfscrL" }, "𝓜": { math: "\\mbfscrM" }, "𝓝": { math: "\\mbfscrN" }, "𝓞": { math: "\\mbfscrO" }, "𝓟": { math: "\\mbfscrP" }, "𝓠": { math: "\\mbfscrQ" }, "𝓡": { math: "\\mbfscrR" }, "𝓢": { math: "\\mbfscrS" }, "𝓣": { math: "\\mbfscrT" }, "𝓤": { math: "\\mbfscrU" }, "𝓥": { math: "\\mbfscrV" }, "𝓦": { math: "\\mbfscrW" }, "𝓧": { math: "\\mbfscrX" }, "𝓨": { math: "\\mbfscrY" }, "𝓩": { math: "\\mbfscrZ" }, "𝓪": { math: "\\mbfscra" }, "𝓫": { math: "\\mbfscrb" }, "𝓬": { math: "\\mbfscrc" }, "𝓭": { math: "\\mbfscrd" }, "𝓮": { math: "\\mbfscre" }, "𝓯": { math: "\\mbfscrf" }, "𝓰": { math: "\\mbfscrg" }, "𝓱": { math: "\\mbfscrh" }, "𝓲": { math: "\\mbfscri" }, "𝓳": { math: "\\mbfscrj" }, "𝓴": { math: "\\mbfscrk" }, "𝓵": { math: "\\mbfscrl" }, "𝓶": { math: "\\mbfscrm" }, "𝓷": { math: "\\mbfscrn" }, "𝓸": { math: "\\mbfscro" }, "𝓹": { math: "\\mbfscrp" }, "𝓺": { math: "\\mbfscrq" }, "𝓻": { math: "\\mbfscrr" }, "𝓼": { math: "\\mbfscrs" }, "𝓽": { math: "\\mbfscrt" }, "𝓾": { math: "\\mbfscru" }, "𝓿": { math: "\\mbfscrv" }, "𝔀": { math: "\\mbfscrw" }, "𝔁": { math: "\\mbfscrx" }, "𝔂": { math: "\\mbfscry" }, "𝔃": { math: "\\mbfscrz" }, "𝔄": { math: "\\mfrakA" }, "𝔅": { math: "\\mfrakB" }, "𝔇": { math: "\\mfrakD" }, "𝔈": { math: "\\mfrakE" }, "𝔉": { math: "\\mfrakF" }, "𝔊": { math: "\\mfrakG" }, "𝔍": { math: "\\mfrakJ" }, "𝔎": { math: "\\mfrakK" }, "𝔏": { math: "\\mfrakL" }, "𝔐": { math: "\\mfrakM" }, "𝔑": { math: "\\mfrakN" }, "𝔒": { math: "\\mfrakO" }, "𝔓": { math: "\\mfrakP" }, "𝔔": { math: "\\mfrakQ" }, "𝔖": { math: "\\mfrakS" }, "𝔗": { math: "\\mfrakT" }, "𝔘": { math: "\\mfrakU" }, "𝔙": { math: "\\mfrakV" }, "𝔚": { math: "\\mfrakW" }, "𝔛": { math: "\\mfrakX" }, "𝔜": { math: "\\mfrakY" }, "𝔞": { math: "\\mfraka" }, "𝔟": { math: "\\mfrakb" }, "𝔠": { math: "\\mfrakc" }, "𝔡": { math: "\\mfrakd" }, "𝔢": { math: "\\mfrake" }, "𝔣": { math: "\\mfrakf" }, "𝔤": { math: "\\mfrakg" }, "𝔥": { math: "\\mfrakh" }, "𝔦": { math: "\\mfraki" }, "𝔧": { math: "\\mfrakj" }, "𝔨": { math: "\\mfrakk" }, "𝔩": { math: "\\mfrakl" }, "𝔪": { math: "\\mfrakm" }, "𝔫": { math: "\\mfrakn" }, "𝔬": { math: "\\mfrako" }, "𝔭": { math: "\\mfrakp" }, "𝔮": { math: "\\mfrakq" }, "𝔯": { math: "\\mfrakr" }, "𝔰": { math: "\\mfraks" }, "𝔱": { math: "\\mfrakt" }, "𝔲": { math: "\\mfraku" }, "𝔳": { math: "\\mfrakv" }, "𝔴": { math: "\\mfrakw" }, "𝔵": { math: "\\mfrakx" }, "𝔶": { math: "\\mfraky" }, "𝔷": { math: "\\mfrakz" }, "𝔸": { math: "\\BbbA" }, "𝔹": { math: "\\BbbB" }, "𝔻": { math: "\\BbbD" }, "𝔼": { math: "\\BbbE" }, "𝔽": { math: "\\BbbF" }, "𝔾": { math: "\\BbbG" }, "𝕀": { math: "\\BbbI" }, "𝕁": { math: "\\BbbJ" }, "𝕂": { math: "\\BbbK" }, "𝕃": { math: "\\BbbL" }, "𝕄": { math: "\\BbbM" }, "𝕆": { math: "\\BbbO" }, "𝕊": { math: "\\BbbS" }, "𝕋": { math: "\\BbbT" }, "𝕌": { math: "\\BbbU" }, "𝕍": { math: "\\BbbV" }, "𝕎": { math: "\\BbbW" }, "𝕏": { math: "\\BbbX" }, "𝕐": { math: "\\BbbY" }, "𝕒": { math: "\\Bbba" }, "𝕓": { math: "\\Bbbb" }, "𝕔": { math: "\\Bbbc" }, "𝕕": { math: "\\Bbbd" }, "𝕖": { math: "\\Bbbe" }, "𝕗": { math: "\\Bbbf" }, "𝕘": { math: "\\Bbbg" }, "𝕙": { math: "\\Bbbh" }, "𝕚": { math: "\\Bbbi" }, "𝕛": { math: "\\Bbbj" }, "𝕜": { math: "\\Bbbk" }, "𝕝": { math: "\\Bbbl" }, "𝕞": { math: "\\Bbbm" }, "𝕟": { math: "\\Bbbn" }, "𝕠": { math: "\\Bbbo" }, "𝕡": { math: "\\Bbbp" }, "𝕢": { math: "\\Bbbq" }, "𝕣": { math: "\\Bbbr" }, "𝕤": { math: "\\Bbbs" }, "𝕥": { math: "\\Bbbt" }, "𝕦": { math: "\\Bbbu" }, "𝕧": { math: "\\Bbbv" }, "𝕨": { math: "\\Bbbw" }, "𝕩": { math: "\\Bbbx" }, "𝕪": { math: "\\Bbby" }, "𝕫": { math: "\\Bbbz" }, "𝕬": { math: "\\mbffrakA" }, "𝕭": { math: "\\mbffrakB" }, "𝕮": { math: "\\mbffrakC" }, "𝕯": { math: "\\mbffrakD" }, "𝕰": { math: "\\mbffrakE" }, "𝕱": { math: "\\mbffrakF" }, "𝕲": { math: "\\mbffrakG" }, "𝕳": { math: "\\mbffrakH" }, "𝕴": { math: "\\mbffrakI" }, "𝕵": { math: "\\mbffrakJ" }, "𝕶": { math: "\\mbffrakK" }, "𝕷": { math: "\\mbffrakL" }, "𝕸": { math: "\\mbffrakM" }, "𝕹": { math: "\\mbffrakN" }, "𝕺": { math: "\\mbffrakO" }, "𝕻": { math: "\\mbffrakP" }, "𝕼": { math: "\\mbffrakQ" }, "𝕽": { math: "\\mbffrakR" }, "𝕾": { math: "\\mbffrakS" }, "𝕿": { math: "\\mbffrakT" }, "𝖀": { math: "\\mbffrakU" }, "𝖁": { math: "\\mbffrakV" }, "𝖂": { math: "\\mbffrakW" }, "𝖃": { math: "\\mbffrakX" }, "𝖄": { math: "\\mbffrakY" }, "𝖅": { math: "\\mbffrakZ" }, "𝖆": { math: "\\mbffraka" }, "𝖇": { math: "\\mbffrakb" }, "𝖈": { math: "\\mbffrakc" }, "𝖉": { math: "\\mbffrakd" }, "𝖊": { math: "\\mbffrake" }, "𝖋": { math: "\\mbffrakf" }, "𝖌": { math: "\\mbffrakg" }, "𝖍": { math: "\\mbffrakh" }, "𝖎": { math: "\\mbffraki" }, "𝖏": { math: "\\mbffrakj" }, "𝖐": { math: "\\mbffrakk" }, "𝖑": { math: "\\mbffrakl" }, "𝖒": { math: "\\mbffrakm" }, "𝖓": { math: "\\mbffrakn" }, "𝖔": { math: "\\mbffrako" }, "𝖕": { math: "\\mbffrakp" }, "𝖖": { math: "\\mbffrakq" }, "𝖗": { math: "\\mbffrakr" }, "𝖘": { math: "\\mbffraks" }, "𝖙": { math: "\\mbffrakt" }, "𝖚": { math: "\\mbffraku" }, "𝖛": { math: "\\mbffrakv" }, "𝖜": { math: "\\mbffrakw" }, "𝖝": { math: "\\mbffrakx" }, "𝖞": { math: "\\mbffraky" }, "𝖟": { math: "\\mbffrakz" }, "𝖠": { math: "\\msansA" }, "𝖡": { math: "\\msansB" }, "𝖢": { math: "\\msansC" }, "𝖣": { math: "\\msansD" }, "𝖤": { math: "\\msansE" }, "𝖥": { math: "\\msansF" }, "𝖦": { math: "\\msansG" }, "𝖧": { math: "\\msansH" }, "𝖨": { math: "\\msansI" }, "𝖩": { math: "\\msansJ" }, "𝖪": { math: "\\msansK" }, "𝖫": { math: "\\msansL" }, "𝖬": { math: "\\msansM" }, "𝖭": { math: "\\msansN" }, "𝖮": { math: "\\msansO" }, "𝖯": { math: "\\msansP" }, "𝖰": { math: "\\msansQ" }, "𝖱": { math: "\\msansR" }, "𝖲": { math: "\\msansS" }, "𝖳": { math: "\\msansT" }, "𝖴": { math: "\\msansU" }, "𝖵": { math: "\\msansV" }, "𝖶": { math: "\\msansW" }, "𝖷": { math: "\\msansX" }, "𝖸": { math: "\\msansY" }, "𝖹": { math: "\\msansZ" }, "𝖺": { math: "\\msansa" }, "𝖻": { math: "\\msansb" }, "𝖼": { math: "\\msansc" }, "𝖽": { math: "\\msansd" }, "𝖾": { math: "\\msanse" }, "𝖿": { math: "\\msansf" }, "𝗀": { math: "\\msansg" }, "𝗁": { math: "\\msansh" }, "𝗂": { math: "\\msansi" }, "𝗃": { math: "\\msansj" }, "𝗄": { math: "\\msansk" }, "𝗅": { math: "\\msansl" }, "𝗆": { math: "\\msansm" }, "𝗇": { math: "\\msansn" }, "𝗈": { math: "\\msanso" }, "𝗉": { math: "\\msansp" }, "𝗊": { math: "\\msansq" }, "𝗋": { math: "\\msansr" }, "𝗌": { math: "\\msanss" }, "𝗍": { math: "\\msanst" }, "𝗎": { math: "\\msansu" }, "𝗏": { math: "\\msansv" }, "𝗐": { math: "\\msansw" }, "𝗑": { math: "\\msansx" }, "𝗒": { math: "\\msansy" }, "𝗓": { math: "\\msansz" }, "𝗔": { math: "\\mbfsansA" }, "𝗕": { math: "\\mbfsansB" }, "𝗖": { math: "\\mbfsansC" }, "𝗗": { math: "\\mbfsansD" }, "𝗘": { math: "\\mbfsansE" }, "𝗙": { math: "\\mbfsansF" }, "𝗚": { math: "\\mbfsansG" }, "𝗛": { math: "\\mbfsansH" }, "𝗜": { math: "\\mbfsansI" }, "𝗝": { math: "\\mbfsansJ" }, "𝗞": { math: "\\mbfsansK" }, "𝗟": { math: "\\mbfsansL" }, "𝗠": { math: "\\mbfsansM" }, "𝗡": { math: "\\mbfsansN" }, "𝗢": { math: "\\mbfsansO" }, "𝗣": { math: "\\mbfsansP" }, "𝗤": { math: "\\mbfsansQ" }, "𝗥": { math: "\\mbfsansR" }, "𝗦": { math: "\\mbfsansS" }, "𝗧": { math: "\\mbfsansT" }, "𝗨": { math: "\\mbfsansU" }, "𝗩": { math: "\\mbfsansV" }, "𝗪": { math: "\\mbfsansW" }, "𝗫": { math: "\\mbfsansX" }, "𝗬": { math: "\\mbfsansY" }, "𝗭": { math: "\\mbfsansZ" }, "𝗮": { math: "\\mbfsansa" }, "𝗯": { math: "\\mbfsansb" }, "𝗰": { math: "\\mbfsansc" }, "𝗱": { math: "\\mbfsansd" }, "𝗲": { math: "\\mbfsanse" }, "𝗳": { math: "\\mbfsansf" }, "𝗴": { math: "\\mbfsansg" }, "𝗵": { math: "\\mbfsansh" }, "𝗶": { math: "\\mbfsansi" }, "𝗷": { math: "\\mbfsansj" }, "𝗸": { math: "\\mbfsansk" }, "𝗹": { math: "\\mbfsansl" }, "𝗺": { math: "\\mbfsansm" }, "𝗻": { math: "\\mbfsansn" }, "𝗼": { math: "\\mbfsanso" }, "𝗽": { math: "\\mbfsansp" }, "𝗾": { math: "\\mbfsansq" }, "𝗿": { math: "\\mbfsansr" }, "𝘀": { math: "\\mbfsanss" }, "𝘁": { math: "\\mbfsanst" }, "𝘂": { math: "\\mbfsansu" }, "𝘃": { math: "\\mbfsansv" }, "𝘄": { math: "\\mbfsansw" }, "𝘅": { math: "\\mbfsansx" }, "𝘆": { math: "\\mbfsansy" }, "𝘇": { math: "\\mbfsansz" }, "𝘈": { math: "\\mitsansA" }, "𝘉": { math: "\\mitsansB" }, "𝘊": { math: "\\mitsansC" }, "𝘋": { math: "\\mitsansD" }, "𝘌": { math: "\\mitsansE" }, "𝘍": { math: "\\mitsansF" }, "𝘎": { math: "\\mitsansG" }, "𝘏": { math: "\\mitsansH" }, "𝘐": { math: "\\mitsansI" }, "𝘑": { math: "\\mitsansJ" }, "𝘒": { math: "\\mitsansK" }, "𝘓": { math: "\\mitsansL" }, "𝘔": { math: "\\mitsansM" }, "𝘕": { math: "\\mitsansN" }, "𝘖": { math: "\\mitsansO" }, "𝘗": { math: "\\mitsansP" }, "𝘘": { math: "\\mitsansQ" }, "𝘙": { math: "\\mitsansR" }, "𝘚": { math: "\\mitsansS" }, "𝘛": { math: "\\mitsansT" }, "𝘜": { math: "\\mitsansU" }, "𝘝": { math: "\\mitsansV" }, "𝘞": { math: "\\mitsansW" }, "𝘟": { math: "\\mitsansX" }, "𝘠": { math: "\\mitsansY" }, "𝘡": { math: "\\mitsansZ" }, "𝘢": { math: "\\mitsansa" }, "𝘣": { math: "\\mitsansb" }, "𝘤": { math: "\\mitsansc" }, "𝘥": { math: "\\mitsansd" }, "𝘦": { math: "\\mitsanse" }, "𝘧": { math: "\\mitsansf" }, "𝘨": { math: "\\mitsansg" }, "𝘩": { math: "\\mitsansh" }, "𝘪": { math: "\\mitsansi" }, "𝘫": { math: "\\mitsansj" }, "𝘬": { math: "\\mitsansk" }, "𝘭": { math: "\\mitsansl" }, "𝘮": { math: "\\mitsansm" }, "𝘯": { math: "\\mitsansn" }, "𝘰": { math: "\\mitsanso" }, "𝘱": { math: "\\mitsansp" }, "𝘲": { math: "\\mitsansq" }, "𝘳": { math: "\\mitsansr" }, "𝘴": { math: "\\mitsanss" }, "𝘵": { math: "\\mitsanst" }, "𝘶": { math: "\\mitsansu" }, "𝘷": { math: "\\mitsansv" }, "𝘸": { math: "\\mitsansw" }, "𝘹": { math: "\\mitsansx" }, "𝘺": { math: "\\mitsansy" }, "𝘻": { math: "\\mitsansz" }, "𝘼": { math: "\\mbfitsansA" }, "𝘽": { math: "\\mbfitsansB" }, "𝘾": { math: "\\mbfitsansC" }, "𝘿": { math: "\\mbfitsansD" }, "𝙀": { math: "\\mbfitsansE" }, "𝙁": { math: "\\mbfitsansF" }, "𝙂": { math: "\\mbfitsansG" }, "𝙃": { math: "\\mbfitsansH" }, "𝙄": { math: "\\mbfitsansI" }, "𝙅": { math: "\\mbfitsansJ" }, "𝙆": { math: "\\mbfitsansK" }, "𝙇": { math: "\\mbfitsansL" }, "𝙈": { math: "\\mbfitsansM" }, "𝙉": { math: "\\mbfitsansN" }, "𝙊": { math: "\\mbfitsansO" }, "𝙋": { math: "\\mbfitsansP" }, "𝙌": { math: "\\mbfitsansQ" }, "𝙍": { math: "\\mbfitsansR" }, "𝙎": { math: "\\mbfitsansS" }, "𝙏": { math: "\\mbfitsansT" }, "𝙐": { math: "\\mbfitsansU" }, "𝙑": { math: "\\mbfitsansV" }, "𝙒": { math: "\\mbfitsansW" }, "𝙓": { math: "\\mbfitsansX" }, "𝙔": { math: "\\mbfitsansY" }, "𝙕": { math: "\\mbfitsansZ" }, "𝙖": { math: "\\mbfitsansa" }, "𝙗": { math: "\\mbfitsansb" }, "𝙘": { math: "\\mbfitsansc" }, "𝙙": { math: "\\mbfitsansd" }, "𝙚": { math: "\\mbfitsanse" }, "𝙛": { math: "\\mbfitsansf" }, "𝙜": { math: "\\mbfitsansg" }, "𝙝": { math: "\\mbfitsansh" }, "𝙞": { math: "\\mbfitsansi" }, "𝙟": { math: "\\mbfitsansj" }, "𝙠": { math: "\\mbfitsansk" }, "𝙡": { math: "\\mbfitsansl" }, "𝙢": { math: "\\mbfitsansm" }, "𝙣": { math: "\\mbfitsansn" }, "𝙤": { math: "\\mbfitsanso" }, "𝙥": { math: "\\mbfitsansp" }, "𝙦": { math: "\\mbfitsansq" }, "𝙧": { math: "\\mbfitsansr" }, "𝙨": { math: "\\mbfitsanss" }, "𝙩": { math: "\\mbfitsanst" }, "𝙪": { math: "\\mbfitsansu" }, "𝙫": { math: "\\mbfitsansv" }, "𝙬": { math: "\\mbfitsansw" }, "𝙭": { math: "\\mbfitsansx" }, "𝙮": { math: "\\mbfitsansy" }, "𝙯": { math: "\\mbfitsansz" }, "𝙰": { math: "\\mttA" }, "𝙱": { math: "\\mttB" }, "𝙲": { math: "\\mttC" }, "𝙳": { math: "\\mttD" }, "𝙴": { math: "\\mttE" }, "𝙵": { math: "\\mttF" }, "𝙶": { math: "\\mttG" }, "𝙷": { math: "\\mttH" }, "𝙸": { math: "\\mttI" }, "𝙹": { math: "\\mttJ" }, "𝙺": { math: "\\mttK" }, "𝙻": { math: "\\mttL" }, "𝙼": { math: "\\mttM" }, "𝙽": { math: "\\mttN" }, "𝙾": { math: "\\mttO" }, "𝙿": { math: "\\mttP" }, "𝚀": { math: "\\mttQ" }, "𝚁": { math: "\\mttR" }, "𝚂": { math: "\\mttS" }, "𝚃": { math: "\\mttT" }, "𝚄": { math: "\\mttU" }, "𝚅": { math: "\\mttV" }, "𝚆": { math: "\\mttW" }, "𝚇": { math: "\\mttX" }, "𝚈": { math: "\\mttY" }, "𝚉": { math: "\\mttZ" }, "𝚊": { math: "\\mtta" }, "𝚋": { math: "\\mttb" }, "𝚌": { math: "\\mttc" }, "𝚍": { math: "\\mttd" }, "𝚎": { math: "\\mtte" }, "𝚏": { math: "\\mttf" }, "𝚐": { math: "\\mttg" }, "𝚑": { math: "\\mtth" }, "𝚒": { math: "\\mtti" }, "𝚓": { math: "\\mttj" }, "𝚔": { math: "\\mttk" }, "𝚕": { math: "\\mttl" }, "𝚖": { math: "\\mttm" }, "𝚗": { math: "\\mttn" }, "𝚘": { math: "\\mtto" }, "𝚙": { math: "\\mttp" }, "𝚚": { math: "\\mttq" }, "𝚛": { math: "\\mttr" }, "𝚜": { math: "\\mtts" }, "𝚝": { math: "\\mttt" }, "𝚞": { math: "\\mttu" }, "𝚟": { math: "\\mttv" }, "𝚠": { math: "\\mttw" }, "𝚡": { math: "\\mttx" }, "𝚢": { math: "\\mtty" }, "𝚣": { math: "\\mttz" }, "𝚤": { math: "\\imath" }, "𝚥": { math: "\\jmath" }, "𝚨": { math: "\\mbfAlpha" }, "𝚩": { math: "\\mbfBeta" }, "𝚪": { math: "\\mbfGamma" }, "𝚫": { math: "\\mbfDelta" }, "𝚬": { math: "\\mbfEpsilon" }, "𝚭": { math: "\\mbfZeta" }, "𝚮": { math: "\\mbfEta" }, "𝚯": { math: "\\mbfTheta" }, "𝚰": { math: "\\mbfIota" }, "𝚱": { math: "\\mbfKappa" }, "𝚲": { math: "\\mbfLambda" }, "𝚳": { math: "\\mbfMu" }, "𝚴": { math: "\\mbfNu" }, "𝚵": { math: "\\mbfXi" }, "𝚶": { math: "\\mbfOmicron" }, "𝚷": { math: "\\mbfPi" }, "𝚸": { math: "\\mbfRho" }, "𝚹": { math: "\\mbfvarTheta" }, "𝚺": { math: "\\mbfSigma" }, "𝚻": { math: "\\mbfTau" }, "𝚼": { math: "\\mbfUpsilon" }, "𝚽": { math: "\\mbfPhi" }, "𝚾": { math: "\\mbfChi" }, "𝚿": { math: "\\mbfPsi" }, "𝛀": { math: "\\mbfOmega" }, "𝛁": { math: "\\mbfnabla" }, "𝛂": { math: "\\mbfalpha" }, "𝛃": { math: "\\mbfbeta" }, "𝛄": { math: "\\mbfgamma" }, "𝛅": { math: "\\mbfdelta" }, "𝛆": { math: "\\mbfvarepsilon" }, "𝛇": { math: "\\mbfzeta" }, "𝛈": { math: "\\mbfeta" }, "𝛉": { math: "\\mbftheta" }, "𝛊": { math: "\\mbfiota" }, "𝛋": { math: "\\mbfkappa" }, "𝛌": { math: "\\mbflambda" }, "𝛍": { math: "\\mbfmu" }, "𝛎": { math: "\\mbfnu" }, "𝛏": { math: "\\mbfxi" }, "𝛐": { math: "\\mbfomicron" }, "𝛑": { math: "\\mbfpi" }, "𝛒": { math: "\\mbfrho" }, "𝛓": { math: "\\mbfvarsigma" }, "𝛔": { math: "\\mbfsigma" }, "𝛕": { math: "\\mbftau" }, "𝛖": { math: "\\mbfupsilon" }, "𝛗": { math: "\\mbfvarphi" }, "𝛘": { math: "\\mbfchi" }, "𝛙": { math: "\\mbfpsi" }, "𝛚": { math: "\\mbfomega" }, "𝛛": { math: "\\mbfpartial" }, "𝛜": { math: "\\mbfepsilon" }, "𝛝": { math: "\\mbfvartheta" }, "𝛞": { math: "\\mbfvarkappa" }, "𝛟": { math: "\\mbfphi" }, "𝛠": { math: "\\mbfvarrho" }, "𝛡": { math: "\\mbfvarpi" }, "𝛢": { math: "\\mitAlpha" }, "𝛣": { math: "\\mitBeta" }, "𝛤": { math: "\\mitGamma" }, "𝛥": { math: "\\mitDelta" }, "𝛦": { math: "\\mitEpsilon" }, "𝛧": { math: "\\mitZeta" }, "𝛨": { math: "\\mitEta" }, "𝛩": { math: "\\mitTheta" }, "𝛪": { math: "\\mitIota" }, "𝛫": { math: "\\mitKappa" }, "𝛬": { math: "\\mitLambda" }, "𝛭": { math: "\\mitMu" }, "𝛮": { math: "\\mitNu" }, "𝛯": { math: "\\mitXi" }, "𝛰": { math: "\\mitOmicron" }, "𝛱": { math: "\\mitPi" }, "𝛲": { math: "\\mitRho" }, "𝛳": { math: "\\mitvarTheta" }, "𝛴": { math: "\\mitSigma" }, "𝛵": { math: "\\mitTau" }, "𝛶": { math: "\\mitUpsilon" }, "𝛷": { math: "\\mitPhi" }, "𝛸": { math: "\\mitChi" }, "𝛹": { math: "\\mitPsi" }, "𝛺": { math: "\\mitOmega" }, "𝛻": { math: "\\mitnabla" }, "𝛼": { math: "\\mitalpha" }, "𝛽": { math: "\\mitbeta" }, "𝛾": { math: "\\mitgamma" }, "𝛿": { math: "\\mitdelta" }, "𝜀": { math: "\\mitvarepsilon" }, "𝜁": { math: "\\mitzeta" }, "𝜂": { math: "\\miteta" }, "𝜃": { math: "\\mittheta" }, "𝜄": { math: "\\mitiota" }, "𝜅": { math: "\\mitkappa" }, "𝜆": { math: "\\mitlambda" }, "𝜇": { math: "\\mitmu" }, "𝜈": { math: "\\mitnu" }, "𝜉": { math: "\\mitxi" }, "𝜊": { math: "\\mitomicron" }, "𝜋": { math: "\\mitpi" }, "𝜌": { math: "\\mitrho" }, "𝜍": { math: "\\mitvarsigma" }, "𝜎": { math: "\\mitsigma" }, "𝜏": { math: "\\mittau" }, "𝜐": { math: "\\mitupsilon" }, "𝜑": { math: "\\mitvarphi" }, "𝜒": { math: "\\mitchi" }, "𝜓": { math: "\\mitpsi" }, "𝜔": { math: "\\mitomega" }, "𝜕": { math: "\\mitpartial" }, "𝜖": { math: "\\mitepsilon" }, "𝜗": { math: "\\mitvartheta" }, "𝜘": { math: "\\mitvarkappa" }, "𝜙": { math: "\\mitphi" }, "𝜚": { math: "\\mitvarrho" }, "𝜛": { math: "\\mitvarpi" }, "𝜜": { math: "\\mbfitAlpha" }, "𝜝": { math: "\\mbfitBeta" }, "𝜞": { math: "\\mbfitGamma" }, "𝜟": { math: "\\mbfitDelta" }, "𝜠": { math: "\\mbfitEpsilon" }, "𝜡": { math: "\\mbfitZeta" }, "𝜢": { math: "\\mbfitEta" }, "𝜣": { math: "\\mbfitTheta" }, "𝜤": { math: "\\mbfitIota" }, "𝜥": { math: "\\mbfitKappa" }, "𝜦": { math: "\\mbfitLambda" }, "𝜧": { math: "\\mbfitMu" }, "𝜨": { math: "\\mbfitNu" }, "𝜩": { math: "\\mbfitXi" }, "𝜪": { math: "\\mbfitOmicron" }, "𝜫": { math: "\\mbfitPi" }, "𝜬": { math: "\\mbfitRho" }, "𝜭": { math: "\\mbfitvarTheta" }, "𝜮": { math: "\\mbfitSigma" }, "𝜯": { math: "\\mbfitTau" }, "𝜰": { math: "\\mbfitUpsilon" }, "𝜱": { math: "\\mbfitPhi" }, "𝜲": { math: "\\mbfitChi" }, "𝜳": { math: "\\mbfitPsi" }, "𝜴": { math: "\\mbfitOmega" }, "𝜵": { math: "\\mbfitnabla" }, "𝜶": { math: "\\mbfitalpha" }, "𝜷": { math: "\\mbfitbeta" }, "𝜸": { math: "\\mbfitgamma" }, "𝜹": { math: "\\mbfitdelta" }, "𝜺": { math: "\\mbfitvarepsilon" }, "𝜻": { math: "\\mbfitzeta" }, "𝜼": { math: "\\mbfiteta" }, "𝜽": { math: "\\mbfittheta" }, "𝜾": { math: "\\mbfitiota" }, "𝜿": { math: "\\mbfitkappa" }, "𝝀": { math: "\\mbfitlambda" }, "𝝁": { math: "\\mbfitmu" }, "𝝂": { math: "\\mbfitnu" }, "𝝃": { math: "\\mbfitxi" }, "𝝄": { math: "\\mbfitomicron" }, "𝝅": { math: "\\mbfitpi" }, "𝝆": { math: "\\mbfitrho" }, "𝝇": { math: "\\mbfitvarsigma" }, "𝝈": { math: "\\mbfitsigma" }, "𝝉": { math: "\\mbfittau" }, "𝝊": { math: "\\mbfitupsilon" }, "𝝋": { math: "\\mbfitvarphi" }, "𝝌": { math: "\\mbfitchi" }, "𝝍": { math: "\\mbfitpsi" }, "𝝎": { math: "\\mbfitomega" }, "𝝏": { math: "\\mbfitpartial" }, "𝝐": { math: "\\mbfitepsilon" }, "𝝑": { math: "\\mbfitvartheta" }, "𝝒": { math: "\\mbfitvarkappa" }, "𝝓": { math: "\\mbfitphi" }, "𝝔": { math: "\\mbfitvarrho" }, "𝝕": { math: "\\mbfitvarpi" }, "𝝖": { math: "\\mbfsansAlpha" }, "𝝗": { math: "\\mbfsansBeta" }, "𝝘": { math: "\\mbfsansGamma" }, "𝝙": { math: "\\mbfsansDelta" }, "𝝚": { math: "\\mbfsansEpsilon" }, "𝝛": { math: "\\mbfsansZeta" }, "𝝜": { math: "\\mbfsansEta" }, "𝝝": { math: "\\mbfsansTheta" }, "𝝞": { math: "\\mbfsansIota" }, "𝝟": { math: "\\mbfsansKappa" }, "𝝠": { math: "\\mbfsansLambda" }, "𝝡": { math: "\\mbfsansMu" }, "𝝢": { math: "\\mbfsansNu" }, "𝝣": { math: "\\mbfsansXi" }, "𝝤": { math: "\\mbfsansOmicron" }, "𝝥": { math: "\\mbfsansPi" }, "𝝦": { math: "\\mbfsansRho" }, "𝝧": { math: "\\mbfsansvarTheta" }, "𝝨": { math: "\\mbfsansSigma" }, "𝝩": { math: "\\mbfsansTau" }, "𝝪": { math: "\\mbfsansUpsilon" }, "𝝫": { math: "\\mbfsansPhi" }, "𝝬": { math: "\\mbfsansChi" }, "𝝭": { math: "\\mbfsansPsi" }, "𝝮": { math: "\\mbfsansOmega" }, "𝝯": { math: "\\mbfsansnabla" }, "𝝰": { math: "\\mbfsansalpha" }, "𝝱": { math: "\\mbfsansbeta" }, "𝝲": { math: "\\mbfsansgamma" }, "𝝳": { math: "\\mbfsansdelta" }, "𝝴": { math: "\\mbfsansvarepsilon" }, "𝝵": { math: "\\mbfsanszeta" }, "𝝶": { math: "\\mbfsanseta" }, "𝝷": { math: "\\mbfsanstheta" }, "𝝸": { math: "\\mbfsansiota" }, "𝝹": { math: "\\mbfsanskappa" }, "𝝺": { math: "\\mbfsanslambda" }, "𝝻": { math: "\\mbfsansmu" }, "𝝼": { math: "\\mbfsansnu" }, "𝝽": { math: "\\mbfsansxi" }, "𝝾": { math: "\\mbfsansomicron" }, "𝝿": { math: "\\mbfsanspi" }, "𝞀": { math: "\\mbfsansrho" }, "𝞁": { math: "\\mbfsansvarsigma" }, "𝞂": { math: "\\mbfsanssigma" }, "𝞃": { math: "\\mbfsanstau" }, "𝞄": { math: "\\mbfsansupsilon" }, "𝞅": { math: "\\mbfsansvarphi" }, "𝞆": { math: "\\mbfsanschi" }, "𝞇": { math: "\\mbfsanspsi" }, "𝞈": { math: "\\mbfsansomega" }, "𝞉": { math: "\\mbfsanspartial" }, "𝞊": { math: "\\mbfsansepsilon" }, "𝞋": { math: "\\mbfsansvartheta" }, "𝞌": { math: "\\mbfsansvarkappa" }, "𝞍": { math: "\\mbfsansphi" }, "𝞎": { math: "\\mbfsansvarrho" }, "𝞏": { math: "\\mbfsansvarpi" }, "𝞐": { math: "\\mbfitsansAlpha" }, "𝞑": { math: "\\mbfitsansBeta" }, "𝞒": { math: "\\mbfitsansGamma" }, "𝞓": { math: "\\mbfitsansDelta" }, "𝞔": { math: "\\mbfitsansEpsilon" }, "𝞕": { math: "\\mbfitsansZeta" }, "𝞖": { math: "\\mbfitsansEta" }, "𝞗": { math: "\\mbfitsansTheta" }, "𝞘": { math: "\\mbfitsansIota" }, "𝞙": { math: "\\mbfitsansKappa" }, "𝞚": { math: "\\mbfitsansLambda" }, "𝞛": { math: "\\mbfitsansMu" }, "𝞜": { math: "\\mbfitsansNu" }, "𝞝": { math: "\\mbfitsansXi" }, "𝞞": { math: "\\mbfitsansOmicron" }, "𝞟": { math: "\\mbfitsansPi" }, "𝞠": { math: "\\mbfitsansRho" }, "𝞡": { math: "\\mbfitsansvarTheta" }, "𝞢": { math: "\\mbfitsansSigma" }, "𝞣": { math: "\\mbfitsansTau" }, "𝞤": { math: "\\mbfitsansUpsilon" }, "𝞥": { math: "\\mbfitsansPhi" }, "𝞦": { math: "\\mbfitsansChi" }, "𝞧": { math: "\\mbfitsansPsi" }, "𝞨": { math: "\\mbfitsansOmega" }, "𝞩": { math: "\\mbfitsansnabla" }, "𝞪": { math: "\\mbfitsansalpha" }, "𝞫": { math: "\\mbfitsansbeta" }, "𝞬": { math: "\\mbfitsansgamma" }, "𝞭": { math: "\\mbfitsansdelta" }, "𝞮": { math: "\\mbfitsansvarepsilon" }, "𝞯": { math: "\\mbfitsanszeta" }, "𝞰": { math: "\\mbfitsanseta" }, "𝞱": { math: "\\mbfitsanstheta" }, "𝞲": { math: "\\mbfitsansiota" }, "𝞳": { math: "\\mbfitsanskappa" }, "𝞴": { math: "\\mbfitsanslambda" }, "𝞵": { math: "\\mbfitsansmu" }, "𝞶": { math: "\\mbfitsansnu" }, "𝞷": { math: "\\mbfitsansxi" }, "𝞸": { math: "\\mbfitsansomicron" }, "𝞹": { math: "\\mbfitsanspi" }, "𝞺": { math: "\\mbfitsansrho" }, "𝞻": { math: "\\mbfitsansvarsigma" }, "𝞼": { math: "\\mbfitsanssigma" }, "𝞽": { math: "\\mbfitsanstau" }, "𝞾": { math: "\\mbfitsansupsilon" }, "𝞿": { math: "\\mbfitsansvarphi" }, "𝟀": { math: "\\mbfitsanschi" }, "𝟁": { math: "\\mbfitsanspsi" }, "𝟂": { math: "\\mbfitsansomega" }, "𝟃": { math: "\\mbfitsanspartial" }, "𝟄": { math: "\\mbfitsansepsilon" }, "𝟅": { math: "\\mbfitsansvartheta" }, "𝟆": { math: "\\mbfitsansvarkappa" }, "𝟇": { math: "\\mbfitsansphi" }, "𝟈": { math: "\\mbfitsansvarrho" }, "𝟉": { math: "\\mbfitsansvarpi" }, "𝟊": { math: "\\mbfDigamma" }, "𝟋": { math: "\\mbfdigamma" }, "𝟎": { math: "\\mbfzero" }, "𝟏": { math: "\\mbfone" }, "𝟐": { math: "\\mbftwo" }, "𝟑": { math: "\\mbfthree" }, "𝟒": { math: "\\mbffour" }, "𝟓": { math: "\\mbffive" }, "𝟔": { math: "\\mbfsix" }, "𝟕": { math: "\\mbfseven" }, "𝟖": { math: "\\mbfeight" }, "𝟗": { math: "\\mbfnine" }, "𝟘": { math: "\\Bbbzero" }, "𝟙": { math: "\\Bbbone" }, "𝟚": { math: "\\Bbbtwo" }, "𝟛": { math: "\\Bbbthree" }, "𝟜": { math: "\\Bbbfour" }, "𝟝": { math: "\\Bbbfive" }, "𝟞": { math: "\\Bbbsix" }, "𝟟": { math: "\\Bbbseven" }, "𝟠": { math: "\\Bbbeight" }, "𝟡": { math: "\\Bbbnine" }, "𝟢": { math: "\\msanszero" }, "𝟣": { math: "\\msansone" }, "𝟤": { math: "\\msanstwo" }, "𝟥": { math: "\\msansthree" }, "𝟦": { math: "\\msansfour" }, "𝟧": { math: "\\msansfive" }, "𝟨": { math: "\\msanssix" }, "𝟩": { math: "\\msansseven" }, "𝟪": { math: "\\msanseight" }, "𝟫": { math: "\\msansnine" }, "𝟬": { math: "\\mbfsanszero" }, "𝟭": { math: "\\mbfsansone" }, "𝟮": { math: "\\mbfsanstwo" }, "𝟯": { math: "\\mbfsansthree" }, "𝟰": { math: "\\mbfsansfour" }, "𝟱": { math: "\\mbfsansfive" }, "𝟲": { math: "\\mbfsanssix" }, "𝟳": { math: "\\mbfsansseven" }, "𝟴": { math: "\\mbfsanseight" }, "𝟵": { math: "\\mbfsansnine" }, "𝟶": { math: "\\mttzero" }, "𝟷": { math: "\\mttone" }, "𝟸": { math: "\\mtttwo" }, "𝟹": { math: "\\mttthree" }, "𝟺": { math: "\\mttfour" }, "𝟻": { math: "\\mttfive" }, "𝟼": { math: "\\mttsix" }, "𝟽": { math: "\\mttseven" }, "𝟾": { math: "\\mtteight" }, "𝟿": { math: "\\mttnine" }, ữ0: { math: "\\arabicmaj" }, ữ1: { math: "\\arabichad" }, "‐": { math: "\\mathhyphen" }, "―": { math: "\\horizbar" }, "‗": { math: "\\twolowline" }, "‥": { math: "\\enleadertwodots" }, "″": { math: "\\dprime" }, "‴": { math: "\\trprime" }, "‵": { math: "\\backprime" }, "‶": { math: "\\backdprime" }, "‷": { math: "\\backtrprime" }, "‸": { math: "\\caretinsert" }, "‼": { math: "\\Exclam" }, "⁀": { math: "\\tieconcat" }, "⁃": { math: "\\hyphenbullet" }, "⁄": { math: "\\fracslash" }, "⁇": { math: "\\Question" }, "⁐": { math: "\\closure" }, "⁗": { math: "\\qprime" }, "⃒": { math: "\\vertoverlay" }, "⃗": { math: "\\vec" }, "⃛": { math: "\\dddot" }, "⃜": { math: "\\ddddot" }, "⃝": { math: "\\enclosecircle" }, "⃞": { math: "\\enclosesquare" }, "⃟": { math: "\\enclosediamond" }, "⃡": { math: "\\overleftrightarrow" }, "⃤": { math: "\\enclosetriangle" }, "⃧": { math: "\\annuity" }, "⃨": { math: "\\threeunderdot" }, "⃩": { math: "\\widebridgeabove" }, "⃬": { math: "\\underrightharpoondown" }, "⃭": { math: "\\underleftharpoondown" }, "⃮": { math: "\\underleftarrow" }, "⃯": { math: "\\underrightarrow" }, "⃰": { math: "\\asteraccent" }, ℎ: { math: "\\Planckconst" }, ℏ: { math: "\\hslash" }, ℒ: { math: "\\mscrL" }, ℛ: { math: "\\mscrR" }, "℧": { math: "\\mho" }, "℩": { math: "\\turnediota" }, "Ⅎ": { math: "\\Finv" }, ℶ: { math: "\\beth" }, ℷ: { math: "\\gimel" }, ℸ: { math: "\\daleth" }, "⅁": { math: "\\Game" }, "⅂": { math: "\\sansLturned" }, "⅃": { math: "\\sansLmirrored" }, "⅄": { math: "\\Yup" }, "ⅅ": { math: "\\CapitalDifferentialD" }, "⅊": { math: "\\PropertyLine" }, "↚": { math: "\\nleftarrow" }, "↛": { math: "\\nrightarrow" }, "↞": { math: "\\twoheadleftarrow" }, "↟": { math: "\\twoheaduparrow" }, "↠": { math: "\\twoheadrightarrow" }, "↡": { math: "\\twoheaddownarrow" }, "↢": { math: "\\leftarrowtail" }, "↣": { math: "\\rightarrowtail" }, "↤": { math: "\\mapsfrom" }, "↥": { math: "\\mapsup" }, "↧": { math: "\\mapsdown" }, "↨": { math: "\\updownarrowbar" }, "↫": { math: "\\looparrowleft" }, "↬": { math: "\\looparrowright" }, "↭": { math: "\\leftrightsquigarrow" }, "↮": { math: "\\nleftrightarrow" }, "↰": { math: "\\Lsh" }, "↱": { math: "\\Rsh" }, "↳": { text: "\\reflectbox{\\carriagereturn}", math: "\\Rdsh" }, "↴": { math: "\\linefeed" }, "↵": { math: "\\carriagereturn" }, "↶": { math: "\\curvearrowleft" }, "↷": { math: "\\curvearrowright" }, "↸": { math: "\\barovernorthwestarrow" }, "↹": { math: "\\barleftarrowrightarrowbar" }, "↺": { math: "\\circlearrowleft" }, "↾": { math: "\\upharpoonright" }, "↿": { math: "\\upharpoonleft" }, "⇁": { math: "\\rightharpoondown" }, "⇂": { math: "\\downharpoonright" }, "⇃": { math: "\\downharpoonleft" }, "⇄": { math: "\\rightleftarrows" }, "⇆": { math: "\\leftrightarrows" }, "⇇": { math: "\\leftleftarrows" }, "⇈": { math: "\\upuparrows" }, "⇉": { math: "\\rightrightarrows" }, "⇊": { math: "\\downdownarrows" }, "⇋": { math: "\\leftrightharpoons" }, "⇍": { math: "\\nLeftarrow" }, "⇎": { math: "\\nLeftrightarrow" }, "⇏": { math: "\\nRightarrow" }, "⇖": { math: "\\Nwarrow" }, "⇗": { math: "\\Nearrow" }, "⇘": { math: "\\Searrow" }, "⇙": { math: "\\Swarrow" }, "⇚": { math: "\\Lleftarrow" }, "⇛": { math: "\\Rrightarrow" }, "⇜": { math: "\\leftsquigarrow" }, "⇝": { math: "\\rightsquigarrow" }, "⇞": { math: "\\nHuparrow" }, "⇟": { math: "\\nHdownarrow" }, "⇡": { math: "\\updasharrow" }, "⇣": { math: "\\downdasharrow" }, "⇦": { math: "\\leftwhitearrow" }, "⇧": { math: "\\upwhitearrow" }, "⇨": { math: "\\rightwhitearrow" }, "⇩": { math: "\\downwhitearrow" }, "⇪": { math: "\\whitearrowupfrombar" }, "⇴": { math: "\\circleonrightarrow" }, "⇶": { math: "\\rightthreearrows" }, "⇷": { math: "\\nvleftarrow" }, "⇹": { math: "\\nvleftrightarrow" }, "⇺": { math: "\\nVleftarrow" }, "⇼": { math: "\\nVleftrightarrow" }, "⇽": { math: "\\leftarrowtriangle" }, "⇾": { math: "\\rightarrowtriangle" }, "⇿": { math: "\\leftrightarrowtriangle" }, "∁": { math: "\\complement" }, "∄": { math: "\\nexists" }, "∅": { math: "\\varnothing" }, "∆": { math: "\\increment" }, "∇": { math: "\\nabla" }, "∊": { math: "\\smallin" }, "∍": { math: "\\smallni" }, "∎": { math: "\\QED" }, "∔": { math: "\\dotplus" }, "∕": { math: "\\divslash" }, "√": { math: "\\sqrt" }, "∟": { math: "\\rightangle" }, "∡": { math: "\\measuredangle" }, "∢": { math: "\\sphericalangle" }, "∤": { math: "\\nmid" }, "∦": { math: "\\nparallel" }, "∲": { math: "\\lcirclerightint" }, "∴": { math: "\\therefore" }, "∵": { math: "\\because" }, "∷": { math: "\\Colon" }, "∹": { math: "\\eqcolon" }, "∽": { math: "\\backsim" }, "≊": { math: "\\approxeq" }, "≎": { math: "\\Bumpeq" }, "≏": { math: "\\bumpeq" }, "≒": { math: "\\fallingdotseq" }, "≓": { math: "\\risingdotseq" }, "≔": { math: "\\coloneq" }, "≖": { math: "\\eqcirc" }, "≗": { math: "\\circeq" }, "≘": { math: "\\arceq" }, "≚": { math: "\\veeeq" }, "≜": { math: "\\triangleq" }, "≝": { math: "\\eqdef" }, "≞": { math: "\\measeq" }, "≟": { math: "\\questeq" }, "≣": { math: "\\Equiv" }, "≨": { math: "\\lneqq" }, "≩": { math: "\\gneqq" }, "≬": { math: "\\between" }, "≭": { math: "\\nasymp" }, "≴": { math: "\\nlesssim" }, "≵": { math: "\\ngtrsim" }, "≶": { math: "\\lessgtr" }, "≷": { math: "\\gtrless" }, "≼": { math: "\\preccurlyeq" }, "≽": { math: "\\succcurlyeq" }, "⊊": { math: "\\subsetneq" }, "⊋": { math: "\\supsetneq" }, "⊌": { math: "\\cupleftarrow" }, "⊍": { math: "\\cupdot" }, "⊏": { math: "\\sqsubset" }, "⊐": { math: "\\sqsupset" }, "⊚": { math: "\\circledcirc" }, "⊛": { math: "\\circledast" }, "⊜": { math: "\\circledequal" }, "⊝": { math: "\\circleddash" }, "⊞": { math: "\\boxplus" }, "⊟": { math: "\\boxminus" }, "⊠": { math: "\\boxtimes" }, "⊡": { math: "\\boxdot" }, "⊦": { math: "\\assert" }, "⊩": { math: "\\Vdash" }, "⊪": { math: "\\Vvdash" }, "⊫": { math: "\\VDash" }, "⊬": { math: "\\nvdash" }, "⊭": { math: "\\nvDash" }, "⊮": { math: "\\nVdash" }, "⊯": { math: "\\nVDash" }, "⊰": { math: "\\prurel" }, "⊱": { math: "\\scurel" }, "⊲": { math: "\\vartriangleleft" }, "⊳": { math: "\\vartriangleright" }, "⊴": { math: "\\trianglelefteq" }, "⊵": { math: "\\trianglerighteq" }, "⊸": { math: "\\multimap" }, "⊺": { math: "\\intercal" }, "⊻": { math: "\\veebar" }, "⊼": { math: "\\barwedge" }, "⊽": { math: "\\barvee" }, "⊿": { math: "\\varlrtriangle" }, "⋇": { math: "\\divideontimes" }, "⋉": { math: "\\ltimes" }, "⋊": { math: "\\rtimes" }, "⋋": { math: "\\leftthreetimes" }, "⋌": { math: "\\rightthreetimes" }, "⋍": { math: "\\backsimeq" }, "⋎": { math: "\\curlyvee" }, "⋏": { math: "\\curlywedge" }, "⋐": { math: "\\Subset" }, "⋑": { math: "\\Supset" }, "⋒": { math: "\\Cap" }, "⋓": { math: "\\Cup" }, "⋔": { math: "\\pitchfork" }, "⋕": { math: "\\hash" }, "⋖": { math: "\\lessdot" }, "⋗": { math: "\\gtrdot" }, "⋚": { math: "\\lesseqgtr" }, "⋛": { math: "\\gtreqless" }, "⋜": { math: "\\eqless" }, "⋝": { math: "\\eqgtr" }, "⋞": { math: "\\curlyeqprec" }, "⋟": { math: "\\curlyeqsucc" }, "⋠": { math: "\\npreceq" }, "⋡": { math: "\\nsucceq" }, "⋤": { math: "\\sqsubsetneq" }, "⋥": { math: "\\sqsupsetneq" }, "⋦": { math: "\\lnsim" }, "⋧": { math: "\\gnsim" }, "⋨": { math: "\\precedesnotsimilar" }, "⋩": { math: "\\succnsim" }, "⋬": { math: "\\ntrianglelefteq" }, "⋭": { math: "\\ntrianglerighteq" }, "⋲": { math: "\\disin" }, "⋳": { math: "\\varisins" }, "⋴": { math: "\\isins" }, "⋵": { math: "\\isindot" }, "⋷": { math: "\\isinobar" }, "⋸": { math: "\\isinvb" }, "⋹": { math: "\\isinE" }, "⋺": { math: "\\nisd" }, "⋻": { math: "\\varnis" }, "⋼": { math: "\\nis" }, "⋽": { math: "\\varniobar" }, "⋾": { math: "\\niobar" }, "⋿": { math: "\\bagmember" }, "⌀": { math: "\\diameter" }, "⌂": { math: "\\house" }, "⌅": { text: "\\barwedge", math: "\\varbarwedge", macrospacer: true }, "⌐": { math: "\\invneg" }, "⌒": { math: "\\profline" }, "⌓": { math: "\\profsurf" }, "⌗": { math: "\\viewdata" }, "⌙": { math: "\\turnednot" }, "⌜": { math: "\\ulcorner" }, "⌝": { math: "\\urcorner" }, "⌞": { math: "\\llcorner" }, "⌟": { math: "\\lrcorner" }, "⌠": { math: "\\inttop" }, "⌡": { math: "\\intbottom" }, "⌬": { math: "\\varhexagonlrbonds" }, "⌲": { math: "\\conictaper" }, "⌶": { math: "\\topbot" }, "⌽": { math: "\\obar" }, "⍓": { math: "\\APLboxupcaret" }, "⍰": { math: "\\APLboxquestion" }, "⍼": { math: "\\rangledownzigzagarrow" }, "⎔": { math: "\\hexagon" }, "⎛": { math: "\\lparenuend" }, "⎜": { math: "\\lparenextender" }, "⎝": { math: "\\lparenlend" }, "⎞": { math: "\\rparenuend" }, "⎟": { math: "\\rparenextender" }, "⎠": { math: "\\rparenlend" }, "⎡": { math: "\\lbrackuend" }, "⎢": { math: "\\lbrackextender" }, "⎣": { math: "\\lbracklend" }, "⎤": { math: "\\rbrackuend" }, "⎥": { math: "\\rbrackextender" }, "⎦": { math: "\\rbracklend" }, "⎧": { math: "\\lbraceuend" }, "⎨": { math: "\\lbracemid" }, "⎩": { math: "\\lbracelend" }, "⎪": { math: "\\vbraceextender" }, "⎫": { math: "\\rbraceuend" }, "⎬": { math: "\\rbracemid" }, "⎭": { math: "\\rbracelend" }, "⎮": { math: "\\intextender" }, "⎯": { math: "\\harrowextender" }, "⎲": { math: "\\sumtop" }, "⎳": { math: "\\sumbottom" }, "⎴": { math: "\\overbracket" }, "⎵": { math: "\\underbracket" }, "⎶": { math: "\\bbrktbrk" }, "⎷": { math: "\\sqrtbottom" }, "⎸": { math: "\\lvboxline" }, "⎹": { math: "\\rvboxline" }, "⏎": { math: "\\varcarriagereturn" }, "⏜": { math: "\\overparen" }, "⏝": { math: "\\underparen" }, "⏞": { math: "\\overbrace" }, "⏟": { math: "\\underbrace" }, "⏠": { math: "\\obrbrak" }, "⏡": { math: "\\ubrbrak" }, "⏢": { math: "\\trapezium" }, "⏣": { math: "\\benzenr" }, "⏤": { math: "\\strns" }, "⏥": { math: "\\fltns" }, "⏦": { math: "\\accurrent" }, "⏧": { math: "\\elinters" }, "␢": { math: "\\blanksymbol" }, "␣": { math: "\\mathvisiblespace" }, "┆": { math: "\\bdtriplevdash" }, "▀": { math: "\\blockuphalf" }, "▄": { math: "\\blocklowhalf" }, "█": { math: "\\blockfull" }, "▌": { math: "\\blocklefthalf" }, "▐": { math: "\\blockrighthalf" }, "░": { math: "\\blockqtrshaded" }, "▒": { math: "\\blockhalfshaded" }, "▓": { math: "\\blockthreeqtrshaded" }, "■": { math: "\\mdlgblksquare" }, "▢": { math: "\\squoval" }, "▣": { math: "\\blackinwhitesquare" }, "▤": { math: "\\squarehfill" }, "▥": { math: "\\squarevfill" }, "▦": { math: "\\squarehvfill" }, "▧": { math: "\\squarenwsefill" }, "▨": { math: "\\squareneswfill" }, "▩": { math: "\\squarecrossfill" }, "▪": { math: "\\smblksquare" }, "▫": { math: "\\smwhtsquare" }, "▬": { math: "\\hrectangleblack" }, "▭": { math: "\\hrectangle" }, "▮": { math: "\\vrectangleblack" }, "▯": { math: "\\vrectangle" }, "▰": { math: "\\parallelogramblack" }, "▱": { math: "\\parallelogram" }, "▲": { math: "\\bigblacktriangleup" }, "△": { math: "\\bigtriangleup" }, "▴": { math: "\\blacktriangle" }, "▵": { math: "\\vartriangle" }, "▸": { math: "\\smallblacktriangleright" }, "▹": { math: "\\smalltriangleright" }, "►": { math: "\\blackpointerright" }, "▻": { math: "\\whitepointerright" }, "▼": { math: "\\bigblacktriangledown" }, "▾": { math: "\\blacktriangledown" }, "▿": { math: "\\triangledown" }, "◂": { math: "\\smallblacktriangleleft" }, "◃": { math: "\\smalltriangleleft" }, "◄": { math: "\\blackpointerleft" }, "◅": { math: "\\whitepointerleft" }, "◈": { math: "\\blackinwhitediamond" }, "◉": { math: "\\fisheye" }, "◊": { math: "\\lozenge" }, "◌": { math: "\\dottedcircle" }, "◍": { math: "\\circlevertfill" }, "◎": { math: "\\bullseye" }, "◐": { math: "\\circlelefthalfblack" }, "◑": { math: "\\circlerighthalfblack" }, "◒": { math: "\\circlebottomhalfblack" }, "◓": { math: "\\circletophalfblack" }, "◔": { math: "\\circleurquadblack" }, "◕": { math: "\\blackcircleulquadwhite" }, "◖": { math: "\\blacklefthalfcircle" }, "◗": { math: "\\blackrighthalfcircle" }, "◘": { math: "\\inversebullet" }, "◙": { math: "\\inversewhitecircle" }, "◚": { math: "\\invwhiteupperhalfcircle" }, "◛": { math: "\\invwhitelowerhalfcircle" }, "◜": { math: "\\ularc" }, "◝": { math: "\\urarc" }, "◞": { math: "\\lrarc" }, "◟": { math: "\\llarc" }, "◠": { math: "\\topsemicircle" }, "◡": { math: "\\botsemicircle" }, "◢": { math: "\\lrblacktriangle" }, "◣": { math: "\\llblacktriangle" }, "◤": { math: "\\ulblacktriangle" }, "◥": { math: "\\urblacktriangle" }, "◦": { math: "\\smwhtcircle" }, "◧": { math: "\\squareleftblack" }, "◨": { math: "\\squarerightblack" }, "◩": { math: "\\squareulblack" }, "◪": { math: "\\squarelrblack" }, "◫": { math: "\\boxbar" }, "◬": { math: "\\trianglecdot" }, "◭": { math: "\\triangleleftblack" }, "◮": { math: "\\trianglerightblack" }, "◰": { math: "\\squareulquad" }, "◱": { math: "\\squarellquad" }, "◲": { math: "\\squarelrquad" }, "◳": { math: "\\squareurquad" }, "◴": { math: "\\circleulquad" }, "◵": { math: "\\circlellquad" }, "◶": { math: "\\circlelrquad" }, "◷": { math: "\\circleurquad" }, "◸": { math: "\\ultriangle" }, "◹": { math: "\\urtriangle" }, "◺": { math: "\\lltriangle" }, "◻": { math: "\\mdwhtsquare" }, "◼": { math: "\\mdblksquare" }, "◽": { math: "\\mdsmwhtsquare" }, "◾": { math: "\\mdsmblksquare" }, "◿": { math: "\\lrtriangle" }, "★": { math: "\\bigstar" }, "☆": { math: "\\bigwhitestar" }, "☡": { math: "\\danger" }, "☻": { math: "\\blacksmiley" }, "☼": { math: "\\sun" }, "☽": { math: "\\rightmoon" }, "☾": { math: "\\leftmoon" }, "♀": { math: "\\female" }, "♂": { math: "\\male" }, "♤": { math: "\\varspadesuit" }, "♥": { math: "\\varheartsuit" }, "♦": { math: "\\vardiamondsuit" }, "♧": { math: "\\varclubsuit" }, "♩": { math: "\\quarternote" }, "♪": { math: "\\eighthnote" }, "♫": { math: "\\twonotes" }, "♬": { math: "\\sixteenthnote" }, "♾": { math: "\\acidfree" }, "⚀": { math: "\\dicei" }, "⚁": { math: "\\diceii" }, "⚂": { math: "\\diceiii" }, "⚃": { math: "\\diceiv" }, "⚄": { math: "\\dicev" }, "⚅": { math: "\\dicevi" }, "⚆": { math: "\\circledrightdot" }, "⚇": { math: "\\circledtwodots" }, "⚈": { math: "\\blackcircledrightdot" }, "⚉": { math: "\\blackcircledtwodots" }, "⚥": { math: "\\Hermaphrodite" }, "⚬": { math: "\\mdsmwhtcircle" }, "⚲": { math: "\\neuter" }, "✓": { math: "\\checkmark" }, "✠": { math: "\\maltese" }, "✪": { math: "\\circledstar" }, "✶": { math: "\\varstar" }, "✽": { math: "\\dingasterisk" }, "❲": { math: "\\lbrbrak" }, "❳": { math: "\\rbrbrak" }, "➛": { math: "\\draftingarrow" }, "⟀": { math: "\\threedangle" }, "⟁": { math: "\\whiteinwhitetriangle" }, "⟃": { math: "\\subsetcirc" }, "⟄": { math: "\\supsetcirc" }, "⟇": { math: "\\veedot" }, "⟈": { math: "\\bsolhsub" }, "⟉": { math: "\\suphsol" }, "⟋": { math: "\\diagup" }, "⟌": { math: "\\longdivision" }, "⟍": { math: "\\diagdown" }, "⟑": { math: "\\wedgedot" }, "⟒": { math: "\\upin" }, "⟓": { math: "\\pullback" }, "⟔": { math: "\\pushout" }, "⟕": { math: "\\leftouterjoin" }, "⟖": { math: "\\rightouterjoin" }, "⟗": { math: "\\fullouterjoin" }, "⟘": { math: "\\bigbot" }, "⟙": { math: "\\bigtop" }, "⟚": { math: "\\DashVDash" }, "⟛": { math: "\\dashVdash" }, "⟜": { math: "\\multimapinv" }, "⟝": { math: "\\vlongdash" }, "⟞": { math: "\\longdashv" }, "⟟": { math: "\\cirbot" }, "⟠": { math: "\\lozengeminus" }, "⟡": { math: "\\concavediamond" }, "⟢": { math: "\\concavediamondtickleft" }, "⟣": { math: "\\concavediamondtickright" }, "⟤": { math: "\\whitesquaretickleft" }, "⟥": { math: "\\whitesquaretickright" }, "⟫": { math: "\\rang" }, "⟬": { math: "\\Lbrbrak" }, "⟭": { math: "\\Rbrbrak" }, "⟰": { math: "\\UUparrow" }, "⟱": { math: "\\DDownarrow" }, "⟲": { math: "\\acwgapcirclearrow" }, "⟳": { math: "\\cwgapcirclearrow" }, "⟴": { math: "\\rightarrowonoplus" }, "⟻": { math: "\\longmapsfrom" }, "⟽": { math: "\\Longmapsfrom" }, "⟾": { math: "\\Longmapsto" }, "⟿": { math: "\\longrightsquigarrow" }, "⤁": { math: "\\nVtwoheadrightarrow" }, "⤂": { math: "\\nvLeftarrow" }, "⤃": { math: "\\nvRightarrow" }, "⤄": { math: "\\nvLeftrightarrow" }, "⤅": { math: "\\twoheadmapsto" }, "⤆": { math: "\\Mapsfrom" }, "⤇": { math: "\\Mapsto" }, "⤈": { math: "\\downarrowbarred" }, "⤉": { math: "\\uparrowbarred" }, "⤊": { math: "\\Uuparrow" }, "⤋": { math: "\\Ddownarrow" }, "⤌": { math: "\\leftbkarrow" }, "⤍": { math: "\\rightbkarrow" }, "⤎": { math: "\\leftdbkarrow" }, "⤏": { math: "\\dbkarrow" }, "⤐": { math: "\\drbkarrow" }, "⤑": { math: "\\rightdotarrow" }, "⤗": { math: "\\nvtwoheadrightarrowtail" }, "⤘": { math: "\\nVtwoheadrightarrowtail" }, "⤙": { math: "\\lefttail" }, "⤚": { math: "\\righttail" }, "⤛": { math: "\\leftdbltail" }, "⤜": { math: "\\rightdbltail" }, "⤝": { math: "\\diamondleftarrow" }, "⤞": { math: "\\rightarrowdiamond" }, "⤟": { math: "\\diamondleftarrowbar" }, "⤠": { math: "\\barrightarrowdiamond" }, "⤡": { math: "\\nwsearrow" }, "⤢": { math: "\\neswarrow" }, "⤣": { math: "\\hknwarrow" }, "⤤": { math: "\\hknearrow" }, "⤥": { math: "\\hksearrow" }, "⤦": { math: "\\hkswarrow" }, "⤧": { math: "\\tona" }, "⤨": { math: "\\toea" }, "⤩": { math: "\\tosa" }, "⤪": { math: "\\towa" }, "⤫": { math: "\\rdiagovfdiag" }, "⤬": { math: "\\fdiagovrdiag" }, "⤭": { math: "\\seovnearrow" }, "⤮": { math: "\\neovsearrow" }, "⤯": { math: "\\fdiagovnearrow" }, "⤰": { math: "\\rdiagovsearrow" }, "⤱": { math: "\\neovnwarrow" }, "⤲": { math: "\\nwovnearrow" }, "⤳": { math: "\\rightcurvedarrow" }, "⤴": { math: "\\uprightcurvearrow" }, "⤵": { math: "\\downrightcurvedarrow" }, "⤶": { math: "\\leftdowncurvedarrow" }, "⤷": { math: "\\rightdowncurvedarrow" }, "⤸": { math: "\\cwrightarcarrow" }, "⤹": { math: "\\acwleftarcarrow" }, "⤺": { math: "\\acwoverarcarrow" }, "⤻": { math: "\\acwunderarcarrow" }, "⤼": { math: "\\curvearrowrightminus" }, "⤽": { math: "\\curvearrowleftplus" }, "⤾": { math: "\\cwundercurvearrow" }, "⤿": { math: "\\ccwundercurvearrow" }, "⥂": { math: "\\rightarrowshortleftarrow" }, "⥃": { math: "\\leftarrowshortrightarrow" }, "⥄": { math: "\\shortrightarrowleftarrow" }, "⥅": { math: "\\rightarrowplus" }, "⥆": { math: "\\leftarrowplus" }, "⥇": { math: "\\rightarrowx" }, "⥈": { math: "\\leftrightarrowcircle" }, "⥉": { math: "\\twoheaduparrowcircle" }, "⥌": { math: "\\updownharpoonrightleft" }, "⥍": { math: "\\updownharpoonleftright" }, "⥎": { math: "\\leftrightharpoonupup" }, "⥐": { math: "\\DownLeftRightVector" }, "⥦": { math: "\\leftrightharpoonsup" }, "⥧": { math: "\\leftrightharpoonsdown" }, "⥨": { math: "\\rightleftharpoonsup" }, "⥩": { math: "\\rightleftharpoonsdown" }, "⥱": { math: "\\equalrightarrow" }, "⥲": { math: "\\similarrightarrow" }, "⥳": { math: "\\leftarrowsimilar" }, "⥴": { math: "\\rightarrowsimilar" }, "⥵": { math: "\\rightarrowapprox" }, "⥶": { math: "\\ltlarr" }, "⥷": { math: "\\leftarrowless" }, "⥸": { math: "\\gtrarr" }, "⥹": { math: "\\subrarr" }, "⥺": { math: "\\leftarrowsubset" }, "⥻": { math: "\\suplarr" }, "⥼": { math: "\\leftfishtail" }, "⥽": { math: "\\rightfishtail" }, "⥾": { math: "\\upfishtail" }, "⥿": { math: "\\downfishtail" }, "⦀": { math: "\\Vvert" }, "⦁": { math: "\\spot" }, "⦂": { math: "\\typecolon" }, "⦃": { math: "\\lBrace" }, "⦄": { math: "\\rBrace" }, "⦅": { math: "\\lParen" }, "⦆": { math: "\\Elroang" }, "⦇": { math: "\\limg" }, "⦋": { math: "\\lbrackubar" }, "⦌": { math: "\\rbrackubar" }, "⦍": { math: "\\lbrackultick" }, "⦎": { math: "\\rbracklrtick" }, "⦏": { math: "\\lbracklltick" }, "⦐": { math: "\\rbrackurtick" }, "⦑": { math: "\\langledot" }, "⦒": { math: "\\rangledot" }, "⦓": { math: "\\lparenless" }, "⦔": { math: "\\rparengtr" }, "⦕": { math: "\\Lparengtr" }, "⦖": { math: "\\Rparenless" }, "⦗": { math: "\\lblkbrbrak" }, "⦘": { math: "\\rblkbrbrak" }, "⦙": { math: "\\fourvdots" }, "⦚": { math: "\\vzigzag" }, "⦛": { math: "\\measuredangleleft" }, "⦝": { math: "\\rightanglemdot" }, "⦞": { math: "\\angles" }, "⦟": { math: "\\angdnr" }, "⦠": { math: "\\gtlpar" }, "⦡": { math: "\\sphericalangleup" }, "⦢": { math: "\\turnangle" }, "⦣": { math: "\\revangle" }, "⦤": { math: "\\angleubar" }, "⦥": { math: "\\revangleubar" }, "⦦": { math: "\\wideangledown" }, "⦧": { math: "\\wideangleup" }, "⦨": { math: "\\measanglerutone" }, "⦩": { math: "\\measanglelutonw" }, "⦪": { math: "\\measanglerdtose" }, "⦫": { math: "\\measangleldtosw" }, "⦬": { math: "\\measangleurtone" }, "⦭": { math: "\\measangleultonw" }, "⦮": { math: "\\measangledrtose" }, "⦯": { math: "\\measangledltosw" }, "⦰": { math: "\\revemptyset" }, "⦱": { math: "\\emptysetobar" }, "⦲": { math: "\\emptysetocirc" }, "⦳": { math: "\\emptysetoarr" }, "⦴": { math: "\\emptysetoarrl" }, "⦵": { math: "\\circlehbar" }, "⦶": { math: "\\circledvert" }, "⦷": { math: "\\circledparallel" }, "⦸": { math: "\\circledbslash" }, "⦹": { math: "\\operp" }, "⦺": { math: "\\obot" }, "⦻": { math: "\\olcross" }, "⦼": { math: "\\odotslashdot" }, "⦽": { math: "\\uparrowoncircle" }, "⦾": { math: "\\circledwhitebullet" }, "⦿": { math: "\\circledbullet" }, "⧀": { math: "\\circledless" }, "⧁": { math: "\\circledgtr" }, "⧂": { math: "\\cirscir" }, "⧃": { math: "\\cirE" }, "⧅": { math: "\\boxbslash" }, "⧆": { math: "\\boxast" }, "⧇": { math: "\\boxcircle" }, "⧈": { math: "\\boxbox" }, "⧉": { math: "\\boxonbox" }, "⧊": { math: "\\triangleodot" }, "⧋": { math: "\\triangleubar" }, "⧌": { math: "\\triangles" }, "⧍": { math: "\\triangleserifs" }, "⧎": { math: "\\rtriltri" }, "⧑": { math: "\\lfbowtie" }, "⧒": { math: "\\rfbowtie" }, "⧓": { math: "\\fbowtie" }, "⧔": { math: "\\lftimes" }, "⧕": { math: "\\rftimes" }, "⧖": { math: "\\hourglass" }, "⧗": { math: "\\blackhourglass" }, "⧘": { math: "\\lvzigzag" }, "⧙": { math: "\\rvzigzag" }, "⧚": { math: "\\Lvzigzag" }, "⧛": { math: "\\Rvzigzag" }, "⧜": { math: "\\iinfin" }, "⧝": { math: "\\tieinfty" }, "⧞": { math: "\\nvinfty" }, "⧠": { math: "\\laplac" }, "⧡": { math: "\\lrtriangleeq" }, "⧢": { math: "\\shuffle" }, "⧣": { math: "\\eparsl" }, "⧤": { math: "\\smeparsl" }, "⧥": { math: "\\eqvparsl" }, "⧦": { math: "\\gleichstark" }, "⧧": { math: "\\thermod" }, "⧨": { math: "\\downtriangleleftblack" }, "⧩": { math: "\\downtrianglerightblack" }, "⧪": { math: "\\blackdiamonddownarrow" }, "⧫": { math: "\\blacklozenge" }, "⧬": { math: "\\circledownarrow" }, "⧭": { math: "\\blackcircledownarrow" }, "⧮": { math: "\\errbarsquare" }, "⧯": { math: "\\errbarblacksquare" }, "⧰": { math: "\\errbardiamond" }, "⧱": { math: "\\errbarblackdiamond" }, "⧲": { math: "\\errbarcircle" }, "⧳": { math: "\\errbarblackcircle" }, "⧴": { math: "\\RuleDelayed" }, "⧶": { math: "\\dsol" }, "⧷": { math: "\\rsolbar" }, "⧸": { math: "\\xsol" }, "⧺": { math: "\\doubleplus" }, "⧻": { math: "\\tripleplus" }, "⧼": { math: "\\lcurvyangle" }, "⧽": { math: "\\rcurvyangle" }, "⧾": { math: "\\tplus" }, "⧿": { math: "\\tminus" }, "⨃": { math: "\\bigcupdot" }, "⨄": { math: "\\Elxuplus" }, "⨅": { math: "\\bigsqcap" }, "⨇": { math: "\\conjquant" }, "⨈": { math: "\\disjquant" }, "⨊": { math: "\\modtwosum" }, "⨋": { math: "\\sumint" }, "⨌": { math: "\\iiiint" }, "⨍": { math: "\\intbar" }, "⨎": { math: "\\intBar" }, "⨐": { math: "\\cirfnint" }, "⨑": { math: "\\awint" }, "⨒": { math: "\\rppolint" }, "⨓": { math: "\\scpolint" }, "⨔": { math: "\\npolint" }, "⨕": { math: "\\pointint" }, "⨗": { math: "\\intlarhk" }, "⨘": { math: "\\intx" }, "⨙": { math: "\\intcap" }, "⨚": { math: "\\intcup" }, "⨛": { math: "\\upint" }, "⨜": { math: "\\lowint" }, "⨝": { math: "\\Join" }, "⨞": { math: "\\bigtriangleleft" }, "⨟": { math: "\\zcmp" }, "⨠": { math: "\\zpipe" }, "⨡": { math: "\\zproject" }, "⨢": { math: "\\ringplus" }, "⨣": { math: "\\plushat" }, "⨤": { math: "\\simplus" }, "⨥": { math: "\\plusdot" }, "⨦": { math: "\\plussim" }, "⨧": { math: "\\plussubtwo" }, "⨨": { math: "\\plustrif" }, "⨩": { math: "\\commaminus" }, "⨪": { math: "\\minusdot" }, "⨫": { math: "\\minusfdots" }, "⨬": { math: "\\minusrdots" }, "⨭": { math: "\\opluslhrim" }, "⨮": { math: "\\oplusrhrim" }, "⨯": { math: "\\vectimes" }, "⨰": { math: "\\dottimes" }, "⨱": { math: "\\timesbar" }, "⨲": { math: "\\btimes" }, "⨳": { math: "\\smashtimes" }, "⨴": { math: "\\otimeslhrim" }, "⨵": { math: "\\otimesrhrim" }, "⨶": { math: "\\otimeshat" }, "⨷": { math: "\\Otimes" }, "⨸": { math: "\\odiv" }, "⨹": { math: "\\triangleplus" }, "⨺": { math: "\\triangleminus" }, "⨻": { math: "\\triangletimes" }, "⨼": { math: "\\intprod" }, "⨽": { math: "\\intprodr" }, "⨾": { math: "\\fcmp" }, "⩀": { math: "\\capdot" }, "⩁": { math: "\\uminus" }, "⩂": { math: "\\barcup" }, "⩃": { math: "\\barcap" }, "⩄": { math: "\\capwedge" }, "⩅": { math: "\\cupvee" }, "⩆": { math: "\\cupovercap" }, "⩇": { math: "\\capovercup" }, "⩈": { math: "\\cupbarcap" }, "⩉": { math: "\\capbarcup" }, "⩊": { math: "\\twocups" }, "⩋": { math: "\\twocaps" }, "⩌": { math: "\\closedvarcup" }, "⩍": { math: "\\closedvarcap" }, "⩎": { math: "\\Sqcap" }, "⩏": { math: "\\Sqcup" }, "⩐": { math: "\\closedvarcupsmashprod" }, "⩑": { math: "\\wedgeodot" }, "⩒": { math: "\\veeodot" }, "⩓": { math: "\\Wedge" }, "⩔": { math: "\\Vee" }, "⩕": { math: "\\wedgeonwedge" }, "⩗": { math: "\\bigslopedvee" }, "⩘": { math: "\\bigslopedwedge" }, "⩙": { math: "\\veeonwedge" }, "⩚": { math: "\\wedgemidvert" }, "⩛": { math: "\\veemidvert" }, "⩜": { math: "\\midbarwedge" }, "⩝": { math: "\\midbarvee" }, "⩟": { math: "\\wedgebar" }, "⩠": { math: "\\wedgedoublebar" }, "⩡": { math: "\\varveebar" }, "⩢": { math: "\\doublebarvee" }, "⩣": { math: "\\veedoublebar" }, "⩤": { math: "\\dsub" }, "⩥": { math: "\\rsub" }, "⩦": { math: "\\eqdot" }, "⩧": { math: "\\dotequiv" }, "⩨": { math: "\\equivVert" }, "⩩": { math: "\\equivVvert" }, "⩪": { math: "\\dotsim" }, "⩫": { math: "\\simrdots" }, "⩬": { math: "\\simminussim" }, "⩭": { math: "\\congdot" }, "⩯": { math: "\\hatapprox" }, "⩰": { math: "\\approxeqq" }, "⩱": { math: "\\eqqplus" }, "⩲": { math: "\\pluseqq" }, "⩳": { math: "\\eqqsim" }, "⩴": { math: "\\Coloneqq" }, "⩷": { math: "\\ddotseq" }, "⩸": { math: "\\equivDD" }, "⩹": { math: "\\ltcir" }, "⩺": { math: "\\gtcir" }, "⩻": { math: "\\ltquest" }, "⩼": { math: "\\gtquest" }, "⩽": { math: "\\leqslant" }, "⩾": { math: "\\geqslant" }, "⩿": { math: "\\lesdot" }, "⪀": { math: "\\gesdot" }, "⪁": { math: "\\lesdoto" }, "⪂": { math: "\\gesdoto" }, "⪃": { math: "\\lesdotor" }, "⪄": { math: "\\gesdotol" }, "⪅": { math: "\\lessapprox" }, "⪆": { math: "\\gtrapprox" }, "⪇": { math: "\\lneq" }, "⪈": { math: "\\gneq" }, "⪉": { math: "\\lnapprox" }, "⪊": { math: "\\gnapprox" }, "⪋": { math: "\\lesseqqgtr" }, "⪌": { math: "\\gtreqqless" }, "⪍": { math: "\\lsime" }, "⪎": { math: "\\gsime" }, "⪏": { math: "\\lsimg" }, "⪐": { math: "\\gsiml" }, "⪑": { math: "\\lgE" }, "⪒": { math: "\\glE" }, "⪓": { math: "\\lesges" }, "⪔": { math: "\\gesles" }, "⪕": { math: "\\eqslantless" }, "⪖": { math: "\\eqslantgtr" }, "⪗": { math: "\\elsdot" }, "⪘": { math: "\\egsdot" }, "⪙": { math: "\\eqqless" }, "⪚": { math: "\\eqqgtr" }, "⪛": { math: "\\eqqslantless" }, "⪜": { math: "\\eqqslantgtr" }, "⪝": { math: "\\simless" }, "⪞": { math: "\\simgtr" }, "⪟": { math: "\\simlE" }, "⪠": { math: "\\simgE" }, "⪣": { math: "\\partialmeetcontraction" }, "⪤": { math: "\\glj" }, "⪥": { math: "\\gla" }, "⪨": { math: "\\lescc" }, "⪩": { math: "\\gescc" }, "⪪": { math: "\\smt" }, "⪫": { math: "\\lat" }, "⪬": { math: "\\smte" }, "⪭": { math: "\\late" }, "⪮": { math: "\\bumpeqq" }, "⪱": { math: "\\precneq" }, "⪲": { math: "\\succneq" }, "⪳": { math: "\\preceqq" }, "⪴": { math: "\\succeqq" }, "⪵": { math: "\\precneqq" }, "⪶": { math: "\\succneqq" }, "⪷": { math: "\\precapprox" }, "⪸": { math: "\\succapprox" }, "⪹": { math: "\\precnapprox" }, "⪺": { math: "\\succnapprox" }, "⪽": { math: "\\subsetdot" }, "⪾": { math: "\\supsetdot" }, "⪿": { math: "\\subsetplus" }, "⫀": { math: "\\supsetplus" }, "⫁": { math: "\\submult" }, "⫂": { math: "\\supmult" }, "⫃": { math: "\\subedot" }, "⫄": { math: "\\supedot" }, "⫅": { math: "\\subseteqq" }, "⫆": { math: "\\supseteqq" }, "⫇": { math: "\\subsim" }, "⫈": { math: "\\supsim" }, "⫉": { math: "\\subsetapprox" }, "⫊": { math: "\\supsetapprox" }, "⫋": { math: "\\subsetneqq" }, "⫌": { math: "\\supsetneqq" }, "⫍": { math: "\\lsqhook" }, "⫎": { math: "\\rsqhook" }, "⫏": { math: "\\csub" }, "⫐": { math: "\\csup" }, "⫑": { math: "\\csube" }, "⫒": { math: "\\csupe" }, "⫓": { math: "\\subsup" }, "⫔": { math: "\\supsub" }, "⫕": { math: "\\subsub" }, "⫖": { math: "\\supsup" }, "⫗": { math: "\\suphsub" }, "⫘": { math: "\\supdsub" }, "⫙": { math: "\\forkv" }, "⫚": { math: "\\topfork" }, "⫛": { math: "\\mlcp" }, "⫝̸": { math: "\\forks" }, "⫝": { math: "\\forksnot" }, "⫞": { math: "\\shortlefttack" }, "⫟": { math: "\\shortdowntack" }, "⫠": { math: "\\shortuptack" }, "⫡": { math: "\\perps" }, "⫢": { math: "\\vDdash" }, "⫣": { math: "\\dashV" }, "⫤": { math: "\\Dashv" }, "⫥": { math: "\\DashV" }, "⫦": { math: "\\varVdash" }, "⫧": { math: "\\Barv" }, "⫨": { math: "\\vBar" }, "⫩": { math: "\\vBarv" }, "⫫": { math: "\\Vbar" }, "⫬": { math: "\\Not" }, "⫭": { math: "\\bNot" }, "⫮": { math: "\\revnmid" }, "⫯": { math: "\\cirmid" }, "⫰": { math: "\\midcir" }, "⫱": { math: "\\topcir" }, "⫲": { math: "\\nhpar" }, "⫳": { math: "\\parsim" }, "⫴": { math: "\\interleave" }, "⫵": { math: "\\nhVvert" }, "⫶": { math: "\\threedotcolon" }, "⫷": { math: "\\lllnest" }, "⫸": { math: "\\gggnest" }, "⫹": { math: "\\leqqslant" }, "⫺": { math: "\\geqqslant" }, "⫻": { math: "\\trslash" }, "⫼": { math: "\\biginterleave" }, "⫾": { math: "\\talloblong" }, "⫿": { math: "\\bigtalloblong" }, "⬒": { math: "\\squaretopblack" }, "⬓": { math: "\\squarebotblack" }, "⬔": { math: "\\squareurblack" }, "⬕": { math: "\\squarellblack" }, "⬖": { math: "\\diamondleftblack" }, "⬗": { math: "\\diamondrightblack" }, "⬘": { math: "\\diamondtopblack" }, "⬙": { math: "\\diamondbotblack" }, "⬚": { math: "\\dottedsquare" }, "⬛": { math: "\\lgblksquare" }, "⬜": { math: "\\lgwhtsquare" }, "⬝": { math: "\\vysmblksquare" }, "⬞": { math: "\\vysmwhtsquare" }, "⬟": { math: "\\pentagonblack" }, "⬠": { math: "\\pentagon" }, "⬡": { math: "\\varhexagon" }, "⬢": { math: "\\varhexagonblack" }, "⬣": { math: "\\hexagonblack" }, "⬤": { math: "\\lgblkcircle" }, "⬥": { math: "\\mdblkdiamond" }, "⬦": { math: "\\mdwhtdiamond" }, "⬧": { math: "\\mdblklozenge" }, "⬨": { math: "\\mdwhtlozenge" }, "⬩": { math: "\\smblkdiamond" }, "⬪": { math: "\\smblklozenge" }, "⬫": { math: "\\smwhtlozenge" }, "⬬": { math: "\\blkhorzoval" }, "⬭": { math: "\\whthorzoval" }, "⬮": { math: "\\blkvertoval" }, "⬯": { math: "\\whtvertoval" }, "⬰": { math: "\\circleonleftarrow" }, "⬱": { math: "\\leftthreearrows" }, "⬲": { math: "\\leftarrowonoplus" }, "⬳": { math: "\\longleftsquigarrow" }, "⬴": { math: "\\nvtwoheadleftarrow" }, "⬵": { math: "\\nVtwoheadleftarrow" }, "⬶": { math: "\\twoheadmapsfrom" }, "⬷": { math: "\\twoheadleftdbkarrow" }, "⬸": { math: "\\leftdotarrow" }, "⬹": { math: "\\nvleftarrowtail" }, "⬺": { math: "\\nVleftarrowtail" }, "⬻": { math: "\\twoheadleftarrowtail" }, "⬼": { math: "\\nvtwoheadleftarrowtail" }, "⬽": { math: "\\nVtwoheadleftarrowtail" }, "⬾": { math: "\\leftarrowx" }, "⬿": { math: "\\leftcurvedarrow" }, "⭀": { math: "\\equalleftarrow" }, "⭁": { math: "\\bsimilarleftarrow" }, "⭂": { math: "\\leftarrowbackapprox" }, "⭃": { math: "\\rightarrowgtr" }, "⭄": { math: "\\rightarrowsupset" }, "⭅": { math: "\\LLeftarrow" }, "⭆": { math: "\\RRightarrow" }, "⭇": { math: "\\bsimilarrightarrow" }, "⭈": { math: "\\rightarrowbackapprox" }, "⭉": { math: "\\similarleftarrow" }, "⭊": { math: "\\leftarrowapprox" }, "⭋": { math: "\\leftarrowbsimilar" }, "⭌": { math: "\\rightarrowbsimilar" }, "⭐": { math: "\\medwhitestar" }, "⭑": { math: "\\medblackstar" }, "⭒": { math: "\\smwhitestar" }, "⭓": { math: "\\rightpentagonblack" }, "⭔": { math: "\\rightpentagon" }, "〒": { math: "\\postalmark" }, "〰": { math: "\\hzigzag" } }, amssymb: { ð: { math: "\\eth" }, "⩽": { math: "\\leqslant" }, "⩽̸": { math: "\\nleqslant" }, "⩾": { math: "\\geqslant" }, "⩾̸": { math: "\\ngeqslant" } }, arevmath: { ð: { math: "\\eth" } }, MinionPro: { ϐ: { math: "\\varbeta" }, ϰ: { math: "\\varkappa" } }, mathrsfs: { ℊ: { math: "\\mathscr{g}" }, ℋ: { math: "\\mathscr{H}" }, ℐ: { math: "\\mathscr{I}" }, ℒ: { math: "\\mathscr{L}" }, ℛ: { math: "\\mathscr{R}" }, ℬ: { math: "\\mathscr{B}" }, ℯ: { math: "\\mathscr{e}" }, ℰ: { math: "\\mathscr{E}" }, ℱ: { math: "\\mathscr{F}" }, ℳ: { math: "\\mathscr{M}" }, ℴ: { math: "\\mathscr{o}" }, "𝒜": { math: "\\mathscr{A}" }, "𝒞": { math: "\\mathscr{C}" }, "𝒟": { math: "\\mathscr{D}" }, "𝒢": { math: "\\mathscr{G}" }, "𝒥": { math: "\\mathscr{J}" }, "𝒦": { math: "\\mathscr{K}" }, "𝒩": { math: "\\mathscr{N}" }, "𝒪": { math: "\\mathscr{O}" }, "𝒫": { math: "\\mathscr{P}" }, "𝒬": { math: "\\mathscr{Q}" }, "𝒮": { math: "\\mathscr{S}" }, "𝒯": { math: "\\mathscr{T}" }, "𝒰": { math: "\\mathscr{U}" }, "𝒱": { math: "\\mathscr{V}" }, "𝒲": { math: "\\mathscr{W}" }, "𝒳": { math: "\\mathscr{X}" }, "𝒴": { math: "\\mathscr{Y}" }, "𝒵": { math: "\\mathscr{Z}" }, "𝒶": { math: "\\mathscr{a}" }, "𝒷": { math: "\\mathscr{b}" }, "𝒸": { math: "\\mathscr{c}" }, "𝒹": { math: "\\mathscr{d}" }, "𝒻": { math: "\\mathscr{f}" }, "𝒽": { math: "\\mathscr{h}" }, "𝒾": { math: "\\mathscr{i}" }, "𝒿": { math: "\\mathscr{j}" }, "𝓀": { math: "\\mathscr{k}" }, "𝓁": { math: "\\mathscr{l}" }, "𝓂": { math: "\\mathscr{m}" }, "𝓃": { math: "\\mathscr{n}" }, "𝓅": { math: "\\mathscr{p}" }, "𝓆": { math: "\\mathscr{q}" }, "𝓇": { math: "\\mathscr{r}" }, "𝓈": { math: "\\mathscr{s}" }, "𝓉": { math: "\\mathscr{t}" }, "𝓊": { math: "\\mathscr{u}" }, "𝓋": { math: "\\mathscr{v}" }, "𝓌": { math: "\\mathscr{w}" }, "𝓍": { math: "\\mathscr{x}" }, "𝓎": { math: "\\mathscr{y}" }, "𝓏": { math: "\\mathscr{z}" } }, MnSymbol: { "∲": { math: "\\lcirclerightint" }, "∳": { math: "\\rcirclerightint" } }, mathabx: { "∸": { math: "\\dotdiv" } }, xecjk: { "≂": { math: "\\texteqsim" }, א: { text: "\\hebalef", macrospacer: true }, ע: { text: "\\hebayin", macrospacer: true }, ב: { text: "\\hebbet", macrospacer: true }, ד: { text: "\\hebdalet", macrospacer: true }, ך: { text: "\\hebfinalkaf", macrospacer: true }, ם: { text: "\\hebfinalmem", macrospacer: true }, ן: { text: "\\hebfinalnun", macrospacer: true }, ף: { text: "\\hebfinalpe", macrospacer: true }, ץ: { text: "\\hebfinaltsadi", macrospacer: true }, ג: { text: "\\hebgimel", macrospacer: true }, ה: { text: "\\hebhe", macrospacer: true }, ח: { text: "\\hebhet", macrospacer: true }, כ: { text: "\\hebkaf", macrospacer: true }, ל: { text: "\\heblamed", macrospacer: true }, מ: { text: "\\hebmem", macrospacer: true }, נ: { text: "\\hebnun", macrospacer: true }, פ: { text: "\\hebpe", macrospacer: true }, ק: { text: "\\hebqof", macrospacer: true }, ר: { text: "\\hebresh", macrospacer: true }, ס: { text: "\\hebsamekh", macrospacer: true }, ש: { text: "\\hebshin", macrospacer: true }, ת: { text: "\\hebtav", macrospacer: true }, ט: { text: "\\hebtet", macrospacer: true }, צ: { text: "\\hebtsadi", macrospacer: true }, ו: { text: "\\hebvav", macrospacer: true }, י: { text: "\\hebyod", macrospacer: true }, ז: { text: "\\hebzayin", macrospacer: true }, ĸ: { text: "\\textkra", macrospacer: true } }, textcomp: { "¢": { text: "\\textcent", macrospacer: true }, "¤": { text: "\\textcurrency", macrospacer: true }, "¥": { text: "\\textyen", macrospacer: true }, "฿": { text: "\\textbaht", macrospacer: true }, "₡": { text: "\\textcolonmonetary", macrospacer: true }, "₤": { text: "\\textlira", macrospacer: true }, "₦": { text: "\\textnaira", macrospacer: true }, "₧": { text: "\\textpeseta", macrospacer: true }, "₩": { text: "\\textwon", macrospacer: true }, "₫": { text: "\\textdong", macrospacer: true }, "₱": { text: "\\textpeso", macrospacer: true }, "¦": { text: "\\textbrokenbar", macrospacer: true }, "©": { text: "\\textcopyright", macrospacer: true }, ª: { text: "\\textordfeminine", macrospacer: true }, "°": { text: "\\textdegree", macrospacer: true }, "¶": { text: "\\textparagraph", macrospacer: true }, º: { text: "\\textordmasculine", macrospacer: true }, ð: { text: "\\textdh", macrospacer: true }, "˙": { text: "\\textperiodcentered", macrospacer: true }, "•": { text: "\\textbullet", macrospacer: true }, "‰": { text: "\\textperthousand", macrospacer: true }, "‱": { text: "\\textpertenthousand", macrospacer: true }, "℞": { text: "\\textrecipe", macrospacer: true }, "™": { text: "\\texttrademark", macrospacer: true }, "↑": { text: "\\textuparrow", macrospacer: true }, "→": { text: "\\textrightarrow", macrospacer: true } }, inputenx: { Ħ: { text: "\\textmalteseH", macrospacer: true }, ɸ: { text: "\\textphi", macrospacer: true }, "≈": { text: "\\textapproxequal", macrospacer: true } }, tipa: { ħ: { text: "\\textcrh", macrospacer: true }, ƕ: { text: "\\texthvlig", macrospacer: true }, ƞ: { text: "\\textipa{\\textnrleg}" }, ǂ: { text: "\\textdoublebarpipe", macrospacer: true }, ɐ: { text: "\\textipa{\\textturna}" }, ɒ: { text: "textipa{\\textopeno}" }, ɔ: { text: "\\textipa{O}" }, ɖ: { text: "\\textrtaild", macrospacer: true }, ə: { text: "\\textschwa", macrospacer: true }, ɣ: { text: "\\textipa{G}" }, ɤ: { text: "\\textrevscripta", macrospacer: true }, ɸ: { text: "\\textphi", macrospacer: true }, ʞ: { text: "\\textturnk", macrospacer: true }, "˥": { text: "\\tone{55}" }, "˦": { text: "\\tone{44}" }, "˧": { text: "\\tone{33}" }, "˨": { text: "\\tone{22}" }, "˩": { text: "\\tone{11}" }, "̀̄": { text: "\\textgravemacron", macrospacer: true }, "̀̇": { text: "\\textgravedot", macrospacer: true }, "́̄": { text: "\\textacutemacron", macrospacer: true }, "́̌": { text: "\\textacutewedge", macrospacer: true }, "̂̇": { text: "\\textcircumdot", macrospacer: true }, "̃̇": { text: "\\texttildedot", macrospacer: true }, "̄̀": { text: "\\textgravemacron", macrospacer: true }, "̆̄": { text: "\\textbrevemacron", macrospacer: true }, "̇́": { text: "\\textdotacute", macrospacer: true }, "̇̆": { text: "\\textdotbreve", macrospacer: true }, "̊̄": { text: "\\textringmacron", macrospacer: true }, "̍": { text: "\\textvbaraccent", macrospacer: true }, "̎": { text: "\\textdoublevbaraccent", macrospacer: true }, "̐": { text: "\\textdotbreve", macrospacer: true }, "̘": { text: "\\textadvancing", macrospacer: true }, "̙": { text: "\\textretracting", macrospacer: true }, "̚": { text: "\\textcorner", macrospacer: true }, "̜": { text: "\\textsublhalfring", macrospacer: true }, "̝": { text: "\\textraising", macrospacer: true }, "̞": { text: "\\textlowering", macrospacer: true }, "̟": { text: "\\textsubplus", macrospacer: true }, "̤": { text: "\\textsubumlaut", macrospacer: true }, "̥": { text: "\\textsubring", macrospacer: true }, "̩": { text: "\\textsyllabic", macrospacer: true }, "̪": { text: "\\textsubbridge", macrospacer: true }, "̬": { text: "\\textsubwedge", macrospacer: true }, "̯": { text: "\\textsubarch", macrospacer: true }, "̰": { text: "\\textsubtilde", macrospacer: true }, "̱": { text: "\\textsubbar", macrospacer: true }, "̴": { text: "\\textsuperimposetilde", macrospacer: true }, "̹": { text: "\\textsubrhalfring", macrospacer: true }, "̺": { text: "\\textinvsubbridge", macrospacer: true }, "̻": { text: "\\textsubsquare", macrospacer: true }, "̼": { text: "\\textseagull", macrospacer: true }, "̽": { text: "\\textovercross", macrospacer: true }, "ₔ": { text: "\\textsubscript{\\textschwa}" } }, ipa: { ɯ: { text: "\\textturnm", macrospacer: true } }, mathscinet: { ʿ: { text: "\\lasp", macrospacer: true } }, textalpha: { α: { text: "\\textalpha", macrospacer: true } }, graphics: { "↳": { text: "\\reflectbox{\\carriagereturn}" } }, pmboxdraw: { "─": { text: "\\textSFx", macrospacer: true }, "━": { text: "\\pmboxdrawuni{2501}" }, "│": { text: "\\textSFxi", macrospacer: true }, "┃": { text: "\\pmboxdrawuni{2503}" }, "┌": { text: "\\textSFi", macrospacer: true }, "┍": { text: "\\pmboxdrawuni{250D}" }, "┎": { text: "\\pmboxdrawuni{250E}" }, "┏": { text: "\\pmboxdrawuni{250F}" }, "┐": { text: "\\textSFiii", macrospacer: true }, "┑": { text: "\\pmboxdrawuni{2511}" }, "┒": { text: "\\pmboxdrawuni{2512}" }, "┓": { text: "\\pmboxdrawuni{2513}" }, "└": { text: "\\textSFii", macrospacer: true }, "┕": { text: "\\pmboxdrawuni{2515}" }, "┖": { text: "\\pmboxdrawuni{2516}" }, "┗": { text: "\\pmboxdrawuni{2517}" }, "┘": { text: "\\textSFiv", macrospacer: true }, "┙": { text: "\\pmboxdrawuni{2519}" }, "┚": { text: "\\pmboxdrawuni{251A}" }, "┛": { text: "\\pmboxdrawuni{251B}" }, "├": { text: "\\textSFviii", macrospacer: true }, "┝": { text: "\\pmboxdrawuni{251D}" }, "┞": { text: "\\pmboxdrawuni{251E}" }, "┟": { text: "\\pmboxdrawuni{251F}" }, "┠": { text: "\\pmboxdrawuni{2520}" }, "┡": { text: "\\pmboxdrawuni{2521}" }, "┢": { text: "\\pmboxdrawuni{2522}" }, "┣": { text: "\\pmboxdrawuni{2523}" }, "┤": { text: "\\textSFix", macrospacer: true }, "┥": { text: "\\pmboxdrawuni{2525}" }, "┦": { text: "\\pmboxdrawuni{2526}" }, "┧": { text: "\\pmboxdrawuni{2527}" }, "┨": { text: "\\pmboxdrawuni{2528}" }, "┩": { text: "\\pmboxdrawuni{2529}" }, "┪": { text: "\\pmboxdrawuni{252A}" }, "┫": { text: "\\pmboxdrawuni{252B}" }, "┬": { text: "\\textSFvi", macrospacer: true }, "┭": { text: "\\pmboxdrawuni{252D}" }, "┮": { text: "\\pmboxdrawuni{252E}" }, "┯": { text: "\\pmboxdrawuni{252F}" }, "┰": { text: "\\pmboxdrawuni{2530}" }, "┱": { text: "\\pmboxdrawuni{2531}" }, "┲": { text: "\\pmboxdrawuni{2532}" }, "┳": { text: "\\pmboxdrawuni{2533}" }, "┴": { text: "\\textSFvii", macrospacer: true }, "┵": { text: "\\pmboxdrawuni{2535}" }, "┶": { text: "\\pmboxdrawuni{2536}" }, "┷": { text: "\\pmboxdrawuni{2537}" }, "┸": { text: "\\pmboxdrawuni{2538}" }, "┹": { text: "\\pmboxdrawuni{2539}" }, "┺": { text: "\\pmboxdrawuni{253A}" }, "┻": { text: "\\pmboxdrawuni{253B}" }, "┼": { text: "\\textSFv", macrospacer: true }, "┽": { text: "\\pmboxdrawuni{253D}" }, "┾": { text: "\\pmboxdrawuni{253E}" }, "┿": { text: "\\pmboxdrawuni{253F}" }, "╀": { text: "\\pmboxdrawuni{2540}" }, "╁": { text: "\\pmboxdrawuni{2541}" }, "╂": { text: "\\pmboxdrawuni{2542}" }, "╃": { text: "\\pmboxdrawuni{2543}" }, "╄": { text: "\\pmboxdrawuni{2544}" }, "╅": { text: "\\pmboxdrawuni{2545}" }, "╆": { text: "\\pmboxdrawuni{2546}" }, "╇": { text: "\\pmboxdrawuni{2547}" }, "╈": { text: "\\pmboxdrawuni{2548}" }, "╉": { text: "\\pmboxdrawuni{2549}" }, "╊": { text: "\\pmboxdrawuni{254A}" }, "╋": { text: "\\pmboxdrawuni{254B}" }, "═": { text: "\\textSFxliii", macrospacer: true }, "║": { text: "\\textSFxxiv", macrospacer: true }, "╒": { text: "\\textSFli", macrospacer: true }, "╓": { text: "\\textSFlii", macrospacer: true }, "╔": { text: "\\textSFxxxix", macrospacer: true }, "╕": { text: "\\textSFxxii", macrospacer: true }, "╖": { text: "\\textSFxxi", macrospacer: true }, "╗": { text: "\\textSFxxv", macrospacer: true }, "╘": { text: "\\textSFl", macrospacer: true }, "╙": { text: "\\textSFxlix", macrospacer: true }, "╚": { text: "\\textSFxxxviii", macrospacer: true }, "╛": { text: "\\textSFxxviii", macrospacer: true }, "╜": { text: "\\textSFxxvii", macrospacer: true }, "╝": { text: "\\textSFxxvi", macrospacer: true }, "╞": { text: "\\textSFxxxvi", macrospacer: true }, "╟": { text: "\\textSFxxxvii", macrospacer: true }, "╠": { text: "\\textSFxlii", macrospacer: true }, "╡": { text: "\\textSFxix", macrospacer: true }, "╢": { text: "\\textSFxx", macrospacer: true }, "╣": { text: "\\textSFxxiii", macrospacer: true }, "╤": { text: "\\textSFxlvii", macrospacer: true }, "╥": { text: "\\textSFxlviii", macrospacer: true }, "╦": { text: "\\textSFxli", macrospacer: true }, "╧": { text: "\\textSFxlv", macrospacer: true }, "╨": { text: "\\textSFxlvi", macrospacer: true }, "╩": { text: "\\textSFxl", macrospacer: true }, "╪": { text: "\\textSFliv", macrospacer: true }, "╫": { text: "\\textSFliii", macrospacer: true }, "╬": { text: "\\textSFxliv", macrospacer: true }, "╴": { text: "\\pmboxdrawuni{2574}" }, "╵": { text: "\\pmboxdrawuni{2575}" }, "╶": { text: "\\pmboxdrawuni{2576}" }, "╷": { text: "\\pmboxdrawuni{2577}" }, "╸": { text: "\\pmboxdrawuni{2578}" }, "╹": { text: "\\pmboxdrawuni{2579}" }, "╺": { text: "\\pmboxdrawuni{257A}" }, "╻": { text: "\\pmboxdrawuni{257B}" }, "╼": { text: "\\pmboxdrawuni{257C}" }, "╽": { text: "\\pmboxdrawuni{257D}" }, "╾": { text: "\\pmboxdrawuni{257E}" }, "╿": { text: "\\pmboxdrawuni{257F}" }, "▀": { text: "\\textupblock", macrospacer: true }, "▁": { text: "\\pmboxdrawuni{2581}" }, "▂": { text: "\\pmboxdrawuni{2582}" }, "▃": { text: "\\pmboxdrawuni{2583}" }, "▄": { text: "\\textdnblock", macrospacer: true }, "▅": { text: "\\pmboxdrawuni{2585}" }, "▆": { text: "\\pmboxdrawuni{2586}" }, "▇": { text: "\\pmboxdrawuni{2587}" }, "█": { text: "\\textblock", macrospacer: true }, "▉": { text: "\\pmboxdrawuni{2589}" }, "▊": { text: "\\pmboxdrawuni{258A}" }, "▋": { text: "\\pmboxdrawuni{258B}" }, "▌": { text: "\\textlfblock", macrospacer: true }, "▍": { text: "\\pmboxdrawuni{258D}" }, "▎": { text: "\\pmboxdrawuni{258E}" }, "▏": { text: "\\pmboxdrawuni{258F}" }, "▐": { text: "\\textrtblock", macrospacer: true }, "░": { text: "\\textltshade", macrospacer: true }, "▒": { text: "\\textshade", macrospacer: true }, "▓": { text: "\\textdkshade", macrospacer: true }, "▔": { text: "\\pmboxdrawuni{2594}" }, "▕": { text: "\\pmboxdrawuni{2595}" }, "▖": { text: "\\pmboxdrawuni{2596}" }, "▗": { text: "\\pmboxdrawuni{2597}" }, "▘": { text: "\\pmboxdrawuni{2598}" }, "▙": { text: "\\pmboxdrawuni{2599}" }, "▚": { text: "\\pmboxdrawuni{259A}" }, "▛": { text: "\\pmboxdrawuni{259B}" }, "▜": { text: "\\pmboxdrawuni{259C}" }, "▝": { text: "\\pmboxdrawuni{259D}" }, "▞": { text: "\\pmboxdrawuni{259E}" }, "▟": { text: "\\pmboxdrawuni{259F}" } } } };
  }
});

// node_modules/unicode2latex/tables/bibtex.json
var require_bibtex = __commonJS({
  "node_modules/unicode2latex/tables/bibtex.json"(exports, module) {
    module.exports = { base: { "#": { text: "\\#", math: "\\#" }, $: { text: "\\$", math: "\\$" }, "%": { text: "\\%", math: "\\%" }, "&": { text: "\\&", math: "\\&" }, _: { text: "\\_", math: "\\_" }, " ": { text: "~", math: "~" }, "£": { text: "{\\pounds}", math: "\\pounds" }, "§": { text: "{\\S}", math: "\\S" }, "©": { text: "{\\copyright}", math: "\\copyright", alt: ["textcomp"] }, "­": { text: "\\-", math: "\\-" }, "¶": { text: "{\\P}", math: "\\P", alt: ["textcomp"] }, "†": { text: "{\\dag}", math: "\\dag" }, "‡": { text: "{\\ddag}", math: "\\ddag" }, "…": { text: "{\\dots}", math: "\\dots" }, " ": { text: "\\:", math: "\\:" }, "−": { text: "-", math: "-" }, "☿": { text: "{\\mercury}", math: "\\mercury" }, "♃": { text: "{\\jupiter}", math: "\\jupiter" }, "♄": { text: "{\\saturn}", math: "\\saturn" }, "♅": { text: "{\\uranus}", math: "\\uranus" }, "♆": { text: "{\\neptune}", math: "\\neptune" }, "♇": { text: "{\\pluto}", math: "\\pluto" }, "♈": { text: "{\\aries}", math: "\\aries" }, "♉": { text: "{\\taurus}", math: "\\taurus" }, "♊": { text: "{\\gemini}", math: "\\gemini" }, "♋": { text: "{\\cancer}", math: "\\cancer" }, "♌": { text: "{\\leo}", math: "\\leo" }, "♍": { text: "{\\virgo}", math: "\\virgo" }, "♎": { text: "{\\libra}", math: "\\libra" }, "♏": { text: "{\\scorpio}", math: "\\scorpio" }, "♐": { text: "{\\sagittarius}", math: "\\sagittarius" }, "♑": { text: "{\\capricornus}", math: "\\capricornus" }, "♒": { text: "{\\aquarius}", math: "\\aquarius" }, "<": { math: "<" }, ">": { math: ">" }, "\\": { text: "{\\textbackslash}", math: "\\backslash" }, "|": { text: "{\\textbar}", math: "\\vert" }, "¬": { text: "{\\textlnot}", math: "\\lnot" }, "°": { math: "^\\circ", alt: ["textcomp"] }, "±": { text: "{\\textpm}", math: "\\pm" }, "²": { math: "^{2}" }, "³": { math: "^{3}" }, "·": { math: "\\cdot" }, "¹": { math: "^{1}" }, "¼": { math: "\\frac{1}{4}" }, "½": { math: "\\frac{1}{2}" }, "¾": { math: "\\frac{3}{4}" }, "×": { text: "{\\texttimes}", math: "\\times" }, "÷": { text: "{\\textdiv}", math: "\\div" }, ħ: { math: "\\hbar", alt: ["tipa"] }, ı: { text: "{\\i}", math: "\\imath" }, ƒ: { text: "{\\textflorin}", math: "f" }, "ȷ": { math: "\\jmath" }, ɛ: { math: "\\varepsilon" }, ɣ: { math: "\\gamma", alt: ["tipa"] }, ʰ: { text: "\\textsuperscript{h}", math: "^{h}" }, ʲ: { text: "\\textsuperscript{j}", math: "^{j}" }, ʳ: { text: "\\textsuperscript{r}", math: "^{r}" }, ʷ: { text: "\\textsuperscript{w}", math: "^{w}" }, ʸ: { text: "\\textsuperscript{y}", math: "^{y}" }, ˡ: { text: "\\textsuperscript{l}", math: "^{l}" }, ˢ: { text: "\\textsuperscript{s}", math: "^{s}" }, ˣ: { text: "\\textsuperscript{x}", math: "^{x}" }, "̅": { math: "\\overline" }, "̊": { text: "{\\r}", math: "\\mathring" }, "̱": { math: "\\underbar", alt: ["tipa"] }, "̲": { math: "\\underline" }, "̸": { math: "\\not" }, Ύ: { math: "\\mathrm{'Y}" }, Ώ: { math: "\\mathrm{'\\Omega}" }, ΐ: { math: "\\acute{\\ddot{\\iota}}" }, Γ: { math: "\\Gamma", alt: ["unicode-math"] }, Δ: { math: "\\Delta", alt: ["unicode-math"] }, Θ: { math: "\\Theta", alt: ["unicode-math"] }, Λ: { math: "\\Lambda", alt: ["unicode-math"] }, Ξ: { math: "\\Xi" }, Π: { math: "\\Pi" }, Σ: { math: "\\Sigma" }, Υ: { math: "\\Upsilon" }, Φ: { math: "\\Phi" }, Ψ: { math: "\\Psi" }, Ω: { text: "{\\textohm}", math: "\\Omega" }, Ϊ: { math: "\\mathrm{\\ddot{I}}" }, Ϋ: { math: "\\mathrm{\\ddot{Y}}" }, ά: { math: "\\acute{\\alpha}" }, έ: { math: "\\acute{\\epsilon}" }, ή: { math: "\\acute{\\eta}" }, ί: { math: "\\acute{\\iota}" }, ΰ: { math: "\\acute{\\ddot{\\upsilon}}" }, α: { math: "\\alpha", alt: ["textalpha"] }, β: { math: "\\beta" }, γ: { math: "\\gamma" }, δ: { math: "\\delta" }, ε: { math: "\\varepsilon" }, ζ: { math: "\\zeta" }, η: { math: "\\eta" }, θ: { text: "{\\texttheta}", math: "\\theta" }, ι: { math: "\\iota" }, κ: { math: "\\kappa" }, λ: { math: "\\lambda" }, μ: { math: "\\mu" }, ν: { math: "\\nu" }, ξ: { math: "\\xi" }, π: { math: "\\pi" }, "𝜌": { math: "\\rho", alt: ["unicode-math"] }, ρ: { math: "\\rho" }, ς: { math: "\\varsigma" }, σ: { math: "\\sigma" }, τ: { math: "\\tau" }, υ: { math: "\\upsilon" }, φ: { math: "\\varphi" }, χ: { math: "\\chi" }, ψ: { math: "\\psi" }, ω: { math: "\\omega" }, ϊ: { math: "\\ddot{\\iota}" }, ϋ: { math: "\\ddot{\\upsilon}" }, ύ: { math: "\\acute{\\upsilon}" }, ώ: { math: "\\acute{\\omega}" }, ϑ: { text: "{\\textvartheta}", math: "\\vartheta" }, ϒ: { math: "\\Upsilon" }, ϕ: { math: "\\phi" }, ϖ: { math: "\\varpi" }, "Ϙ": { math: "\\Qoppa" }, "ϙ": { math: "\\qoppa" }, Ϛ: { math: "\\Stigma" }, ϛ: { math: "\\stigma" }, Ϝ: { math: "\\Digamma" }, ϝ: { math: "\\digamma" }, Ϟ: { math: "\\Koppa" }, ϟ: { math: "\\koppa" }, Ϡ: { math: "\\Sampi" }, ϡ: { math: "\\sampi" }, ϱ: { math: "\\varrho" }, "ϴ": { text: "{\\textTheta}", math: "\\upvarTheta" }, "ϵ": { math: "\\epsilon" }, "϶": { math: "\\backepsilon", alt: ["unicode-math"] }, "ࡱ": { math: "\\\\backslash" }, "ᵃ": { text: "\\textsuperscript{a}", math: "^{a}" }, "ᴬ": { text: "\\textsuperscript{A}", math: "^{A}" }, "ᵇ": { text: "\\textsuperscript{b}", math: "^{b}" }, "ᵈ": { text: "\\textsuperscript{d}", math: "^{d}" }, "ᵉ": { text: "\\textsuperscript{e}", math: "^{e}" }, "ᵍ": { text: "\\textsuperscript{g}", math: "^{g}" }, "ᵏ": { text: "\\textsuperscript{k}", math: "^{k}" }, "ᵐ": { text: "\\textsuperscript{m}", math: "^{m}" }, "ᵒ": { text: "\\textsuperscript{o}", math: "^{o}" }, "ᵖ": { text: "\\textsuperscript{p}", math: "^{p}" }, "ᵗ": { text: "\\textsuperscript{t}", math: "^{t}" }, "ᵘ": { text: "\\textsuperscript{u}", math: "^{u}" }, "ᵛ": { text: "\\textsuperscript{v}", math: "^{v}" }, "ᶜ": { text: "\\textsuperscript{c}", math: "^{c}" }, "ᶠ": { text: "\\textsuperscript{f}", math: "^{f}" }, "ᶻ": { text: "\\textsuperscript{z}", math: "^{z}" }, " ": { math: "\\quad" }, " ": { math: "\\mkern1mu" }, "•": { math: "\\bullet", alt: ["textcomp"] }, "′": { math: "\\prime" }, "″": { math: "{''}", alt: ["unicode-math"] }, "‴": { math: "{'''}", alt: ["unicode-math"] }, "⁗": { math: "''''", alt: ["unicode-math"] }, "⁰": { math: "^{0}" }, "ⁱ": { text: "\\textsuperscript{i}", math: "^{i}" }, "⁴": { math: "^{4}" }, "⁵": { math: "^{5}" }, "⁶": { math: "^{6}" }, "⁷": { math: "^{7}" }, "⁸": { math: "^{8}" }, "⁹": { math: "^{9}" }, "⁺": { math: "^{+}" }, "⁻": { math: "^{-}" }, "⁼": { math: "^{=}" }, "⁽": { math: "^{(}" }, "⁾": { math: "^{)}" }, ⁿ: { math: "^{n}" }, "₀": { math: "_{0}" }, "₁": { math: "_{1}" }, "₂": { math: "_{2}" }, "₃": { math: "_{3}" }, "₄": { math: "_{4}" }, "₅": { math: "_{5}" }, "₆": { math: "_{6}" }, "₇": { math: "_{7}" }, "₈": { math: "_{8}" }, "₉": { math: "_{9}" }, "₊": { math: "_{+}" }, "₋": { math: "_{-}" }, "₌": { math: "_{=}" }, "₍": { math: "_{(}" }, "₎": { math: "_{)}" }, "ₐ": { text: "\\textsubscript{a}", math: "_{a}" }, "ₑ": { text: "\\textsubscript{e}", math: "_{e}" }, "ₒ": { text: "\\textsubscript{o}", math: "_{o}" }, "ₓ": { text: "\\textsubscript{x}", math: "_{x}" }, "ₕ": { text: "\\textsubscript{h}", math: "_{h}" }, "ₖ": { text: "\\textsubscript{k}", math: "_{k}" }, "ₗ": { text: "\\textsubscript{l}", math: "_{l}" }, "ₘ": { text: "\\textsubscript{m}", math: "_{m}" }, "ₙ": { text: "\\textsubscript{n}", math: "_{n}" }, "ₚ": { text: "\\textsubscript{p}", math: "_{p}" }, "ₛ": { text: "\\textsubscript{s}", math: "_{s}" }, "ₜ": { text: "\\textsubscript{t}", math: "_{t}" }, "⃐": { math: "\\lvec" }, "⃖": { math: "\\LVec" }, ℂ: { math: "\\mathbb{C}" }, ℇ: { math: "\\Euler" }, ℋ: { math: "\\mathcal{H}", alt: ["mathrsfs"] }, ℌ: { math: "\\mathfrak{H}" }, ℍ: { math: "\\mathbb{H}" }, ℑ: { math: "\\mathfrak{I}" }, ℓ: { math: "\\ell" }, ℕ: { math: "\\mathbb{N}" }, "℘": { math: "\\wp" }, ℙ: { math: "\\mathbb{P}" }, ℚ: { math: "\\mathbb{Q}" }, ℜ: { math: "\\mathfrak{R}" }, ℝ: { math: "\\mathbb{R}" }, ℤ: { math: "\\mathbb{Z}" }, ℨ: { math: "\\mathfrak{Z}" }, Å: { text: "{\\AA}", math: "\\Angstroem" }, ℭ: { math: "\\mathfrak{C}" }, ℵ: { math: "\\aleph" }, "ℼ": { math: "\\mathbb{\\pi}" }, "ℽ": { math: "\\mathbb{\\gamma}" }, "ℾ": { math: "\\mathbb{\\Gamma}" }, "ℿ": { math: "\\mathbb{\\Pi}" }, "⅀": { math: "\\mathbb{\\Sigma}" }, "ⅆ": { math: "\\DifferentialD" }, "ⅇ": { math: "\\ExponetialE" }, "ⅈ": { math: "\\ComplexI" }, "ⅉ": { math: "\\ComplexJ" }, "⅋": { math: "\\invamp" }, "⅐": { math: "\\frac{1}{7}" }, "⅑": { math: "\\frac{1}{9}" }, "⅒": { math: "\\frac{1}{10}" }, "⅓": { math: "\\frac{1}{3}" }, "⅔": { math: "\\frac{2}{3}" }, "⅕": { math: "\\frac{1}{5}" }, "⅖": { math: "\\frac{2}{5}" }, "⅗": { math: "\\frac{3}{5}" }, "⅘": { math: "\\frac{4}{5}" }, "⅙": { math: "\\frac{1}{6}" }, "⅚": { math: "\\frac{5}{6}" }, "⅛": { math: "\\frac{1}{8}" }, "⅜": { math: "\\frac{3}{8}" }, "⅝": { math: "\\frac{5}{8}" }, "⅞": { math: "\\frac{7}{8}" }, "⅟": { math: "\\frac{1}" }, "↉": { math: "\\frac{0}{3}" }, "←": { text: "{\\textleftarrow}", math: "\\leftarrow" }, "↑": { math: "\\uparrow", alt: ["textcomp"] }, "→": { math: "\\rightarrow", alt: ["textcomp"] }, "↓": { text: "{\\textdownarrow}", math: "\\downarrow" }, "↔": { math: "\\leftrightarrow" }, "↕": { math: "\\updownarrow" }, "↖": { math: "\\nwarrow" }, "↗": { math: "\\nearrow" }, "↘": { math: "\\searrow" }, "↙": { math: "\\swarrow" }, "↜": { math: "\\arrowwaveleft" }, "↝": { math: "\\arrowwaveright" }, "↦": { math: "\\mapsto" }, "↩": { math: "\\hookleftarrow" }, "↪": { math: "\\hookrightarrow" }, "↯": { math: "\\lightning" }, "↲": { math: "\\dlsh" }, "↻": { math: "\\circlearrowright" }, "↼": { math: "\\leftharpoonup" }, "↽": { math: "\\leftharpoondown" }, "⇀": { math: "\\rightharpoonup" }, "⇅": { math: "\\dblarrowupdown" }, "⇌": { math: "\\rightleftharpoons" }, "⇐": { math: "\\Leftarrow" }, "⇑": { math: "\\Uparrow" }, "⇒": { math: "\\Rightarrow" }, "⇓": { math: "\\Downarrow" }, "⇔": { math: "\\Leftrightarrow" }, "⇕": { math: "\\Updownarrow" }, "⇠": { math: "\\dashleftarrow" }, "⇢": { math: "\\dashrightarrow" }, "⇤": { math: "\\LeftArrowBar" }, "⇥": { math: "\\RightArrowBar" }, "⇵": { math: "\\DownArrowUpArrow" }, "⇸": { math: "\\pfun" }, "⇻": { math: "\\ffun" }, "∀": { math: "\\forall" }, "∂": { math: "\\partial" }, "∃": { math: "\\exists" }, "∈": { math: "\\in" }, "∉": { math: "\\notin" }, "∋": { math: "\\ni" }, "∌": { math: "\\not\\ni" }, "∏": { math: "\\prod" }, "∐": { math: "\\coprod" }, "∑": { math: "\\sum" }, "∓": { math: "\\mp" }, "∗": { math: "\\ast" }, "∘": { math: "\\circ" }, "∙": { math: "\\bullet" }, "∛": { math: "\\sqrt[3]" }, "∜": { math: "\\sqrt[4]" }, "∝": { math: "\\propto" }, "∞": { math: "\\infty" }, "∠": { math: "\\angle" }, "∣": { math: "\\mid" }, "∥": { math: "\\parallel" }, "∧": { math: "\\wedge" }, "∨": { math: "\\vee" }, "∩": { math: "\\cap" }, "∪": { math: "\\cup" }, "∫": { math: "\\int" }, "∬": { math: "{\\int\\!\\int}" }, "∭": { math: "{\\int\\!\\int\\!\\int}" }, "∮": { math: "\\oint" }, "∯": { math: "\\surfintegral" }, "∰": { math: "\\volintegral" }, "∱": { math: "\\clwintegral" }, "∶": { math: ":" }, "∺": { math: "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}" }, "∻": { math: "\\homothetic" }, "∼": { math: "\\sim" }, "∾": { math: "\\lazysinv" }, "∿": { math: "\\AC" }, "≀": { math: "\\wr" }, "≁": { math: "\\not\\sim" }, "≂̸": { math: "\\NotEqualTilde" }, "≃": { math: "\\simeq" }, "≄": { math: "\\not\\simeq" }, "≅": { math: "\\cong" }, "≆": { math: "\\approxnotequal" }, "≇": { math: "\\not\\cong" }, "≈": { math: "\\approx", alt: ["inputenx"] }, "≉": { math: "\\not\\approx" }, "≋": { math: "\\tildetrpl" }, "≋̸": { math: "\\not\\apid" }, "≌": { math: "\\allequal" }, "≍": { math: "\\asymp" }, "≎̸": { math: "\\NotHumpDownHump" }, "≏̸": { math: "\\NotHumpEqual" }, "≐": { math: "\\doteq" }, "≐̸": { math: "\\not\\doteq" }, "≑": { math: "\\doteqdot" }, "≔": { text: ":=", math: ":=", alt: ["unicode-math"] }, "≕": { math: "=:" }, "≙": { math: "\\estimates" }, "≛": { math: "\\starequal" }, "≠": { math: "\\neq" }, "≡": { math: "\\equiv" }, "≢": { math: "\\not\\equiv" }, "≤": { math: "\\leq" }, "≥": { math: "\\geq" }, "≦": { math: "\\leqq" }, "≧": { math: "\\geqq" }, "≨︀": { math: "\\lvertneqq" }, "≩︀": { math: "\\gvertneqq" }, "≪": { math: "\\ll" }, "≪̸": { math: "\\NotLessLess" }, "≫": { math: "\\gg" }, "≫̸": { math: "\\NotGreaterGreater" }, "≭": { math: "{\\not\\kern-0.3em\\times}", alt: ["unicode-math"] }, "≮": { math: "\\not<" }, "≯": { math: "\\not>" }, "≰": { math: "\\not\\leq" }, "≱": { math: "\\not\\geq" }, "≲": { math: "\\lessequivlnt" }, "≳": { math: "\\greaterequivlnt" }, "≸": { math: "\\notlessgreater" }, "≹": { math: "\\notgreaterless" }, "≺": { math: "\\prec" }, "≻": { math: "\\succ" }, "≾": { math: "\\precapprox" }, "≾̸": { math: "\\NotPrecedesTilde" }, "≿": { math: "\\succapprox" }, "≿̸": { math: "\\NotSucceedsTilde" }, "⊀": { math: "\\not\\prec" }, "⊁": { math: "\\not\\succ" }, "⊂": { math: "\\subset" }, "⊃": { math: "\\supset" }, "⊄": { math: "\\not\\subset" }, "⊅": { math: "\\not\\supset" }, "⊆": { math: "\\subseteq" }, "⊇": { math: "\\supseteq" }, "⊈": { math: "\\not\\subseteq" }, "⊉": { math: "\\not\\supseteq" }, "⊊︀": { math: "\\varsubsetneqq" }, "⊋︀": { math: "\\varsupsetneq" }, "⊎": { math: "\\uplus" }, "⊏̸": { math: "\\NotSquareSubset" }, "⊐̸": { math: "\\NotSquareSuperset" }, "⊑": { math: "\\sqsubseteq" }, "⊒": { math: "\\sqsupseteq" }, "⊓": { math: "\\sqcap" }, "⊔": { math: "\\sqcup" }, "⊕": { math: "\\oplus" }, "⊖": { math: "\\ominus" }, "⊗": { math: "\\otimes" }, "⊘": { math: "\\oslash" }, "⊙": { math: "\\odot" }, "⊢": { math: "\\vdash" }, "⊣": { math: "\\dashv" }, "⊤": { math: "\\top" }, "⊥": { math: "\\perp" }, "⊧": { math: "\\truestate" }, "⊨": { math: "\\forcesextra" }, "⊶": { math: "\\original" }, "⊷": { math: "\\image" }, "⊹": { math: "\\hermitconjmatrix" }, "⊾": { math: "\\rightanglearc" }, "⋀": { math: "\\bigwedge" }, "⋁": { math: "\\bigvee" }, "⋂": { math: "\\bigcap" }, "⋃": { math: "\\bigcup" }, "⋄": { math: "\\diamond" }, "⋅": { math: "\\cdot" }, "⋆": { math: "\\star" }, "⋈": { math: "\\bowtie" }, "⋘": { math: "\\verymuchless" }, "⋙": { math: "\\verymuchgreater" }, "⋢": { math: "\\not\\sqsubseteq" }, "⋣": { math: "\\not\\sqsupseteq" }, "⋪": { math: "\\ntriangleleft" }, "⋫": { math: "\\ntriangleright" }, "⋮": { math: "\\vdots" }, "⋯": { math: "\\cdots" }, "⋰": { math: "\\upslopeellipsis" }, "⋱": { math: "\\ddots" }, "⋶": { math: "\\barin" }, "⌆": { math: "\\perspcorrespond" }, "⌈": { math: "\\lceil" }, "⌉": { math: "\\rceil" }, "⌊": { math: "\\lfloor" }, "⌋": { math: "\\rfloor" }, "⌑": { math: "\\wasylozenge" }, "⌕": { math: "\\recorder" }, "⌖": { math: '{\\mathchar"2208}' }, "⌢": { math: "\\frown" }, "⌣": { math: "\\smile" }, "〈": { text: "{\\textlangle}", math: "\\langle" }, "〉": { text: "{\\textrangle}", math: "\\rangle" }, "⌹": { math: "\\APLinv" }, "⌿": { math: "\\notslash" }, "⍀": { math: "\\notbackslash" }, "⍇": { math: "\\APLleftarrowbox" }, "⍈": { math: "\\APLrightarrowbox" }, "⍉": { math: "\\invdiameter" }, "⍐": { math: "\\APLuparrowbox" }, "⍗": { math: "\\APLdownarrowbox" }, "⍝": { math: "\\APLcomment" }, "⍞": { math: "\\APLinput" }, "⍟": { math: "\\APLlog" }, "⎰": { math: "\\lmoustache" }, "⎱": { math: "\\rmoustache" }, "Ⓢ": { math: "\\circledS" }, "╱": { math: "\\diagup" }, "□": { math: "\\square" }, "▶": { math: "\\RHD" }, "▷": { math: "\\rhd" }, "▽": { math: "\\bigtriangledown" }, "◀": { math: "\\LHD" }, "◁": { math: "\\lhd" }, "◆": { text: "\\ding{117}", math: "\\Diamondblack" }, "◇": { math: "\\Diamond" }, "○": { math: "\\bigcirc" }, "●": { text: "\\ding{108}", math: "\\CIRCLE" }, "◯": { text: "{\\textbigcircle}", math: "\\bigcirc" }, "☉": { math: "\\Sun" }, "☐": { math: "\\Square" }, "☑": { math: "\\CheckedBox" }, "☒": { math: "\\XBox" }, "☕": { math: "\\steaming" }, "☞": { text: "\\ding{43}", math: "\\pointright" }, "☠": { math: "\\skull" }, "☢": { math: "\\radiation" }, "☣": { math: "\\biohazard" }, "☯": { math: "\\yinyang" }, "☹": { math: "\\frownie" }, "☺": { math: "\\smiley" }, "♁": { math: "\\earth" }, "♠": { text: "\\ding{171}", math: "\\spadesuit" }, "♡": { math: "\\heartsuit" }, "♢": { math: "\\diamondsuit" }, "♣": { math: "\\clubsuit" }, "♭": { math: "\\flat" }, "♮": { math: "\\natural" }, "♯": { math: "\\sharp" }, "♻": { math: "\\recycle" }, "⚓": { math: "\\anchor" }, "⚔": { math: "\\swords" }, "⚠": { math: "\\warning" }, "⚪": { math: "\\medcirc" }, "⚫": { math: "\\medbullet" }, "✎": { text: "\\ding{46}", math: "\\pencil" }, "✗": { text: "\\ding{55}", math: "\\ballotx" }, "➢": { text: "\\ding{226}", math: "\\arrowbullet" }, "⟂": { math: "\\perp" }, "⟅": { math: "\\Lbag" }, "⟆": { math: "\\Rbag" }, "⟐": { math: "\\Diamonddot" }, "⟦": { math: "\\llbracket" }, "⟧": { math: "\\rrbracket" }, "⟨": { math: "\\langle" }, "⟩": { math: "\\rangle" }, "⟪": { math: "\\lang" }, "⟮": { math: "\\lgroup" }, "⟯": { math: "\\rgroup" }, "⟵": { math: "\\longleftarrow" }, "⟶": { math: "\\longrightarrow" }, "⟷": { math: "\\longleftrightarrow" }, "⟸": { math: "\\Longleftarrow" }, "⟹": { math: "\\Longrightarrow" }, "⟺": { math: "\\Longleftrightarrow" }, "⟼": { math: "\\longmapsto" }, "⤀": { math: "\\psur" }, "⤒": { math: "\\UpArrowBar" }, "⤓": { math: "\\DownArrowBar" }, "⤔": { math: "\\pinj" }, "⤕": { math: "\\finj" }, "⤖": { math: "\\bij" }, "⥀": { math: "\\Elolarr" }, "⥁": { math: "\\Elorarr" }, "⥊": { math: "\\leftrightharpoon" }, "⥋": { math: "\\rightleftharpoon" }, "⥏": { math: "\\RightUpDownVector" }, "⥑": { math: "\\LeftUpDownVector" }, "⥒": { math: "\\LeftVectorBar" }, "⥓": { math: "\\RightVectorBar" }, "⥔": { math: "\\RightUpVectorBar" }, "⥕": { math: "\\RightDownVectorBar" }, "⥖": { math: "\\DownLeftVectorBar" }, "⥗": { math: "\\DownRightVectorBar" }, "⥘": { math: "\\LeftUpVectorBar" }, "⥙": { math: "\\LeftDownVectorBar" }, "⥚": { math: "\\LeftTeeVector" }, "⥛": { math: "\\RightTeeVector" }, "⥜": { math: "\\RightUpTeeVector" }, "⥝": { math: "\\RightDownTeeVector" }, "⥞": { math: "\\DownLeftTeeVector" }, "⥟": { math: "\\DownRightTeeVector" }, "⥠": { math: "\\LeftUpTeeVector" }, "⥡": { math: "\\LeftDownTeeVector" }, "⥢": { math: "\\leftleftharpoons" }, "⥣": { math: "\\upupharpoons" }, "⥤": { math: "\\rightrightharpoons" }, "⥥": { math: "\\downdownharpoons" }, "⥪": { math: "\\leftbarharpoon" }, "⥫": { math: "\\barleftharpoon" }, "⥬": { math: "\\rightbarharpoon" }, "⥭": { math: "\\barrightharpoon" }, "⥮": { math: "\\UpEquilibrium" }, "⥯": { math: "\\ReverseUpEquilibrium" }, "⥰": { math: "\\RoundImplies" }, "⦈": { math: "\\rimg" }, "⦉": { math: "\\lblot" }, "⦊": { math: "\\rblot" }, "⦜": { math: "\\Angle" }, "⧄": { math: "\\boxslash" }, "⧏": { math: "\\LeftTriangleBar" }, "⧏̸": { math: "\\NotLeftTriangleBar" }, "⧐": { math: "\\RightTriangleBar" }, "⧐̸": { math: "\\NotRightTriangleBar" }, "⧟": { math: "\\multimapboth" }, "⧵": { math: "\\setminus" }, "⧹": { math: "\\zhide" }, "⨀": { math: "\\bigodot" }, "⨁": { math: "\\bigoplus" }, "⨂": { math: "\\bigotimes" }, "⨆": { math: "\\Elxsqcup" }, "⨉": { math: "\\varprod" }, "⨏": { math: "\\clockoint" }, "⨖": { math: "\\sqrint" }, "⨿": { math: "\\amalg" }, "⩖": { math: "\\ElOr" }, "⩮": { math: "\\stackrel{*}{=}" }, "⩵": { math: "\\Equal" }, "⩶": { math: "\\Same" }, "⩽": { math: "\\leq", alt: ["amssymb", "unicode-math"] }, "⪡": { math: "\\NestedLessLess" }, "⪡̸": { math: "\\NotNestedLessLess" }, "⪢": { math: "\\NestedGreaterGreater" }, "⪢̸": { math: "\\NotNestedGreaterGreater" }, "⪦": { math: "\\leftslice" }, "⪧": { math: "\\rightslice" }, "⪯": { math: "\\preceq" }, "⪯̸": { math: "\\not\\preceq" }, "⪰": { math: "\\succeq" }, "⪰̸": { math: "\\not\\succeq" }, "⪻": { math: "\\llcurly" }, "⪼": { math: "\\ggcurly" }, "⫅̸": { math: "\\nsubseteqq" }, "⫆̸": { math: "\\nsupseteqq" }, "⫝̸": { math: "\\forks", alt: ["unicode-math"] }, "⫪": { math: "\\Top" }, "⫽": { math: "{{/}\\!\\!{/}}" }, "⫽⃥": { math: "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}" }, "〔": { math: "\\lbrbrak" }, "〕": { math: "\\rbrbrak" }, "〚": { math: "\\openbracketleft" }, "〛": { math: "\\openbracketright" }, "𝐀": { math: "\\mathbf{A}", alt: ["unicode-math"] }, "𝐁": { math: "\\mathbf{B}", alt: ["unicode-math"] }, "𝐂": { math: "\\mathbf{C}", alt: ["unicode-math"] }, "𝐃": { math: "\\mathbf{D}", alt: ["unicode-math"] }, "𝐄": { math: "\\mathbf{E}", alt: ["unicode-math"] }, "𝐅": { math: "\\mathbf{F}", alt: ["unicode-math"] }, "𝐆": { math: "\\mathbf{G}", alt: ["unicode-math"] }, "𝐇": { math: "\\mathbf{H}", alt: ["unicode-math"] }, "𝐈": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝐉": { math: "\\mathbf{J}", alt: ["unicode-math"] }, "𝐊": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝐋": { math: "\\mathbf{L}", alt: ["unicode-math"] }, "𝐌": { math: "\\mathbf{M}", alt: ["unicode-math"] }, "𝐍": { math: "\\mathbf{N}", alt: ["unicode-math"] }, "𝐎": { math: "\\mathbf{O}", alt: ["unicode-math"] }, "𝐏": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝐐": { math: "\\mathbf{Q}", alt: ["unicode-math"] }, "𝐑": { math: "\\mathbf{R}", alt: ["unicode-math"] }, "𝐒": { math: "\\mathbf{S}", alt: ["unicode-math"] }, "𝐓": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝐔": { math: "\\mathbf{U}", alt: ["unicode-math"] }, "𝐕": { math: "\\mathbf{V}", alt: ["unicode-math"] }, "𝐖": { math: "\\mathbf{W}", alt: ["unicode-math"] }, "𝐗": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝐘": { math: "\\mathbf{Y}", alt: ["unicode-math"] }, "𝐙": { math: "\\mathbf{Z}", alt: ["unicode-math"] }, "𝐚": { math: "\\mathbf{a}", alt: ["unicode-math"] }, "𝐛": { math: "\\mathbf{b}", alt: ["unicode-math"] }, "𝐜": { math: "\\mathbf{c}", alt: ["unicode-math"] }, "𝐝": { math: "\\mathbf{d}", alt: ["unicode-math"] }, "𝐞": { math: "\\mathbf{e}", alt: ["unicode-math"] }, "𝐟": { math: "\\mathbf{f}", alt: ["unicode-math"] }, "𝐠": { math: "\\mathbf{g}", alt: ["unicode-math"] }, "𝐡": { math: "\\mathbf{h}", alt: ["unicode-math"] }, "𝐢": { math: "\\mathbf{i}", alt: ["unicode-math"] }, "𝐣": { math: "\\mathbf{j}", alt: ["unicode-math"] }, "𝐤": { math: "\\mathbf{k}", alt: ["unicode-math"] }, "𝐥": { math: "\\mathbf{l}", alt: ["unicode-math"] }, "𝐦": { math: "\\mathbf{m}", alt: ["unicode-math"] }, "𝐧": { math: "\\mathbf{n}", alt: ["unicode-math"] }, "𝐨": { math: "\\mathbf{o}", alt: ["unicode-math"] }, "𝐩": { math: "\\mathbf{p}", alt: ["unicode-math"] }, "𝐪": { math: "\\mathbf{q}", alt: ["unicode-math"] }, "𝐫": { math: "\\mathbf{r}", alt: ["unicode-math"] }, "𝐬": { math: "\\mathbf{s}", alt: ["unicode-math"] }, "𝐭": { math: "\\mathbf{t}", alt: ["unicode-math"] }, "𝐮": { math: "\\mathbf{u}", alt: ["unicode-math"] }, "𝐯": { math: "\\mathbf{v}", alt: ["unicode-math"] }, "𝐰": { math: "\\mathbf{w}", alt: ["unicode-math"] }, "𝐱": { math: "\\mathbf{x}", alt: ["unicode-math"] }, "𝐲": { math: "\\mathbf{y}", alt: ["unicode-math"] }, "𝐳": { math: "\\mathbf{z}", alt: ["unicode-math"] }, "𝐴": { math: "A", alt: ["unicode-math"] }, "𝐵": { math: "B", alt: ["unicode-math"] }, "𝐶": { math: "C", alt: ["unicode-math"] }, "𝐷": { math: "D", alt: ["unicode-math"] }, "𝐸": { math: "E", alt: ["unicode-math"] }, "𝐹": { math: "F", alt: ["unicode-math"] }, "𝐺": { math: "G", alt: ["unicode-math"] }, "𝐻": { math: "H", alt: ["unicode-math"] }, "𝐼": { math: "I", alt: ["unicode-math"] }, "𝐽": { math: "J", alt: ["unicode-math"] }, "𝐾": { math: "K", alt: ["unicode-math"] }, "𝐿": { math: "L", alt: ["unicode-math"] }, "𝑀": { math: "M", alt: ["unicode-math"] }, "𝑁": { math: "N", alt: ["unicode-math"] }, "𝑂": { math: "O", alt: ["unicode-math"] }, "𝑃": { math: "P", alt: ["unicode-math"] }, "𝑄": { math: "Q", alt: ["unicode-math"] }, "𝑅": { math: "R", alt: ["unicode-math"] }, "𝑆": { math: "S", alt: ["unicode-math"] }, "𝑇": { math: "T", alt: ["unicode-math"] }, "𝑈": { math: "U", alt: ["unicode-math"] }, "𝑉": { math: "V", alt: ["unicode-math"] }, "𝑊": { math: "W", alt: ["unicode-math"] }, "𝑋": { math: "X", alt: ["unicode-math"] }, "𝑌": { math: "Y", alt: ["unicode-math"] }, "𝑍": { math: "Z", alt: ["unicode-math"] }, "𝑎": { math: "a", alt: ["unicode-math"] }, "𝑏": { math: "b", alt: ["unicode-math"] }, "𝑐": { math: "c", alt: ["unicode-math"] }, "𝑑": { math: "d", alt: ["unicode-math"] }, "𝑒": { math: "e", alt: ["unicode-math"] }, "𝑓": { math: "f", alt: ["unicode-math"] }, "𝑔": { math: "g", alt: ["unicode-math"] }, "𝑖": { math: "i", alt: ["unicode-math"] }, "𝑗": { math: "j", alt: ["unicode-math"] }, "𝑘": { math: "k", alt: ["unicode-math"] }, "𝑙": { math: "l", alt: ["unicode-math"] }, "𝑚": { math: "m", alt: ["unicode-math"] }, "𝑛": { math: "n", alt: ["unicode-math"] }, "𝑜": { math: "o", alt: ["unicode-math"] }, "𝑝": { math: "p", alt: ["unicode-math"] }, "𝑞": { math: "q", alt: ["unicode-math"] }, "𝑟": { math: "r", alt: ["unicode-math"] }, "𝑠": { math: "s", alt: ["unicode-math"] }, "𝑡": { math: "t", alt: ["unicode-math"] }, "𝑢": { math: "u", alt: ["unicode-math"] }, "𝑣": { math: "v", alt: ["unicode-math"] }, "𝑤": { math: "w", alt: ["unicode-math"] }, "𝑥": { math: "x", alt: ["unicode-math"] }, "𝑦": { math: "y", alt: ["unicode-math"] }, "𝑧": { math: "z", alt: ["unicode-math"] }, "𝑨": { math: "\\mathbit{A}", alt: ["unicode-math"] }, "𝑩": { math: "\\mathbit{B}", alt: ["unicode-math"] }, "𝑪": { math: "\\mathbit{C}", alt: ["unicode-math"] }, "𝑫": { math: "\\mathbit{D}", alt: ["unicode-math"] }, "𝑬": { math: "\\mathbit{E}", alt: ["unicode-math"] }, "𝑭": { math: "\\mathbit{F}", alt: ["unicode-math"] }, "𝑮": { math: "\\mathbit{G}", alt: ["unicode-math"] }, "𝑯": { math: "\\mathbit{H}", alt: ["unicode-math"] }, "𝑰": { math: "\\mathbit{I}", alt: ["unicode-math"] }, "𝑱": { math: "\\mathbit{J}", alt: ["unicode-math"] }, "𝑲": { math: "\\mathbit{K}", alt: ["unicode-math"] }, "𝑳": { math: "\\mathbit{L}", alt: ["unicode-math"] }, "𝑴": { math: "\\mathbit{M}", alt: ["unicode-math"] }, "𝑵": { math: "\\mathbit{N}", alt: ["unicode-math"] }, "𝑶": { math: "\\mathbit{O}", alt: ["unicode-math"] }, "𝑷": { math: "\\mathbit{P}", alt: ["unicode-math"] }, "𝑸": { math: "\\mathbit{Q}", alt: ["unicode-math"] }, "𝑹": { math: "\\mathbit{R}", alt: ["unicode-math"] }, "𝑺": { math: "\\mathbit{S}", alt: ["unicode-math"] }, "𝑻": { math: "\\mathbit{T}", alt: ["unicode-math"] }, "𝑼": { math: "\\mathbit{U}", alt: ["unicode-math"] }, "𝑽": { math: "\\mathbit{V}", alt: ["unicode-math"] }, "𝑾": { math: "\\mathbit{W}", alt: ["unicode-math"] }, "𝑿": { math: "\\mathbit{X}", alt: ["unicode-math"] }, "𝒀": { math: "\\mathbit{Y}", alt: ["unicode-math"] }, "𝒁": { math: "\\mathbit{Z}", alt: ["unicode-math"] }, "𝒂": { math: "\\mathbit{a}", alt: ["unicode-math"] }, "𝒃": { math: "\\mathbit{b}", alt: ["unicode-math"] }, "𝒄": { math: "\\mathbit{c}", alt: ["unicode-math"] }, "𝒅": { math: "\\mathbit{d}", alt: ["unicode-math"] }, "𝒆": { math: "\\mathbit{e}", alt: ["unicode-math"] }, "𝒇": { math: "\\mathbit{f}", alt: ["unicode-math"] }, "𝒈": { math: "\\mathbit{g}", alt: ["unicode-math"] }, "𝒉": { math: "\\mathbit{h}", alt: ["unicode-math"] }, "𝒊": { math: "\\mathbit{i}", alt: ["unicode-math"] }, "𝒋": { math: "\\mathbit{j}", alt: ["unicode-math"] }, "𝒌": { math: "\\mathbit{k}", alt: ["unicode-math"] }, "𝒍": { math: "\\mathbit{l}", alt: ["unicode-math"] }, "𝒎": { math: "\\mathbit{m}", alt: ["unicode-math"] }, "𝒏": { math: "\\mathbit{n}", alt: ["unicode-math"] }, "𝒐": { math: "\\mathbit{o}", alt: ["unicode-math"] }, "𝒑": { math: "\\mathbit{p}", alt: ["unicode-math"] }, "𝒒": { math: "\\mathbit{q}", alt: ["unicode-math"] }, "𝒓": { math: "\\mathbit{r}", alt: ["unicode-math"] }, "𝒔": { math: "\\mathbit{s}", alt: ["unicode-math"] }, "𝒕": { math: "\\mathbit{t}", alt: ["unicode-math"] }, "𝒖": { math: "\\mathbit{u}", alt: ["unicode-math"] }, "𝒗": { math: "\\mathbit{v}", alt: ["unicode-math"] }, "𝒘": { math: "\\mathbit{w}", alt: ["unicode-math"] }, "𝒙": { math: "\\mathbit{x}", alt: ["unicode-math"] }, "𝒚": { math: "\\mathbit{y}", alt: ["unicode-math"] }, "𝒛": { math: "\\mathbit{z}", alt: ["unicode-math"] }, "𝓐": { math: "\\mathmit{A}", alt: ["unicode-math"] }, "𝓑": { math: "\\mathmit{B}", alt: ["unicode-math"] }, "𝓒": { math: "\\mathmit{C}", alt: ["unicode-math"] }, "𝓓": { math: "\\mathmit{D}", alt: ["unicode-math"] }, "𝓔": { math: "\\mathmit{E}", alt: ["unicode-math"] }, "𝓕": { math: "\\mathmit{F}", alt: ["unicode-math"] }, "𝓖": { math: "\\mathmit{G}", alt: ["unicode-math"] }, "𝓗": { math: "\\mathmit{H}", alt: ["unicode-math"] }, "𝓘": { math: "\\mathmit{I}", alt: ["unicode-math"] }, "𝓙": { math: "\\mathmit{J}", alt: ["unicode-math"] }, "𝓚": { math: "\\mathmit{K}", alt: ["unicode-math"] }, "𝓛": { math: "\\mathmit{L}", alt: ["unicode-math"] }, "𝓜": { math: "\\mathmit{M}", alt: ["unicode-math"] }, "𝓝": { math: "\\mathmit{N}", alt: ["unicode-math"] }, "𝓞": { math: "\\mathmit{O}", alt: ["unicode-math"] }, "𝓟": { math: "\\mathmit{P}", alt: ["unicode-math"] }, "𝓠": { math: "\\mathmit{Q}", alt: ["unicode-math"] }, "𝓡": { math: "\\mathmit{R}", alt: ["unicode-math"] }, "𝓢": { math: "\\mathmit{S}", alt: ["unicode-math"] }, "𝓣": { math: "\\mathmit{T}", alt: ["unicode-math"] }, "𝓤": { math: "\\mathmit{U}", alt: ["unicode-math"] }, "𝓥": { math: "\\mathmit{V}", alt: ["unicode-math"] }, "𝓦": { math: "\\mathmit{W}", alt: ["unicode-math"] }, "𝓧": { math: "\\mathmit{X}", alt: ["unicode-math"] }, "𝓨": { math: "\\mathmit{Y}", alt: ["unicode-math"] }, "𝓩": { math: "\\mathmit{Z}", alt: ["unicode-math"] }, "𝓪": { math: "\\mathmit{a}", alt: ["unicode-math"] }, "𝓫": { math: "\\mathmit{b}", alt: ["unicode-math"] }, "𝓬": { math: "\\mathmit{c}", alt: ["unicode-math"] }, "𝓭": { math: "\\mathmit{d}", alt: ["unicode-math"] }, "𝓮": { math: "\\mathmit{e}", alt: ["unicode-math"] }, "𝓯": { math: "\\mathmit{f}", alt: ["unicode-math"] }, "𝓰": { math: "\\mathmit{g}", alt: ["unicode-math"] }, "𝓱": { math: "\\mathmit{h}", alt: ["unicode-math"] }, "𝓲": { math: "\\mathmit{i}", alt: ["unicode-math"] }, "𝓳": { math: "\\mathmit{j}", alt: ["unicode-math"] }, "𝓴": { math: "\\mathmit{k}", alt: ["unicode-math"] }, "𝓵": { math: "\\mathmit{l}", alt: ["unicode-math"] }, "𝓶": { math: "\\mathmit{m}", alt: ["unicode-math"] }, "𝓷": { math: "\\mathmit{n}", alt: ["unicode-math"] }, "𝓸": { math: "\\mathmit{o}", alt: ["unicode-math"] }, "𝓹": { math: "\\mathmit{p}", alt: ["unicode-math"] }, "𝓺": { math: "\\mathmit{q}", alt: ["unicode-math"] }, "𝓻": { math: "\\mathmit{r}", alt: ["unicode-math"] }, "𝓼": { math: "\\mathmit{s}", alt: ["unicode-math"] }, "𝓽": { math: "\\mathmit{t}", alt: ["unicode-math"] }, "𝓾": { math: "\\mathmit{u}", alt: ["unicode-math"] }, "𝓿": { math: "\\mathmit{v}", alt: ["unicode-math"] }, "𝔀": { math: "\\mathmit{w}", alt: ["unicode-math"] }, "𝔁": { math: "\\mathmit{x}", alt: ["unicode-math"] }, "𝔂": { math: "\\mathmit{y}", alt: ["unicode-math"] }, "𝔃": { math: "\\mathmit{z}", alt: ["unicode-math"] }, "𝔄": { math: "\\mathfrak{A}", alt: ["unicode-math"] }, "𝔅": { math: "\\mathfrak{B}", alt: ["unicode-math"] }, "𝔇": { math: "\\mathfrak{D}", alt: ["unicode-math"] }, "𝔈": { math: "\\mathfrak{E}", alt: ["unicode-math"] }, "𝔉": { math: "\\mathfrak{F}", alt: ["unicode-math"] }, "𝔊": { math: "\\mathfrak{G}", alt: ["unicode-math"] }, "𝔍": { math: "\\mathfrak{J}", alt: ["unicode-math"] }, "𝔎": { math: "\\mathfrak{K}", alt: ["unicode-math"] }, "𝔏": { math: "\\mathfrak{L}", alt: ["unicode-math"] }, "𝔐": { math: "\\mathfrak{M}", alt: ["unicode-math"] }, "𝔑": { math: "\\mathfrak{N}", alt: ["unicode-math"] }, "𝔒": { math: "\\mathfrak{O}", alt: ["unicode-math"] }, "𝔓": { math: "\\mathfrak{P}", alt: ["unicode-math"] }, "𝔔": { math: "\\mathfrak{Q}", alt: ["unicode-math"] }, "𝔖": { math: "\\mathfrak{S}", alt: ["unicode-math"] }, "𝔗": { math: "\\mathfrak{T}", alt: ["unicode-math"] }, "𝔘": { math: "\\mathfrak{U}", alt: ["unicode-math"] }, "𝔙": { math: "\\mathfrak{V}", alt: ["unicode-math"] }, "𝔚": { math: "\\mathfrak{W}", alt: ["unicode-math"] }, "𝔛": { math: "\\mathfrak{X}", alt: ["unicode-math"] }, "𝔜": { math: "\\mathfrak{Y}", alt: ["unicode-math"] }, "𝔞": { math: "\\mathfrak{a}", alt: ["unicode-math"] }, "𝔟": { math: "\\mathfrak{b}", alt: ["unicode-math"] }, "𝔠": { math: "\\mathfrak{c}", alt: ["unicode-math"] }, "𝔡": { math: "\\mathfrak{d}", alt: ["unicode-math"] }, "𝔢": { math: "\\mathfrak{e}", alt: ["unicode-math"] }, "𝔣": { math: "\\mathfrak{f}", alt: ["unicode-math"] }, "𝔤": { math: "\\mathfrak{g}", alt: ["unicode-math"] }, "𝔥": { math: "\\mathfrak{h}", alt: ["unicode-math"] }, "𝔦": { math: "\\mathfrak{i}", alt: ["unicode-math"] }, "𝔧": { math: "\\mathfrak{j}", alt: ["unicode-math"] }, "𝔨": { math: "\\mathfrak{k}", alt: ["unicode-math"] }, "𝔩": { math: "\\mathfrak{l}", alt: ["unicode-math"] }, "𝔪": { math: "\\mathfrak{m}", alt: ["unicode-math"] }, "𝔫": { math: "\\mathfrak{n}", alt: ["unicode-math"] }, "𝔬": { math: "\\mathfrak{o}", alt: ["unicode-math"] }, "𝔭": { math: "\\mathfrak{p}", alt: ["unicode-math"] }, "𝔮": { math: "\\mathfrak{q}", alt: ["unicode-math"] }, "𝔯": { math: "\\mathfrak{r}", alt: ["unicode-math"] }, "𝔰": { math: "\\mathfrak{s}", alt: ["unicode-math"] }, "𝔱": { math: "\\mathfrak{t}", alt: ["unicode-math"] }, "𝔲": { math: "\\mathfrak{u}", alt: ["unicode-math"] }, "𝔳": { math: "\\mathfrak{v}", alt: ["unicode-math"] }, "𝔴": { math: "\\mathfrak{w}", alt: ["unicode-math"] }, "𝔵": { math: "\\mathfrak{x}", alt: ["unicode-math"] }, "𝔶": { math: "\\mathfrak{y}", alt: ["unicode-math"] }, "𝔷": { math: "\\mathfrak{z}", alt: ["unicode-math"] }, "𝔸": { math: "\\mathbb{A}", alt: ["unicode-math"] }, "𝔹": { math: "\\mathbb{B}", alt: ["unicode-math"] }, "𝔻": { math: "\\mathbb{D}", alt: ["unicode-math"] }, "𝔼": { math: "\\mathbb{E}", alt: ["unicode-math"] }, "𝔽": { math: "\\mathbb{F}", alt: ["unicode-math"] }, "𝔾": { math: "\\mathbb{G}", alt: ["unicode-math"] }, "𝕀": { math: "\\mathbb{I}", alt: ["unicode-math"] }, "𝕁": { math: "\\mathbb{J}", alt: ["unicode-math"] }, "𝕂": { math: "\\mathbb{K}", alt: ["unicode-math"] }, "𝕃": { math: "\\mathbb{L}", alt: ["unicode-math"] }, "𝕄": { math: "\\mathbb{M}", alt: ["unicode-math"] }, "𝕆": { math: "\\mathbb{O}", alt: ["unicode-math"] }, "𝕊": { math: "\\mathbb{S}", alt: ["unicode-math"] }, "𝕋": { math: "\\mathbb{T}", alt: ["unicode-math"] }, "𝕌": { math: "\\mathbb{U}", alt: ["unicode-math"] }, "𝕍": { math: "\\mathbb{V}", alt: ["unicode-math"] }, "𝕎": { math: "\\mathbb{W}", alt: ["unicode-math"] }, "𝕏": { math: "\\mathbb{X}", alt: ["unicode-math"] }, "𝕐": { math: "\\mathbb{Y}", alt: ["unicode-math"] }, "𝕒": { math: "\\mathbb{a}", alt: ["unicode-math"] }, "𝕓": { math: "\\mathbb{b}", alt: ["unicode-math"] }, "𝕔": { math: "\\mathbb{c}", alt: ["unicode-math"] }, "𝕕": { math: "\\mathbb{d}", alt: ["unicode-math"] }, "𝕖": { math: "\\mathbb{e}", alt: ["unicode-math"] }, "𝕗": { math: "\\mathbb{f}", alt: ["unicode-math"] }, "𝕘": { math: "\\mathbb{g}", alt: ["unicode-math"] }, "𝕙": { math: "\\mathbb{h}", alt: ["unicode-math"] }, "𝕚": { math: "\\mathbb{i}", alt: ["unicode-math"] }, "𝕛": { math: "\\mathbb{j}", alt: ["unicode-math"] }, "𝕜": { math: "\\mathbb{k}", alt: ["unicode-math"] }, "𝕝": { math: "\\mathbb{l}", alt: ["unicode-math"] }, "𝕞": { math: "\\mathbb{m}", alt: ["unicode-math"] }, "𝕟": { math: "\\mathbb{n}", alt: ["unicode-math"] }, "𝕠": { math: "\\mathbb{o}", alt: ["unicode-math"] }, "𝕡": { math: "\\mathbb{p}", alt: ["unicode-math"] }, "𝕢": { math: "\\mathbb{q}", alt: ["unicode-math"] }, "𝕣": { math: "\\mathbb{r}", alt: ["unicode-math"] }, "𝕤": { math: "\\mathbb{s}", alt: ["unicode-math"] }, "𝕥": { math: "\\mathbb{t}", alt: ["unicode-math"] }, "𝕦": { math: "\\mathbb{u}", alt: ["unicode-math"] }, "𝕧": { math: "\\mathbb{v}", alt: ["unicode-math"] }, "𝕨": { math: "\\mathbb{w}", alt: ["unicode-math"] }, "𝕩": { math: "\\mathbb{x}", alt: ["unicode-math"] }, "𝕪": { math: "\\mathbb{y}", alt: ["unicode-math"] }, "𝕫": { math: "\\mathbb{z}", alt: ["unicode-math"] }, "𝕬": { math: "A", alt: ["unicode-math"] }, "𝕭": { math: "B", alt: ["unicode-math"] }, "𝕮": { math: "C", alt: ["unicode-math"] }, "𝕯": { math: "D", alt: ["unicode-math"] }, "𝕰": { math: "E", alt: ["unicode-math"] }, "𝕱": { math: "F", alt: ["unicode-math"] }, "𝕲": { math: "G", alt: ["unicode-math"] }, "𝕳": { math: "H", alt: ["unicode-math"] }, "𝕴": { math: "I", alt: ["unicode-math"] }, "𝕵": { math: "J", alt: ["unicode-math"] }, "𝕶": { math: "K", alt: ["unicode-math"] }, "𝕷": { math: "L", alt: ["unicode-math"] }, "𝕸": { math: "M", alt: ["unicode-math"] }, "𝕹": { math: "N", alt: ["unicode-math"] }, "𝕺": { math: "O", alt: ["unicode-math"] }, "𝕻": { math: "P", alt: ["unicode-math"] }, "𝕼": { math: "Q", alt: ["unicode-math"] }, "𝕽": { math: "R", alt: ["unicode-math"] }, "𝕾": { math: "S", alt: ["unicode-math"] }, "𝕿": { math: "T", alt: ["unicode-math"] }, "𝖀": { math: "U", alt: ["unicode-math"] }, "𝖁": { math: "V", alt: ["unicode-math"] }, "𝖂": { math: "W", alt: ["unicode-math"] }, "𝖃": { math: "X", alt: ["unicode-math"] }, "𝖄": { math: "Y", alt: ["unicode-math"] }, "𝖅": { math: "Z", alt: ["unicode-math"] }, "𝖆": { math: "a", alt: ["unicode-math"] }, "𝖇": { math: "b", alt: ["unicode-math"] }, "𝖈": { math: "c", alt: ["unicode-math"] }, "𝖉": { math: "d", alt: ["unicode-math"] }, "𝖊": { math: "e", alt: ["unicode-math"] }, "𝖋": { math: "f", alt: ["unicode-math"] }, "𝖌": { math: "g", alt: ["unicode-math"] }, "𝖍": { math: "h", alt: ["unicode-math"] }, "𝖎": { math: "i", alt: ["unicode-math"] }, "𝖏": { math: "j", alt: ["unicode-math"] }, "𝖐": { math: "k", alt: ["unicode-math"] }, "𝖑": { math: "l", alt: ["unicode-math"] }, "𝖒": { math: "m", alt: ["unicode-math"] }, "𝖓": { math: "n", alt: ["unicode-math"] }, "𝖔": { math: "o", alt: ["unicode-math"] }, "𝖕": { math: "p", alt: ["unicode-math"] }, "𝖖": { math: "q", alt: ["unicode-math"] }, "𝖗": { math: "r", alt: ["unicode-math"] }, "𝖘": { math: "s", alt: ["unicode-math"] }, "𝖙": { math: "t", alt: ["unicode-math"] }, "𝖚": { math: "u", alt: ["unicode-math"] }, "𝖛": { math: "v", alt: ["unicode-math"] }, "𝖜": { math: "w", alt: ["unicode-math"] }, "𝖝": { math: "x", alt: ["unicode-math"] }, "𝖞": { math: "y", alt: ["unicode-math"] }, "𝖟": { math: "z", alt: ["unicode-math"] }, "𝖠": { math: "\\mathsf{A}", alt: ["unicode-math"] }, "𝖡": { math: "\\mathsf{B}", alt: ["unicode-math"] }, "𝖢": { math: "\\mathsf{C}", alt: ["unicode-math"] }, "𝖣": { math: "\\mathsf{D}", alt: ["unicode-math"] }, "𝖤": { math: "\\mathsf{E}", alt: ["unicode-math"] }, "𝖥": { math: "\\mathsf{F}", alt: ["unicode-math"] }, "𝖦": { math: "\\mathsf{G}", alt: ["unicode-math"] }, "𝖧": { math: "\\mathsf{H}", alt: ["unicode-math"] }, "𝖨": { math: "\\mathsf{I}", alt: ["unicode-math"] }, "𝖩": { math: "\\mathsf{J}", alt: ["unicode-math"] }, "𝖪": { math: "\\mathsf{K}", alt: ["unicode-math"] }, "𝖫": { math: "\\mathsf{L}", alt: ["unicode-math"] }, "𝖬": { math: "\\mathsf{M}", alt: ["unicode-math"] }, "𝖭": { math: "\\mathsf{N}", alt: ["unicode-math"] }, "𝖮": { math: "\\mathsf{O}", alt: ["unicode-math"] }, "𝖯": { math: "\\mathsf{P}", alt: ["unicode-math"] }, "𝖰": { math: "\\mathsf{Q}", alt: ["unicode-math"] }, "𝖱": { math: "\\mathsf{R}", alt: ["unicode-math"] }, "𝖲": { math: "\\mathsf{S}", alt: ["unicode-math"] }, "𝖳": { math: "\\mathsf{T}", alt: ["unicode-math"] }, "𝖴": { math: "\\mathsf{U}", alt: ["unicode-math"] }, "𝖵": { math: "\\mathsf{V}", alt: ["unicode-math"] }, "𝖶": { math: "\\mathsf{W}", alt: ["unicode-math"] }, "𝖷": { math: "\\mathsf{X}", alt: ["unicode-math"] }, "𝖸": { math: "\\mathsf{Y}", alt: ["unicode-math"] }, "𝖹": { math: "\\mathsf{Z}", alt: ["unicode-math"] }, "𝖺": { math: "\\mathsf{a}", alt: ["unicode-math"] }, "𝖻": { math: "\\mathsf{b}", alt: ["unicode-math"] }, "𝖼": { math: "\\mathsf{c}", alt: ["unicode-math"] }, "𝖽": { math: "\\mathsf{d}", alt: ["unicode-math"] }, "𝖾": { math: "\\mathsf{e}", alt: ["unicode-math"] }, "𝖿": { math: "\\mathsf{f}", alt: ["unicode-math"] }, "𝗀": { math: "\\mathsf{g}", alt: ["unicode-math"] }, "𝗁": { math: "\\mathsf{h}", alt: ["unicode-math"] }, "𝗂": { math: "\\mathsf{i}", alt: ["unicode-math"] }, "𝗃": { math: "\\mathsf{j}", alt: ["unicode-math"] }, "𝗄": { math: "\\mathsf{k}", alt: ["unicode-math"] }, "𝗅": { math: "\\mathsf{l}", alt: ["unicode-math"] }, "𝗆": { math: "\\mathsf{m}", alt: ["unicode-math"] }, "𝗇": { math: "\\mathsf{n}", alt: ["unicode-math"] }, "𝗈": { math: "\\mathsf{o}", alt: ["unicode-math"] }, "𝗉": { math: "\\mathsf{p}", alt: ["unicode-math"] }, "𝗊": { math: "\\mathsf{q}", alt: ["unicode-math"] }, "𝗋": { math: "\\mathsf{r}", alt: ["unicode-math"] }, "𝗌": { math: "\\mathsf{s}", alt: ["unicode-math"] }, "𝗍": { math: "\\mathsf{t}", alt: ["unicode-math"] }, "𝗎": { math: "\\mathsf{u}", alt: ["unicode-math"] }, "𝗏": { math: "\\mathsf{v}", alt: ["unicode-math"] }, "𝗐": { math: "\\mathsf{w}", alt: ["unicode-math"] }, "𝗑": { math: "\\mathsf{x}", alt: ["unicode-math"] }, "𝗒": { math: "\\mathsf{y}", alt: ["unicode-math"] }, "𝗓": { math: "\\mathsf{z}", alt: ["unicode-math"] }, "𝗔": { math: "\\mathsfbf{A}", alt: ["unicode-math"] }, "𝗕": { math: "\\mathsfbf{B}", alt: ["unicode-math"] }, "𝗖": { math: "\\mathsfbf{C}", alt: ["unicode-math"] }, "𝗗": { math: "\\mathsfbf{D}", alt: ["unicode-math"] }, "𝗘": { math: "\\mathsfbf{E}", alt: ["unicode-math"] }, "𝗙": { math: "\\mathsfbf{F}", alt: ["unicode-math"] }, "𝗚": { math: "\\mathsfbf{G}", alt: ["unicode-math"] }, "𝗛": { math: "\\mathsfbf{H}", alt: ["unicode-math"] }, "𝗜": { math: "\\mathsfbf{I}", alt: ["unicode-math"] }, "𝗝": { math: "\\mathsfbf{J}", alt: ["unicode-math"] }, "𝗞": { math: "\\mathsfbf{K}", alt: ["unicode-math"] }, "𝗟": { math: "\\mathsfbf{L}", alt: ["unicode-math"] }, "𝗠": { math: "\\mathsfbf{M}", alt: ["unicode-math"] }, "𝗡": { math: "\\mathsfbf{N}", alt: ["unicode-math"] }, "𝗢": { math: "\\mathsfbf{O}", alt: ["unicode-math"] }, "𝗣": { math: "\\mathsfbf{P}", alt: ["unicode-math"] }, "𝗤": { math: "\\mathsfbf{Q}", alt: ["unicode-math"] }, "𝗥": { math: "\\mathsfbf{R}", alt: ["unicode-math"] }, "𝗦": { math: "\\mathsfbf{S}", alt: ["unicode-math"] }, "𝗧": { math: "\\mathsfbf{T}", alt: ["unicode-math"] }, "𝗨": { math: "\\mathsfbf{U}", alt: ["unicode-math"] }, "𝗩": { math: "\\mathsfbf{V}", alt: ["unicode-math"] }, "𝗪": { math: "\\mathsfbf{W}", alt: ["unicode-math"] }, "𝗫": { math: "\\mathsfbf{X}", alt: ["unicode-math"] }, "𝗬": { math: "\\mathsfbf{Y}", alt: ["unicode-math"] }, "𝗭": { math: "\\mathsfbf{Z}", alt: ["unicode-math"] }, "𝗮": { math: "\\mathsfbf{a}", alt: ["unicode-math"] }, "𝗯": { math: "\\mathsfbf{b}", alt: ["unicode-math"] }, "𝗰": { math: "\\mathsfbf{c}", alt: ["unicode-math"] }, "𝗱": { math: "\\mathsfbf{d}", alt: ["unicode-math"] }, "𝗲": { math: "\\mathsfbf{e}", alt: ["unicode-math"] }, "𝗳": { math: "\\mathsfbf{f}", alt: ["unicode-math"] }, "𝗴": { math: "\\mathsfbf{g}", alt: ["unicode-math"] }, "𝗵": { math: "\\mathsfbf{h}", alt: ["unicode-math"] }, "𝗶": { math: "\\mathsfbf{i}", alt: ["unicode-math"] }, "𝗷": { math: "\\mathsfbf{j}", alt: ["unicode-math"] }, "𝗸": { math: "\\mathsfbf{k}", alt: ["unicode-math"] }, "𝗹": { math: "\\mathsfbf{l}", alt: ["unicode-math"] }, "𝗺": { math: "\\mathsfbf{m}", alt: ["unicode-math"] }, "𝗻": { math: "\\mathsfbf{n}", alt: ["unicode-math"] }, "𝗼": { math: "\\mathsfbf{o}", alt: ["unicode-math"] }, "𝗽": { math: "\\mathsfbf{p}", alt: ["unicode-math"] }, "𝗾": { math: "\\mathsfbf{q}", alt: ["unicode-math"] }, "𝗿": { math: "\\mathsfbf{r}", alt: ["unicode-math"] }, "𝘀": { math: "\\mathsfbf{s}", alt: ["unicode-math"] }, "𝘁": { math: "\\mathsfbf{t}", alt: ["unicode-math"] }, "𝘂": { math: "\\mathsfbf{u}", alt: ["unicode-math"] }, "𝘃": { math: "\\mathsfbf{v}", alt: ["unicode-math"] }, "𝘄": { math: "\\mathsfbf{w}", alt: ["unicode-math"] }, "𝘅": { math: "\\mathsfbf{x}", alt: ["unicode-math"] }, "𝘆": { math: "\\mathsfbf{y}", alt: ["unicode-math"] }, "𝘇": { math: "\\mathsfbf{z}", alt: ["unicode-math"] }, "𝘈": { math: "\\mathsfsl{A}", alt: ["unicode-math"] }, "𝘉": { math: "\\mathsfsl{B}", alt: ["unicode-math"] }, "𝘊": { math: "\\mathsfsl{C}", alt: ["unicode-math"] }, "𝘋": { math: "\\mathsfsl{D}", alt: ["unicode-math"] }, "𝘌": { math: "\\mathsfsl{E}", alt: ["unicode-math"] }, "𝘍": { math: "\\mathsfsl{F}", alt: ["unicode-math"] }, "𝘎": { math: "\\mathsfsl{G}", alt: ["unicode-math"] }, "𝘏": { math: "\\mathsfsl{H}", alt: ["unicode-math"] }, "𝘐": { math: "\\mathsfsl{I}", alt: ["unicode-math"] }, "𝘑": { math: "\\mathsfsl{J}", alt: ["unicode-math"] }, "𝘒": { math: "\\mathsfsl{K}", alt: ["unicode-math"] }, "𝘓": { math: "\\mathsfsl{L}", alt: ["unicode-math"] }, "𝘔": { math: "\\mathsfsl{M}", alt: ["unicode-math"] }, "𝘕": { math: "\\mathsfsl{N}", alt: ["unicode-math"] }, "𝘖": { math: "\\mathsfsl{O}", alt: ["unicode-math"] }, "𝘗": { math: "\\mathsfsl{P}", alt: ["unicode-math"] }, "𝘘": { math: "\\mathsfsl{Q}", alt: ["unicode-math"] }, "𝘙": { math: "\\mathsfsl{R}", alt: ["unicode-math"] }, "𝘚": { math: "\\mathsfsl{S}", alt: ["unicode-math"] }, "𝘛": { math: "\\mathsfsl{T}", alt: ["unicode-math"] }, "𝘜": { math: "\\mathsfsl{U}", alt: ["unicode-math"] }, "𝘝": { math: "\\mathsfsl{V}", alt: ["unicode-math"] }, "𝘞": { math: "\\mathsfsl{W}", alt: ["unicode-math"] }, "𝘟": { math: "\\mathsfsl{X}", alt: ["unicode-math"] }, "𝘠": { math: "\\mathsfsl{Y}", alt: ["unicode-math"] }, "𝘡": { math: "\\mathsfsl{Z}", alt: ["unicode-math"] }, "𝘢": { math: "\\mathsfsl{a}", alt: ["unicode-math"] }, "𝘣": { math: "\\mathsfsl{b}", alt: ["unicode-math"] }, "𝘤": { math: "\\mathsfsl{c}", alt: ["unicode-math"] }, "𝘥": { math: "\\mathsfsl{d}", alt: ["unicode-math"] }, "𝘦": { math: "\\mathsfsl{e}", alt: ["unicode-math"] }, "𝘧": { math: "\\mathsfsl{f}", alt: ["unicode-math"] }, "𝘨": { math: "\\mathsfsl{g}", alt: ["unicode-math"] }, "𝘩": { math: "\\mathsfsl{h}", alt: ["unicode-math"] }, "𝘪": { math: "\\mathsfsl{i}", alt: ["unicode-math"] }, "𝘫": { math: "\\mathsfsl{j}", alt: ["unicode-math"] }, "𝘬": { math: "\\mathsfsl{k}", alt: ["unicode-math"] }, "𝘭": { math: "\\mathsfsl{l}", alt: ["unicode-math"] }, "𝘮": { math: "\\mathsfsl{m}", alt: ["unicode-math"] }, "𝘯": { math: "\\mathsfsl{n}", alt: ["unicode-math"] }, "𝘰": { math: "\\mathsfsl{o}", alt: ["unicode-math"] }, "𝘱": { math: "\\mathsfsl{p}", alt: ["unicode-math"] }, "𝘲": { math: "\\mathsfsl{q}", alt: ["unicode-math"] }, "𝘳": { math: "\\mathsfsl{r}", alt: ["unicode-math"] }, "𝘴": { math: "\\mathsfsl{s}", alt: ["unicode-math"] }, "𝘵": { math: "\\mathsfsl{t}", alt: ["unicode-math"] }, "𝘶": { math: "\\mathsfsl{u}", alt: ["unicode-math"] }, "𝘷": { math: "\\mathsfsl{v}", alt: ["unicode-math"] }, "𝘸": { math: "\\mathsfsl{w}", alt: ["unicode-math"] }, "𝘹": { math: "\\mathsfsl{x}", alt: ["unicode-math"] }, "𝘺": { math: "\\mathsfsl{y}", alt: ["unicode-math"] }, "𝘻": { math: "\\mathsfsl{z}", alt: ["unicode-math"] }, "𝘼": { math: "\\mathsfbfsl{A}", alt: ["unicode-math"] }, "𝘽": { math: "\\mathsfbfsl{B}", alt: ["unicode-math"] }, "𝘾": { math: "\\mathsfbfsl{C}", alt: ["unicode-math"] }, "𝘿": { math: "\\mathsfbfsl{D}", alt: ["unicode-math"] }, "𝙀": { math: "\\mathsfbfsl{E}", alt: ["unicode-math"] }, "𝙁": { math: "\\mathsfbfsl{F}", alt: ["unicode-math"] }, "𝙂": { math: "\\mathsfbfsl{G}", alt: ["unicode-math"] }, "𝙃": { math: "\\mathsfbfsl{H}", alt: ["unicode-math"] }, "𝙄": { math: "\\mathsfbfsl{I}", alt: ["unicode-math"] }, "𝙅": { math: "\\mathsfbfsl{J}", alt: ["unicode-math"] }, "𝙆": { math: "\\mathsfbfsl{K}", alt: ["unicode-math"] }, "𝙇": { math: "\\mathsfbfsl{L}", alt: ["unicode-math"] }, "𝙈": { math: "\\mathsfbfsl{M}", alt: ["unicode-math"] }, "𝙉": { math: "\\mathsfbfsl{N}", alt: ["unicode-math"] }, "𝙊": { math: "\\mathsfbfsl{O}", alt: ["unicode-math"] }, "𝙋": { math: "\\mathsfbfsl{P}", alt: ["unicode-math"] }, "𝙌": { math: "\\mathsfbfsl{Q}", alt: ["unicode-math"] }, "𝙍": { math: "\\mathsfbfsl{R}", alt: ["unicode-math"] }, "𝙎": { math: "\\mathsfbfsl{S}", alt: ["unicode-math"] }, "𝙏": { math: "\\mathsfbfsl{T}", alt: ["unicode-math"] }, "𝙐": { math: "\\mathsfbfsl{U}", alt: ["unicode-math"] }, "𝙑": { math: "\\mathsfbfsl{V}", alt: ["unicode-math"] }, "𝙒": { math: "\\mathsfbfsl{W}", alt: ["unicode-math"] }, "𝙓": { math: "\\mathsfbfsl{X}", alt: ["unicode-math"] }, "𝙔": { math: "\\mathsfbfsl{Y}", alt: ["unicode-math"] }, "𝙕": { math: "\\mathsfbfsl{Z}", alt: ["unicode-math"] }, "𝙖": { math: "\\mathsfbfsl{a}", alt: ["unicode-math"] }, "𝙗": { math: "\\mathsfbfsl{b}", alt: ["unicode-math"] }, "𝙘": { math: "\\mathsfbfsl{c}", alt: ["unicode-math"] }, "𝙙": { math: "\\mathsfbfsl{d}", alt: ["unicode-math"] }, "𝙚": { math: "\\mathsfbfsl{e}", alt: ["unicode-math"] }, "𝙛": { math: "\\mathsfbfsl{f}", alt: ["unicode-math"] }, "𝙜": { math: "\\mathsfbfsl{g}", alt: ["unicode-math"] }, "𝙝": { math: "\\mathsfbfsl{h}", alt: ["unicode-math"] }, "𝙞": { math: "\\mathsfbfsl{i}", alt: ["unicode-math"] }, "𝙟": { math: "\\mathsfbfsl{j}", alt: ["unicode-math"] }, "𝙠": { math: "\\mathsfbfsl{k}", alt: ["unicode-math"] }, "𝙡": { math: "\\mathsfbfsl{l}", alt: ["unicode-math"] }, "𝙢": { math: "\\mathsfbfsl{m}", alt: ["unicode-math"] }, "𝙣": { math: "\\mathsfbfsl{n}", alt: ["unicode-math"] }, "𝙤": { math: "\\mathsfbfsl{o}", alt: ["unicode-math"] }, "𝙥": { math: "\\mathsfbfsl{p}", alt: ["unicode-math"] }, "𝙦": { math: "\\mathsfbfsl{q}", alt: ["unicode-math"] }, "𝙧": { math: "\\mathsfbfsl{r}", alt: ["unicode-math"] }, "𝙨": { math: "\\mathsfbfsl{s}", alt: ["unicode-math"] }, "𝙩": { math: "\\mathsfbfsl{t}", alt: ["unicode-math"] }, "𝙪": { math: "\\mathsfbfsl{u}", alt: ["unicode-math"] }, "𝙫": { math: "\\mathsfbfsl{v}", alt: ["unicode-math"] }, "𝙬": { math: "\\mathsfbfsl{w}", alt: ["unicode-math"] }, "𝙭": { math: "\\mathsfbfsl{x}", alt: ["unicode-math"] }, "𝙮": { math: "\\mathsfbfsl{y}", alt: ["unicode-math"] }, "𝙯": { math: "\\mathsfbfsl{z}", alt: ["unicode-math"] }, "𝙰": { math: "\\mathtt{A}", alt: ["unicode-math"] }, "𝙱": { math: "\\mathtt{B}", alt: ["unicode-math"] }, "𝙲": { math: "\\mathtt{C}", alt: ["unicode-math"] }, "𝙳": { math: "\\mathtt{D}", alt: ["unicode-math"] }, "𝙴": { math: "\\mathtt{E}", alt: ["unicode-math"] }, "𝙵": { math: "\\mathtt{F}", alt: ["unicode-math"] }, "𝙶": { math: "\\mathtt{G}", alt: ["unicode-math"] }, "𝙷": { math: "\\mathtt{H}", alt: ["unicode-math"] }, "𝙸": { math: "\\mathtt{I}", alt: ["unicode-math"] }, "𝙹": { math: "\\mathtt{J}", alt: ["unicode-math"] }, "𝙺": { math: "\\mathtt{K}", alt: ["unicode-math"] }, "𝙻": { math: "\\mathtt{L}", alt: ["unicode-math"] }, "𝙼": { math: "\\mathtt{M}", alt: ["unicode-math"] }, "𝙽": { math: "\\mathtt{N}", alt: ["unicode-math"] }, "𝙾": { math: "\\mathtt{O}", alt: ["unicode-math"] }, "𝙿": { math: "\\mathtt{P}", alt: ["unicode-math"] }, "𝚀": { math: "\\mathtt{Q}", alt: ["unicode-math"] }, "𝚁": { math: "\\mathtt{R}", alt: ["unicode-math"] }, "𝚂": { math: "\\mathtt{S}", alt: ["unicode-math"] }, "𝚃": { math: "\\mathtt{T}", alt: ["unicode-math"] }, "𝚄": { math: "\\mathtt{U}", alt: ["unicode-math"] }, "𝚅": { math: "\\mathtt{V}", alt: ["unicode-math"] }, "𝚆": { math: "\\mathtt{W}", alt: ["unicode-math"] }, "𝚇": { math: "\\mathtt{X}", alt: ["unicode-math"] }, "𝚈": { math: "\\mathtt{Y}", alt: ["unicode-math"] }, "𝚉": { math: "\\mathtt{Z}", alt: ["unicode-math"] }, "𝚊": { math: "\\mathtt{a}", alt: ["unicode-math"] }, "𝚋": { math: "\\mathtt{b}", alt: ["unicode-math"] }, "𝚌": { math: "\\mathtt{c}", alt: ["unicode-math"] }, "𝚍": { math: "\\mathtt{d}", alt: ["unicode-math"] }, "𝚎": { math: "\\mathtt{e}", alt: ["unicode-math"] }, "𝚏": { math: "\\mathtt{f}", alt: ["unicode-math"] }, "𝚐": { math: "\\mathtt{g}", alt: ["unicode-math"] }, "𝚑": { math: "\\mathtt{h}", alt: ["unicode-math"] }, "𝚒": { math: "\\mathtt{i}", alt: ["unicode-math"] }, "𝚓": { math: "\\mathtt{j}", alt: ["unicode-math"] }, "𝚔": { math: "\\mathtt{k}", alt: ["unicode-math"] }, "𝚕": { math: "\\mathtt{l}", alt: ["unicode-math"] }, "𝚖": { math: "\\mathtt{m}", alt: ["unicode-math"] }, "𝚗": { math: "\\mathtt{n}", alt: ["unicode-math"] }, "𝚘": { math: "\\mathtt{o}", alt: ["unicode-math"] }, "𝚙": { math: "\\mathtt{p}", alt: ["unicode-math"] }, "𝚚": { math: "\\mathtt{q}", alt: ["unicode-math"] }, "𝚛": { math: "\\mathtt{r}", alt: ["unicode-math"] }, "𝚜": { math: "\\mathtt{s}", alt: ["unicode-math"] }, "𝚝": { math: "\\mathtt{t}", alt: ["unicode-math"] }, "𝚞": { math: "\\mathtt{u}", alt: ["unicode-math"] }, "𝚟": { math: "\\mathtt{v}", alt: ["unicode-math"] }, "𝚠": { math: "\\mathtt{w}", alt: ["unicode-math"] }, "𝚡": { math: "\\mathtt{x}", alt: ["unicode-math"] }, "𝚢": { math: "\\mathtt{y}", alt: ["unicode-math"] }, "𝚣": { math: "\\mathtt{z}", alt: ["unicode-math"] }, "𝚤": { math: "\\imath", alt: ["unicode-math"] }, "𝚥": { math: "\\jmath", alt: ["unicode-math"] }, "𝚨": { math: "\\mathbf{A}", alt: ["unicode-math"] }, "𝚩": { math: "\\mathbf{B}", alt: ["unicode-math"] }, "𝚪": { math: "\\mathbf{\\Gamma}", alt: ["unicode-math"] }, "𝚫": { math: "\\mathbf{\\Delta}", alt: ["unicode-math"] }, "𝚬": { math: "\\mathbf{E}", alt: ["unicode-math"] }, "𝚭": { math: "\\mathbf{Z}", alt: ["unicode-math"] }, "𝚮": { math: "\\mathbf{H}", alt: ["unicode-math"] }, "𝚯": { math: "\\mathbf{\\Theta}", alt: ["unicode-math"] }, "𝚰": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝚱": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝚲": { math: "\\mathbf{\\Lambda}", alt: ["unicode-math"] }, "𝚳": { math: "M", alt: ["unicode-math"] }, "𝚴": { math: "N", alt: ["unicode-math"] }, "𝚵": { math: "\\mathbf{\\Xi}", alt: ["unicode-math"] }, "𝚶": { math: "O", alt: ["unicode-math"] }, "𝚷": { math: "\\mathbf{\\Pi}", alt: ["unicode-math"] }, "𝚸": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝚹": { math: "\\mathbf{\\vartheta}", alt: ["unicode-math"] }, "𝚺": { math: "\\mathbf{\\Sigma}", alt: ["unicode-math"] }, "𝚻": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝚼": { math: "\\mathbf{\\Upsilon}", alt: ["unicode-math"] }, "𝚽": { math: "\\mathbf{\\Phi}", alt: ["unicode-math"] }, "𝚾": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝚿": { math: "\\mathbf{\\Psi}", alt: ["unicode-math"] }, "𝛀": { math: "\\mathbf{\\Omega}", alt: ["unicode-math"] }, "𝛁": { math: "\\mathbf{\\nabla}", alt: ["unicode-math"] }, "𝛂": { math: "\\mathbf{\\alpha}", alt: ["unicode-math"] }, "𝛃": { math: "\\mathbf{\\beta}", alt: ["unicode-math"] }, "𝛄": { math: "\\mathbf{\\gamma}", alt: ["unicode-math"] }, "𝛅": { math: "\\mathbf{\\delta}", alt: ["unicode-math"] }, "𝛆": { math: "\\mathbf{\\epsilon}", alt: ["unicode-math"] }, "𝛇": { math: "\\mathbf{\\zeta}", alt: ["unicode-math"] }, "𝛈": { math: "\\mathbf{\\eta}", alt: ["unicode-math"] }, "𝛉": { math: "\\mathbf{\\theta}", alt: ["unicode-math"] }, "𝛊": { math: "\\mathbf{I}", alt: ["unicode-math"] }, "𝛋": { math: "\\mathbf{K}", alt: ["unicode-math"] }, "𝛌": { math: "\\mathbf{\\lambda}", alt: ["unicode-math"] }, "𝛍": { math: "m", alt: ["unicode-math"] }, "𝛎": { math: "v", alt: ["unicode-math"] }, "𝛏": { math: "\\mathbf{\\xi}", alt: ["unicode-math"] }, "𝛐": { math: "O", alt: ["unicode-math"] }, "𝛑": { math: "\\mathbf{\\pi}", alt: ["unicode-math"] }, "𝛒": { math: "\\mathbf{P}", alt: ["unicode-math"] }, "𝛓": { math: "\\mathbf{\\varsigma}", alt: ["unicode-math"] }, "𝛔": { math: "\\mathbf{\\sigma}", alt: ["unicode-math"] }, "𝛕": { math: "\\mathbf{T}", alt: ["unicode-math"] }, "𝛖": { math: "\\mathbf{\\upsilon}", alt: ["unicode-math"] }, "𝛗": { math: "\\mathbf{\\phi}", alt: ["unicode-math"] }, "𝛘": { math: "\\mathbf{X}", alt: ["unicode-math"] }, "𝛙": { math: "\\mathbf{\\psi}", alt: ["unicode-math"] }, "𝛚": { math: "\\mathbf{\\omega}", alt: ["unicode-math"] }, "𝛛": { math: "\\partial", alt: ["unicode-math"] }, "𝛜": { math: "\\in", alt: ["unicode-math"] }, "𝛝": { math: "\\mathbf{\\vartheta}", alt: ["unicode-math"] }, "𝛞": { math: "\\mathbf{\\varkappa}", alt: ["unicode-math"] }, "𝛟": { math: "\\mathbf{\\phi}", alt: ["unicode-math"] }, "𝛠": { math: "\\mathbf{\\varrho}", alt: ["unicode-math"] }, "𝛡": { math: "\\mathbf{\\varpi}", alt: ["unicode-math"] }, "𝛢": { math: "A", alt: ["unicode-math"] }, "𝛣": { math: "B", alt: ["unicode-math"] }, "𝛤": { math: "\\Gamma", alt: ["unicode-math"] }, "𝛥": { math: "\\Delta", alt: ["unicode-math"] }, "𝛦": { math: "E", alt: ["unicode-math"] }, "𝛧": { math: "Z", alt: ["unicode-math"] }, "𝛨": { math: "H", alt: ["unicode-math"] }, "𝛩": { math: "\\Theta", alt: ["unicode-math"] }, "𝛪": { math: "I", alt: ["unicode-math"] }, "𝛫": { math: "K", alt: ["unicode-math"] }, "𝛬": { math: "\\Lambda", alt: ["unicode-math"] }, "𝛭": { math: "M", alt: ["unicode-math"] }, "𝛮": { math: "N", alt: ["unicode-math"] }, "𝛯": { math: "\\Xi", alt: ["unicode-math"] }, "𝛰": { math: "O", alt: ["unicode-math"] }, "𝛱": { math: "\\Pi", alt: ["unicode-math"] }, "𝛲": { math: "P", alt: ["unicode-math"] }, "𝛳": { math: "\\Theta", alt: ["unicode-math"] }, "𝛴": { math: "\\Sigma", alt: ["unicode-math"] }, "𝛵": { math: "T", alt: ["unicode-math"] }, "𝛶": { math: "\\Upsilon", alt: ["unicode-math"] }, "𝛷": { math: "\\Phi", alt: ["unicode-math"] }, "𝛸": { math: "X", alt: ["unicode-math"] }, "𝛹": { math: "\\Psi", alt: ["unicode-math"] }, "𝛺": { math: "\\Omega", alt: ["unicode-math"] }, "𝛻": { math: "\\nabla", alt: ["unicode-math"] }, "𝛼": { math: "A", alt: ["unicode-math"] }, "𝛽": { math: "B", alt: ["unicode-math"] }, "𝛾": { math: "\\gamma", alt: ["unicode-math"] }, "𝛿": { math: "\\delta", alt: ["unicode-math"] }, "𝜀": { math: "E", alt: ["unicode-math"] }, "𝜁": { math: "Z", alt: ["unicode-math"] }, "𝜂": { math: "H", alt: ["unicode-math"] }, "𝜃": { math: "\\theta", alt: ["unicode-math"] }, "𝜄": { math: "I", alt: ["unicode-math"] }, "𝜅": { math: "K", alt: ["unicode-math"] }, "𝜆": { math: "\\lambda", alt: ["unicode-math"] }, "𝜇": { math: "\\mu", alt: ["unicode-math"] }, "𝜈": { math: "\\nu", alt: ["unicode-math"] }, "𝜉": { math: "\\xi", alt: ["unicode-math"] }, "𝜊": { math: "o", alt: ["unicode-math"] }, "𝜋": { math: "\\pi", alt: ["unicode-math"] }, "𝜍": { math: "\\varsigma", alt: ["unicode-math"] }, "𝜎": { math: "\\sigma", alt: ["unicode-math"] }, "𝜏": { math: "T", alt: ["unicode-math"] }, "𝜐": { math: "\\upsilon", alt: ["unicode-math"] }, "𝜑": { math: "\\varphi", alt: ["unicode-math"] }, "𝜒": { math: "X", alt: ["unicode-math"] }, "𝜓": { math: "\\psi", alt: ["unicode-math"] }, "𝜔": { math: "\\omega", alt: ["unicode-math"] }, "𝜕": { math: "\\partial", alt: ["unicode-math"] }, "𝜖": { math: "\\in", alt: ["unicode-math"] }, "𝜗": { math: "\\vartheta", alt: ["unicode-math"] }, "𝜘": { math: "\\varkappa", alt: ["unicode-math"] }, "𝜙": { math: "\\phi", alt: ["unicode-math"] }, "𝜚": { math: "\\varrho", alt: ["unicode-math"] }, "𝜛": { math: "\\varpi", alt: ["unicode-math"] }, "𝜜": { math: "\\mathbit{A}", alt: ["unicode-math"] }, "𝜝": { math: "\\mathbit{B}", alt: ["unicode-math"] }, "𝜞": { math: "\\mathbit{\\Gamma}", alt: ["unicode-math"] }, "𝜟": { math: "\\mathbit{\\Delta}", alt: ["unicode-math"] }, "𝜠": { math: "\\mathbit{E}", alt: ["unicode-math"] }, "𝜡": { math: "\\mathbit{Z}", alt: ["unicode-math"] }, "𝜢": { math: "\\mathbit{H}", alt: ["unicode-math"] }, "𝜣": { math: "\\mathbit{\\Theta}", alt: ["unicode-math"] }, "𝜤": { math: "\\mathbit{I}", alt: ["unicode-math"] }, "𝜥": { math: "\\mathbit{K}", alt: ["unicode-math"] }, "𝜦": { math: "\\mathbit{\\Lambda}", alt: ["unicode-math"] }, "𝜧": { math: "M", alt: ["unicode-math"] }, "𝜨": { math: "N", alt: ["unicode-math"] }, "𝜩": { math: "\\mathbit{\\Xi}", alt: ["unicode-math"] }, "𝜪": { math: "O", alt: ["unicode-math"] }, "𝜫": { math: "\\mathbit{\\Pi}", alt: ["unicode-math"] }, "𝜬": { math: "\\mathbit{P}", alt: ["unicode-math"] }, "𝜭": { math: "\\mathbit{O}", alt: ["unicode-math"] }, "𝜮": { math: "\\mathbit{\\Sigma}", alt: ["unicode-math"] }, "𝜯": { math: "\\mathbit{T}", alt: ["unicode-math"] }, "𝜰": { math: "\\mathbit{\\Upsilon}", alt: ["unicode-math"] }, "𝜱": { math: "\\mathbit{\\Phi}", alt: ["unicode-math"] }, "𝜲": { math: "\\mathbit{X}", alt: ["unicode-math"] }, "𝜳": { math: "\\mathbit{\\Psi}", alt: ["unicode-math"] }, "𝜴": { math: "\\mathbit{\\Omega}", alt: ["unicode-math"] }, "𝜵": { math: "\\mathbit{\\nabla}", alt: ["unicode-math"] }, "𝜶": { math: "\\mathbit{\\alpha}", alt: ["unicode-math"] }, "𝜷": { math: "\\mathbit{\\beta}", alt: ["unicode-math"] }, "𝜸": { math: "\\mathbit{\\gamma}", alt: ["unicode-math"] }, "𝜹": { math: "\\mathbit{\\delta}", alt: ["unicode-math"] }, "𝜺": { math: "\\mathbit{\\epsilon}", alt: ["unicode-math"] }, "𝜻": { math: "\\mathbit{\\zeta}", alt: ["unicode-math"] }, "𝜼": { math: "\\mathbit{\\eta}", alt: ["unicode-math"] }, "𝜽": { math: "\\mathbit{\\theta}", alt: ["unicode-math"] }, "𝜾": { math: "\\mathbit{\\imath}", alt: ["unicode-math"] }, "𝜿": { math: "\\mathbit{\\kappa}", alt: ["unicode-math"] }, "𝝀": { math: "\\mathbit{\\lambda}", alt: ["unicode-math"] }, "𝝁": { math: "\\mu", alt: ["unicode-math"] }, "𝝂": { math: "v", alt: ["unicode-math"] }, "𝝃": { math: "\\mathbit{\\xi}", alt: ["unicode-math"] }, "𝝄": { math: "O", alt: ["unicode-math"] }, "𝝅": { math: "\\mathbit{\\pi}", alt: ["unicode-math"] }, "𝝆": { math: "\\mathbit{\\rho}", alt: ["unicode-math"] }, "𝝇": { math: "\\mathbit{\\varsigma}", alt: ["unicode-math"] }, "𝝈": { math: "\\mathbit{\\sigma}", alt: ["unicode-math"] }, "𝝉": { math: "\\mathbit{\\tau}", alt: ["unicode-math"] }, "𝝊": { math: "\\mathbit{\\upsilon}", alt: ["unicode-math"] }, "𝝋": { math: "\\mathbit{\\varphi}", alt: ["unicode-math"] }, "𝝌": { math: "\\mathbit{\\chi}", alt: ["unicode-math"] }, "𝝍": { math: "\\mathbit{\\psi}", alt: ["unicode-math"] }, "𝝎": { math: "\\mathbit{\\omega}", alt: ["unicode-math"] }, "𝝏": { math: "\\partial", alt: ["unicode-math"] }, "𝝐": { math: "\\in", alt: ["unicode-math"] }, "𝝑": { math: "\\mathbit{\\vartheta}", alt: ["unicode-math"] }, "𝝒": { math: "\\mathbit{\\varkappa}", alt: ["unicode-math"] }, "𝝓": { math: "\\mathbit{\\phi}", alt: ["unicode-math"] }, "𝝔": { math: "\\mathbit{\\varrho}", alt: ["unicode-math"] }, "𝝕": { math: "\\mathbit{\\varpi}", alt: ["unicode-math"] }, "𝝖": { math: "\\mathsfbf{A}", alt: ["unicode-math"] }, "𝝗": { math: "\\mathsfbf{B}", alt: ["unicode-math"] }, "𝝘": { math: "\\mathsfbf{\\Gamma}", alt: ["unicode-math"] }, "𝝙": { math: "\\mathsfbf{\\Delta}", alt: ["unicode-math"] }, "𝝚": { math: "\\mathsfbf{E}", alt: ["unicode-math"] }, "𝝛": { math: "\\mathsfbf{Z}", alt: ["unicode-math"] }, "𝝜": { math: "\\mathsfbf{H}", alt: ["unicode-math"] }, "𝝝": { math: "\\mathsfbf{\\Theta}", alt: ["unicode-math"] }, "𝝞": { math: "\\mathsfbf{I}", alt: ["unicode-math"] }, "𝝟": { math: "\\mathsfbf{K}", alt: ["unicode-math"] }, "𝝠": { math: "\\mathsfbf{\\Lambda}", alt: ["unicode-math"] }, "𝝡": { math: "M", alt: ["unicode-math"] }, "𝝢": { math: "N", alt: ["unicode-math"] }, "𝝣": { math: "\\mathsfbf{\\Xi}", alt: ["unicode-math"] }, "𝝤": { math: "O", alt: ["unicode-math"] }, "𝝥": { math: "\\mathsfbf{\\Pi}", alt: ["unicode-math"] }, "𝝦": { math: "\\mathsfbf{P}", alt: ["unicode-math"] }, "𝝧": { math: "\\mathsfbf{\\Theta}", alt: ["unicode-math"] }, "𝝨": { math: "\\mathsfbf{\\Sigma}", alt: ["unicode-math"] }, "𝝩": { math: "\\mathsfbf{T}", alt: ["unicode-math"] }, "𝝪": { math: "\\mathsfbf{\\Upsilon}", alt: ["unicode-math"] }, "𝝫": { math: "\\mathsfbf{\\Phi}", alt: ["unicode-math"] }, "𝝬": { math: "\\mathsfbf{X}", alt: ["unicode-math"] }, "𝝭": { math: "\\mathsfbf{\\Psi}", alt: ["unicode-math"] }, "𝝮": { math: "\\mathsfbf{\\Omega}", alt: ["unicode-math"] }, "𝝯": { math: "\\mathsfbf{\\nabla}", alt: ["unicode-math"] }, "𝝰": { math: "\\mathsfbf{\\alpha}", alt: ["unicode-math"] }, "𝝱": { math: "\\mathsfbf{\\beta}", alt: ["unicode-math"] }, "𝝲": { math: "\\mathsfbf{\\gamma}", alt: ["unicode-math"] }, "𝝳": { math: "\\mathsfbf{\\delta}", alt: ["unicode-math"] }, "𝝴": { math: "\\mathsfbf{\\varepsilon}", alt: ["unicode-math"] }, "𝝵": { math: "\\mathsfbf{\\zeta}", alt: ["unicode-math"] }, "𝝶": { math: "\\mathsfbf{\\eta}", alt: ["unicode-math"] }, "𝝷": { math: "\\mathsfbf{\\theta}", alt: ["unicode-math"] }, "𝝸": { math: "\\mathsfbf{\\imath}", alt: ["unicode-math"] }, "𝝹": { math: "\\mathsfbf{\\kappa}", alt: ["unicode-math"] }, "𝝺": { math: "\\mathsfbf{\\lambda}", alt: ["unicode-math"] }, "𝝻": { math: "\\mu", alt: ["unicode-math"] }, "𝝼": { math: "\\nu", alt: ["unicode-math"] }, "𝝽": { math: "\\mathsfbf{\\xi}", alt: ["unicode-math"] }, "𝝾": { math: "o", alt: ["unicode-math"] }, "𝝿": { math: "\\mathsfbf{\\pi}", alt: ["unicode-math"] }, "𝞀": { math: "\\mathsfbf{\\rho}", alt: ["unicode-math"] }, "𝞁": { math: "\\mathsfbf{\\varsigma}", alt: ["unicode-math"] }, "𝞂": { math: "\\mathsfbf{\\sigma}", alt: ["unicode-math"] }, "𝞃": { math: "\\mathsfbf{\\tau}", alt: ["unicode-math"] }, "𝞄": { math: "\\mathsfbf{\\upsilon}", alt: ["unicode-math"] }, "𝞅": { math: "\\mathsfbf{\\varphi}", alt: ["unicode-math"] }, "𝞆": { math: "\\mathsfbf{\\chi}", alt: ["unicode-math"] }, "𝞇": { math: "\\mathsfbf{\\psi}", alt: ["unicode-math"] }, "𝞈": { math: "\\mathsfbf{\\omega}", alt: ["unicode-math"] }, "𝞉": { math: "\\partial", alt: ["unicode-math"] }, "𝞊": { math: "\\in", alt: ["unicode-math"] }, "𝞋": { math: "\\mathsfbf{\\vartheta}", alt: ["unicode-math"] }, "𝞌": { math: "\\mathsfbf{\\varkappa}", alt: ["unicode-math"] }, "𝞍": { math: "\\mathsfbf{\\phi}", alt: ["unicode-math"] }, "𝞎": { math: "\\mathsfbf{\\varrho}", alt: ["unicode-math"] }, "𝞏": { math: "\\mathsfbf{\\varpi}", alt: ["unicode-math"] }, "𝞐": { math: "\\mathsfbfsl{A}", alt: ["unicode-math"] }, "𝞑": { math: "\\mathsfbfsl{B}", alt: ["unicode-math"] }, "𝞒": { math: "\\mathsfbfsl{\\Gamma}", alt: ["unicode-math"] }, "𝞓": { math: "\\mathsfbfsl{\\Delta}", alt: ["unicode-math"] }, "𝞔": { math: "\\mathsfbfsl{E}", alt: ["unicode-math"] }, "𝞕": { math: "\\mathsfbfsl{Z}", alt: ["unicode-math"] }, "𝞖": { math: "\\mathsfbfsl{H}", alt: ["unicode-math"] }, "𝞗": { math: "\\mathsfbfsl{\\Theta}", alt: ["unicode-math"] }, "𝞘": { math: "\\mathsfbfsl{I}", alt: ["unicode-math"] }, "𝞙": { math: "\\mathsfbfsl{K}", alt: ["unicode-math"] }, "𝞚": { math: "\\mathsfbfsl{\\Lambda}", alt: ["unicode-math"] }, "𝞛": { math: "\\mathsfbfsl{M}", alt: ["unicode-math"] }, "𝞜": { math: "\\mathsfbfsl{N}", alt: ["unicode-math"] }, "𝞝": { math: "\\mathsfbfsl{\\Xi}", alt: ["unicode-math"] }, "𝞞": { math: "\\mathsfbfsl{O}", alt: ["unicode-math"] }, "𝞟": { math: "\\mathsfbfsl{\\Pi}", alt: ["unicode-math"] }, "𝞠": { math: "\\mathsfbfsl{P}", alt: ["unicode-math"] }, "𝞡": { math: "\\mathsfbfsl{\\Theta}", alt: ["unicode-math"] }, "𝞢": { math: "\\mathsfbfsl{\\Sigma}", alt: ["unicode-math"] }, "𝞣": { math: "\\mathsfbfsl{T}", alt: ["unicode-math"] }, "𝞤": { math: "\\mathsfbfsl{\\Upsilon}", alt: ["unicode-math"] }, "𝞥": { math: "\\mathsfbfsl{\\Phi}", alt: ["unicode-math"] }, "𝞦": { math: "\\mathsfbfsl{X}", alt: ["unicode-math"] }, "𝞧": { math: "\\mathsfbfsl{\\Psi}", alt: ["unicode-math"] }, "𝞨": { math: "\\mathsfbfsl{\\Omega}", alt: ["unicode-math"] }, "𝞩": { math: "\\mathsfbfsl{\\nabla}", alt: ["unicode-math"] }, "𝞪": { math: "\\mathsfbfsl{\\alpha}", alt: ["unicode-math"] }, "𝞫": { math: "\\mathsfbfsl{\\beta}", alt: ["unicode-math"] }, "𝞬": { math: "\\mathsfbfsl{\\gamma}", alt: ["unicode-math"] }, "𝞭": { math: "\\mathsfbfsl{\\delta}", alt: ["unicode-math"] }, "𝞮": { math: "\\mathsfbfsl{\\varepsilon}", alt: ["unicode-math"] }, "𝞯": { math: "\\mathsfbfsl{\\zeta}", alt: ["unicode-math"] }, "𝞰": { math: "\\mathsfbfsl{\\eta}", alt: ["unicode-math"] }, "𝞱": { math: "\\mathsfbfsl{\\theta}", alt: ["unicode-math"] }, "𝞲": { math: "\\mathsfbfsl{\\imath}", alt: ["unicode-math"] }, "𝞳": { math: "\\mathsfbfsl{\\kappa}", alt: ["unicode-math"] }, "𝞴": { math: "\\mathsfbfsl{\\lambda}", alt: ["unicode-math"] }, "𝞵": { math: "\\mu", alt: ["unicode-math"] }, "𝞶": { math: "\\nu", alt: ["unicode-math"] }, "𝞷": { math: "\\mathsfbfsl{\\xi}", alt: ["unicode-math"] }, "𝞸": { math: "o", alt: ["unicode-math"] }, "𝞹": { math: "\\mathsfbfsl{\\pi}", alt: ["unicode-math"] }, "𝞺": { math: "\\mathsfbfsl{\\rho}", alt: ["unicode-math"] }, "𝞻": { math: "\\mathsfbfsl{\\varsigma}", alt: ["unicode-math"] }, "𝞼": { math: "\\mathsfbfsl{\\sigma}", alt: ["unicode-math"] }, "𝞽": { math: "\\mathsfbfsl{\\tau}", alt: ["unicode-math"] }, "𝞾": { math: "\\mathsfbfsl{\\upsilon}", alt: ["unicode-math"] }, "𝞿": { math: "\\mathsfbfsl{\\varphi}", alt: ["unicode-math"] }, "𝟀": { math: "\\mathsfbfsl{\\chi}", alt: ["unicode-math"] }, "𝟁": { math: "\\mathsfbfsl{\\psi}", alt: ["unicode-math"] }, "𝟂": { math: "\\mathsfbfsl{\\omega}", alt: ["unicode-math"] }, "𝟃": { math: "\\partial", alt: ["unicode-math"] }, "𝟄": { math: "\\in", alt: ["unicode-math"] }, "𝟅": { math: "\\mathsfbfsl{\\vartheta}", alt: ["unicode-math"] }, "𝟆": { math: "\\mathsfbfsl{\\varkappa}", alt: ["unicode-math"] }, "𝟇": { math: "\\mathsfbfsl{\\phi}", alt: ["unicode-math"] }, "𝟈": { math: "\\mathsfbfsl{\\varrho}", alt: ["unicode-math"] }, "𝟉": { math: "\\mathsfbfsl{\\varpi}", alt: ["unicode-math"] }, "𝟊": { math: "\\mbfDigamma", alt: ["unicode-math"] }, "𝟋": { math: "\\mbfdigamma", alt: ["unicode-math"] }, "𝟎": { math: "\\mathbf{0}", alt: ["unicode-math"] }, "𝟏": { math: "\\mathbf{1}", alt: ["unicode-math"] }, "𝟐": { math: "\\mathbf{2}", alt: ["unicode-math"] }, "𝟑": { math: "\\mathbf{3}", alt: ["unicode-math"] }, "𝟒": { math: "\\mathbf{4}", alt: ["unicode-math"] }, "𝟓": { math: "\\mathbf{5}", alt: ["unicode-math"] }, "𝟔": { math: "\\mathbf{6}", alt: ["unicode-math"] }, "𝟕": { math: "\\mathbf{7}", alt: ["unicode-math"] }, "𝟖": { math: "\\mathbf{8}", alt: ["unicode-math"] }, "𝟗": { math: "\\mathbf{9}", alt: ["unicode-math"] }, "𝟘": { math: "\\mathbb{0}", alt: ["unicode-math"] }, "𝟙": { math: "\\mathbb{1}", alt: ["unicode-math"] }, "𝟚": { math: "\\mathbb{2}", alt: ["unicode-math"] }, "𝟛": { math: "\\mathbb{3}", alt: ["unicode-math"] }, "𝟜": { math: "\\mathbb{4}", alt: ["unicode-math"] }, "𝟝": { math: "\\mathbb{5}", alt: ["unicode-math"] }, "𝟞": { math: "\\mathbb{6}", alt: ["unicode-math"] }, "𝟟": { math: "\\mathbb{7}", alt: ["unicode-math"] }, "𝟠": { math: "\\mathbb{8}", alt: ["unicode-math"] }, "𝟡": { math: "\\mathbb{9}", alt: ["unicode-math"] }, "𝟢": { math: "\\mathsf{0}", alt: ["unicode-math"] }, "𝟣": { math: "\\mathsf{1}", alt: ["unicode-math"] }, "𝟤": { math: "\\mathsf{2}", alt: ["unicode-math"] }, "𝟥": { math: "\\mathsf{3}", alt: ["unicode-math"] }, "𝟦": { math: "\\mathsf{4}", alt: ["unicode-math"] }, "𝟧": { math: "\\mathsf{5}", alt: ["unicode-math"] }, "𝟨": { math: "\\mathsf{6}", alt: ["unicode-math"] }, "𝟩": { math: "\\mathsf{7}", alt: ["unicode-math"] }, "𝟪": { math: "\\mathsf{8}", alt: ["unicode-math"] }, "𝟫": { math: "\\mathsf{9}", alt: ["unicode-math"] }, "𝟬": { math: "\\mathsfbf{0}", alt: ["unicode-math"] }, "𝟭": { math: "\\mathsfbf{1}", alt: ["unicode-math"] }, "𝟮": { math: "\\mathsfbf{2}", alt: ["unicode-math"] }, "𝟯": { math: "\\mathsfbf{3}", alt: ["unicode-math"] }, "𝟰": { math: "\\mathsfbf{4}", alt: ["unicode-math"] }, "𝟱": { math: "\\mathsfbf{5}", alt: ["unicode-math"] }, "𝟲": { math: "\\mathsfbf{6}", alt: ["unicode-math"] }, "𝟳": { math: "\\mathsfbf{7}", alt: ["unicode-math"] }, "𝟴": { math: "\\mathsfbf{8}", alt: ["unicode-math"] }, "𝟵": { math: "\\mathsfbf{9}", alt: ["unicode-math"] }, "𝟶": { math: "\\mathtt{0}", alt: ["unicode-math"] }, "𝟷": { math: "\\mathtt{1}", alt: ["unicode-math"] }, "𝟸": { math: "\\mathtt{2}", alt: ["unicode-math"] }, "𝟹": { math: "\\mathtt{3}", alt: ["unicode-math"] }, "𝟺": { math: "\\mathtt{4}", alt: ["unicode-math"] }, "𝟻": { math: "\\mathtt{5}", alt: ["unicode-math"] }, "𝟼": { math: "\\mathtt{6}", alt: ["unicode-math"] }, "𝟽": { math: "\\mathtt{7}", alt: ["unicode-math"] }, "𝟾": { math: "\\mathtt{8}", alt: ["unicode-math"] }, "𝟿": { math: "\\mathtt{9}", alt: ["unicode-math"] }, " ͚": { math: "_\\infty" }, "\u2029": { text: "{\\par}" }, "/​": { text: "{\\slash}" }, "^": { text: "{\\textasciicircum}" }, i︠a︡: { text: "\\t{ia}" }, "{": { text: "\\{" }, "}": { text: "\\}" }, "~": { text: "{\\textasciitilde}" }, "¡": { text: "{\\textexclamdown}" }, "€": { text: "{\\texteuro}", alt: ["unicode-math"] }, "¨": { text: "{\\textasciidieresis}" }, "«": { text: "<<" }, "®": { text: "{\\textregistered}" }, "¯": { text: "{\\textasciimacron}" }, "´": { text: "{\\textasciiacute}" }, µ: { text: "{\\textmu}" }, "¸": { text: "{\\c}" }, "»": { text: ">>" }, "¿": { text: "{\\textquestiondown}" }, Æ: { text: "{\\AE}" }, Ð: { text: "{\\DH}" }, Ø: { text: "{\\O}" }, Þ: { text: "{\\TH}" }, ß: { text: "{\\ss}" }, å: { text: "{\\aa}" }, æ: { text: "{\\ae}" }, ð: { text: "{\\dh}", alt: ["amssymb", "arevmath", "textcomp"] }, ø: { text: "{\\o}" }, þ: { text: "{\\th}" }, Đ: { text: "{\\DJ}" }, đ: { text: "{\\dj}" }, ĭ: { text: "{\\u \\i}" }, Ĳ: { text: "{\\IJ}" }, ĳ: { text: "{\\ij}" }, ĵ: { text: "{\\^\\j}" }, ĸ: { text: "K", alt: ["xecjk"] }, Ł: { text: "{\\L}" }, ł: { text: "{\\l}" }, ŉ: { text: "'n" }, Ŋ: { text: "{\\NG}" }, ŋ: { text: "{\\ng}" }, Œ: { text: "{\\OE}" }, œ: { text: "{\\oe}" }, ſ: { text: "s" }, ƪ: { text: "{\\textesh}" }, ǂ: { text: "{\\textdoublepipe}", alt: ["tipa"] }, ɡ: { text: "g" }, "ʹ": { text: "'" }, ʻ: { text: "'" }, ʼ: { text: "'" }, ʽ: { text: "'" }, "ˆ": { text: "{\\textasciicircum}" }, "ˇ": { text: "{\\textasciicaron}" }, "ˉ": { text: "-" }, "˘": { text: "{\\textasciibreve}" }, "˚": { text: "{\\r{}}" }, "˛": { text: "{\\k{}}" }, "˜": { text: "{\\texttildelow}" }, "˝": { text: "{\\textacutedbl}" }, "̀": { text: "{\\`}", alt: ["unicode-math"] }, "́": { text: "{\\'}", alt: ["unicode-math"] }, "̂": { text: "{\\^}" }, "̃": { text: "{\\~}", alt: ["unicode-math"] }, "̄": { text: "{\\=}" }, "̆": { text: "{\\u}", alt: ["unicode-math"] }, "̇": { text: "{\\.}", alt: ["unicode-math"] }, "̈": { text: '{\\"}', alt: ["unicode-math"] }, "̋": { text: "{\\H}" }, "̌": { text: "{\\v}", alt: ["unicode-math"] }, "̏": { text: "{\\textdoublegrave}" }, "̖": { text: "{\\textsubgrave}" }, "̣": { text: "{\\d}" }, "̦": { text: "{\\textcommabelow}" }, "̧": { text: "{\\c}" }, "̨": { text: "{\\k}" }, "͵": { text: "," }, ";": { text: ";" }, Ί: { text: "{\\'{}I}" }, Ό: { text: "{\\'{}O}" }, ϐ: { text: "\\Pisymbol{ppi022}{87}", alt: ["MinionPro", "unicode-math"] }, ѫ: { text: "{\\cyrchar\\cyrbyus}" }, ѳ: { text: "{\\cyrchar\\cyrfita}" }, ѵ: { text: "{\\cyrchar\\cyrizh}" }, "Ӆ": { text: "{\\cyrchar\\CYRLDSC}" }, "ӆ": { text: "{\\cyrchar\\cyrldsc}" }, "Ӎ": { text: "{\\cyrchar\\CYRMDSC}" }, "ӎ": { text: "{\\cyrchar\\cyrmdsc}" }, ѣ: { text: "{\\cyrchar\\cyryat}" }, Ё: { text: "{\\cyrchar\\CYRYO}" }, Ђ: { text: "{\\cyrchar\\CYRDJE}" }, Ѓ: { text: "\\cyrchar{\\'\\CYRG}" }, Є: { text: "{\\cyrchar\\CYRIE}" }, Ѕ: { text: "{\\cyrchar\\CYRDZE}" }, І: { text: "{\\cyrchar\\CYRII}" }, Ї: { text: "{\\cyrchar\\CYRYI}" }, Ј: { text: "{\\cyrchar\\CYRJE}" }, Љ: { text: "{\\cyrchar\\CYRLJE}" }, Њ: { text: "{\\cyrchar\\CYRNJE}" }, Ћ: { text: "{\\cyrchar\\CYRTSHE}" }, Ќ: { text: "\\cyrchar{\\'\\CYRK}" }, Ў: { text: "{\\cyrchar\\CYRUSHRT}" }, Џ: { text: "{\\cyrchar\\CYRDZHE}" }, А: { text: "{\\cyrchar\\CYRA}" }, Б: { text: "{\\cyrchar\\CYRB}" }, В: { text: "{\\cyrchar\\CYRV}" }, Г: { text: "{\\cyrchar\\CYRG}" }, Д: { text: "{\\cyrchar\\CYRD}" }, Е: { text: "{\\cyrchar\\CYRE}" }, Ж: { text: "{\\cyrchar\\CYRZH}" }, З: { text: "{\\cyrchar\\CYRZ}" }, И: { text: "{\\cyrchar\\CYRI}" }, Й: { text: "{\\cyrchar\\CYRISHRT}" }, К: { text: "{\\cyrchar\\CYRK}" }, Л: { text: "{\\cyrchar\\CYRL}" }, М: { text: "{\\cyrchar\\CYRM}" }, Н: { text: "{\\cyrchar\\CYRN}" }, О: { text: "{\\cyrchar\\CYRO}" }, П: { text: "{\\cyrchar\\CYRP}" }, Р: { text: "{\\cyrchar\\CYRR}" }, С: { text: "{\\cyrchar\\CYRS}" }, Т: { text: "{\\cyrchar\\CYRT}" }, У: { text: "{\\cyrchar\\CYRU}" }, Ф: { text: "{\\cyrchar\\CYRF}" }, Х: { text: "{\\cyrchar\\CYRH}" }, Ц: { text: "{\\cyrchar\\CYRC}" }, Ч: { text: "{\\cyrchar\\CYRCH}" }, Ш: { text: "{\\cyrchar\\CYRSH}" }, Щ: { text: "{\\cyrchar\\CYRSHCH}" }, Ъ: { text: "{\\cyrchar\\CYRHRDSN}" }, Ы: { text: "{\\cyrchar\\CYRERY}" }, Ь: { text: "{\\cyrchar\\CYRSFTSN}" }, Э: { text: "{\\cyrchar\\CYREREV}" }, Ю: { text: "{\\cyrchar\\CYRYU}" }, Я: { text: "{\\cyrchar\\CYRYA}" }, а: { text: "{\\cyrchar\\cyra}" }, б: { text: "{\\cyrchar\\cyrb}" }, в: { text: "{\\cyrchar\\cyrv}" }, г: { text: "{\\cyrchar\\cyrg}" }, д: { text: "{\\cyrchar\\cyrd}" }, е: { text: "{\\cyrchar\\cyre}" }, ж: { text: "{\\cyrchar\\cyrzh}" }, з: { text: "{\\cyrchar\\cyrz}" }, и: { text: "{\\cyrchar\\cyri}" }, й: { text: "{\\cyrchar\\cyrishrt}" }, к: { text: "{\\cyrchar\\cyrk}" }, л: { text: "{\\cyrchar\\cyrl}" }, м: { text: "{\\cyrchar\\cyrm}" }, н: { text: "{\\cyrchar\\cyrn}" }, о: { text: "{\\cyrchar\\cyro}" }, п: { text: "{\\cyrchar\\cyrp}" }, р: { text: "{\\cyrchar\\cyrr}" }, с: { text: "{\\cyrchar\\cyrs}" }, т: { text: "{\\cyrchar\\cyrt}" }, у: { text: "{\\cyrchar\\cyru}" }, ф: { text: "{\\cyrchar\\cyrf}" }, х: { text: "{\\cyrchar\\cyrh}" }, ц: { text: "{\\cyrchar\\cyrc}" }, ч: { text: "{\\cyrchar\\cyrch}" }, ш: { text: "{\\cyrchar\\cyrsh}" }, щ: { text: "{\\cyrchar\\cyrshch}" }, ъ: { text: "{\\cyrchar\\cyrhrdsn}" }, ы: { text: "{\\cyrchar\\cyrery}" }, ь: { text: "{\\cyrchar\\cyrsftsn}" }, э: { text: "{\\cyrchar\\cyrerev}" }, ю: { text: "{\\cyrchar\\cyryu}" }, я: { text: "{\\cyrchar\\cyrya}" }, ё: { text: "{\\cyrchar\\cyryo}" }, ђ: { text: "{\\cyrchar\\cyrdje}" }, ѓ: { text: "\\cyrchar{\\'\\cyrg}" }, є: { text: "{\\cyrchar\\cyrie}" }, ѕ: { text: "{\\cyrchar\\cyrdze}" }, і: { text: "{\\cyrchar\\cyrii}" }, ї: { text: "{\\cyrchar\\cyryi}" }, ј: { text: "{\\cyrchar\\cyrje}" }, љ: { text: "{\\cyrchar\\cyrlje}" }, њ: { text: "{\\cyrchar\\cyrnje}" }, ћ: { text: "{\\cyrchar\\cyrtshe}" }, ќ: { text: "\\cyrchar{\\'\\cyrk}" }, ў: { text: "{\\cyrchar\\cyrushrt}" }, џ: { text: "{\\cyrchar\\cyrdzhe}" }, Ѡ: { text: "{\\cyrchar\\CYROMEGA}" }, ѡ: { text: "{\\cyrchar\\cyromega}" }, Ѣ: { text: "{\\cyrchar\\CYRYAT}" }, Ѥ: { text: "{\\cyrchar\\CYRIOTE}" }, ѥ: { text: "{\\cyrchar\\cyriote}" }, Ѧ: { text: "{\\cyrchar\\CYRLYUS}" }, ѧ: { text: "{\\cyrchar\\cyrlyus}" }, Ѩ: { text: "{\\cyrchar\\CYRIOTLYUS}" }, ѩ: { text: "{\\cyrchar\\cyriotlyus}" }, Ѫ: { text: "{\\cyrchar\\CYRBYUS}" }, Ѭ: { text: "{\\cyrchar\\CYRIOTBYUS}" }, ѭ: { text: "{\\cyrchar\\cyriotbyus}" }, Ѯ: { text: "{\\cyrchar\\CYRKSI}" }, ѯ: { text: "{\\cyrchar\\cyrksi}" }, Ѱ: { text: "{\\cyrchar\\CYRPSI}" }, ѱ: { text: "{\\cyrchar\\cyrpsi}" }, Ѳ: { text: "{\\cyrchar\\CYRFITA}" }, Ѵ: { text: "{\\cyrchar\\CYRIZH}" }, Ѹ: { text: "{\\cyrchar\\CYRUK}" }, ѹ: { text: "{\\cyrchar\\cyruk}" }, Ѻ: { text: "{\\cyrchar\\CYROMEGARND}" }, ѻ: { text: "{\\cyrchar\\cyromegarnd}" }, Ѽ: { text: "{\\cyrchar\\CYROMEGATITLO}" }, ѽ: { text: "{\\cyrchar\\cyromegatitlo}" }, Ѿ: { text: "{\\cyrchar\\CYROT}" }, ѿ: { text: "{\\cyrchar\\cyrot}" }, Ҁ: { text: "{\\cyrchar\\CYRKOPPA}" }, ҁ: { text: "{\\cyrchar\\cyrkoppa}" }, "҂": { text: "{\\cyrchar\\cyrthousands}" }, "҈": { text: "{\\cyrchar\\cyrhundredthousands}" }, "҉": { text: "{\\cyrchar\\cyrmillions}" }, Ҍ: { text: "{\\cyrchar\\CYRSEMISFTSN}" }, ҍ: { text: "{\\cyrchar\\cyrsemisftsn}" }, Ҏ: { text: "{\\cyrchar\\CYRRTICK}" }, ҏ: { text: "{\\cyrchar\\cyrrtick}" }, Ґ: { text: "{\\cyrchar\\CYRGUP}" }, ґ: { text: "{\\cyrchar\\cyrgup}" }, Ғ: { text: "{\\cyrchar\\CYRGHCRS}" }, ғ: { text: "{\\cyrchar\\cyrghcrs}" }, Ҕ: { text: "{\\cyrchar\\CYRGHK}" }, ҕ: { text: "{\\cyrchar\\cyrghk}" }, Җ: { text: "{\\cyrchar\\CYRZHDSC}" }, җ: { text: "{\\cyrchar\\cyrzhdsc}" }, Ҙ: { text: "{\\cyrchar\\CYRZDSC}" }, ҙ: { text: "{\\cyrchar\\cyrzdsc}" }, Қ: { text: "{\\cyrchar\\CYRKDSC}" }, қ: { text: "{\\cyrchar\\cyrkdsc}" }, Ҝ: { text: "{\\cyrchar\\CYRKVCRS}" }, ҝ: { text: "{\\cyrchar\\cyrkvcrs}" }, Ҟ: { text: "{\\cyrchar\\CYRKHCRS}" }, ҟ: { text: "{\\cyrchar\\cyrkhcrs}" }, Ҡ: { text: "{\\cyrchar\\CYRKBEAK}" }, ҡ: { text: "{\\cyrchar\\cyrkbeak}" }, Ң: { text: "{\\cyrchar\\CYRNDSC}" }, ң: { text: "{\\cyrchar\\cyrndsc}" }, Ҥ: { text: "{\\cyrchar\\CYRNG}" }, ҥ: { text: "{\\cyrchar\\cyrng}" }, Ҧ: { text: "{\\cyrchar\\CYRPHK}" }, ҧ: { text: "{\\cyrchar\\cyrphk}" }, Ҩ: { text: "{\\cyrchar\\CYRABHHA}" }, ҩ: { text: "{\\cyrchar\\cyrabhha}" }, Ҫ: { text: "{\\cyrchar\\CYRSDSC}" }, ҫ: { text: "{\\cyrchar\\cyrsdsc}" }, Ҭ: { text: "{\\cyrchar\\CYRTDSC}" }, ҭ: { text: "{\\cyrchar\\cyrtdsc}" }, Ү: { text: "{\\cyrchar\\CYRY}" }, ү: { text: "{\\cyrchar\\cyry}" }, Ұ: { text: "{\\cyrchar\\CYRYHCRS}" }, ұ: { text: "{\\cyrchar\\cyryhcrs}" }, Ҳ: { text: "{\\cyrchar\\CYRHDSC}" }, ҳ: { text: "{\\cyrchar\\cyrhdsc}" }, Ҵ: { text: "{\\cyrchar\\CYRTETSE}" }, ҵ: { text: "{\\cyrchar\\cyrtetse}" }, Ҷ: { text: "{\\cyrchar\\CYRCHRDSC}" }, ҷ: { text: "{\\cyrchar\\cyrchrdsc}" }, Ҹ: { text: "{\\cyrchar\\CYRCHVCRS}" }, ҹ: { text: "{\\cyrchar\\cyrchvcrs}" }, Һ: { text: "{\\cyrchar\\CYRSHHA}" }, һ: { text: "{\\cyrchar\\cyrshha}" }, Ҽ: { text: "{\\cyrchar\\CYRABHCH}" }, ҽ: { text: "{\\cyrchar\\cyrabhch}" }, Ҿ: { text: "{\\cyrchar\\CYRABHCHDSC}" }, ҿ: { text: "{\\cyrchar\\cyrabhchdsc}" }, Ӏ: { text: "{\\cyrchar\\CYRpalochka}" }, Ӄ: { text: "{\\cyrchar\\CYRKHK}" }, ӄ: { text: "{\\cyrchar\\cyrkhk}" }, Ӈ: { text: "{\\cyrchar\\CYRNHK}" }, ӈ: { text: "{\\cyrchar\\cyrnhk}" }, Ӌ: { text: "{\\cyrchar\\CYRCHLDSC}" }, ӌ: { text: "{\\cyrchar\\cyrchldsc}" }, Ӕ: { text: "{\\cyrchar\\CYRAE}" }, ӕ: { text: "{\\cyrchar\\cyrae}" }, Ә: { text: "{\\cyrchar\\CYRSCHWA}" }, ә: { text: "{\\cyrchar\\cyrschwa}" }, Ӡ: { text: "{\\cyrchar\\CYRABHDZE}" }, ӡ: { text: "{\\cyrchar\\cyrabhdze}" }, Ө: { text: "{\\cyrchar\\CYROTLD}" }, ө: { text: "{\\cyrchar\\cyrotld}" }, Ḝ: { text: "\\c{\\u{E}}" }, ḝ: { text: "\\c{\\u{e}}" }, " ": { text: "{\\enspace}" }, "  ": { text: "{\\qquad}" }, " ": { text: "\\;" }, " ": { text: "\\>" }, " ": { text: "\\hspace{0.166em}" }, " ": { text: "\\hphantom{0}" }, " ": { text: "\\hphantom{,}" }, " ": { text: "\\," }, "​": { text: "\\hspace{0pt}" }, "‌": { text: "{\\null}" }, "‐": { text: "-", alt: ["unicode-math"] }, "‑": { text: "-" }, "‒": { text: "-" }, "–": { text: "--" }, "—": { text: "---" }, "―": { text: "{\\texthorizontalbar}", alt: ["unicode-math"] }, "‖": { text: "{\\textbardbl}" }, "‘": { text: "`" }, "’": { text: "'" }, "‚": { text: "{\\quotesinglbase}" }, "“": { text: "``" }, "”": { text: "''" }, "„": { text: ",," }, "‟": { text: "{\\quotedblbase}" }, "‣": { text: ">" }, "․": { text: "." }, "‥": { text: "..", alt: ["unicode-math"] }, "‧": { text: "-" }, " ": { text: "\\," }, "‹": { text: "{\\guilsinglleft}" }, "›": { text: "{\\guilsinglright}" }, "‾": { text: "-" }, "⁄": { text: "{\\textfractionsolidus}", alt: ["unicode-math"] }, "⁈": { text: "?!" }, "⁉": { text: "!?" }, "⁊": { text: "7" }, "⁠": { text: "{\\nolinebreak}" }, "℀": { text: "a/c" }, "℁": { text: "a/s" }, "℃": { text: "{\\textcelsius}" }, "℅": { text: "c/o" }, "℆": { text: "c/u" }, "℉": { text: "F" }, "№": { text: "{\\textnumero}" }, "℗": { text: "{\\textcircledP}" }, "℠": { text: "{\\textservicemark}" }, "℡": { text: "TEL" }, "℧": { text: "{\\textmho}", alt: ["unicode-math"] }, "℩": { text: "{\\textriota}", alt: ["unicode-math"] }, "℮": { text: "{\\textestimated}" }, "Ⅰ": { text: "I" }, "Ⅱ": { text: "II" }, "Ⅲ": { text: "III" }, "Ⅳ": { text: "IV" }, "Ⅴ": { text: "V" }, "Ⅵ": { text: "VI" }, "Ⅶ": { text: "VII" }, "Ⅷ": { text: "VIII" }, "Ⅸ": { text: "IX" }, "Ⅹ": { text: "X" }, "Ⅺ": { text: "XI" }, "Ⅻ": { text: "XII" }, "Ⅼ": { text: "L" }, "Ⅽ": { text: "C" }, "Ⅾ": { text: "D" }, "Ⅿ": { text: "M" }, "ⅰ": { text: "i" }, "ⅱ": { text: "ii" }, "ⅲ": { text: "iii" }, "ⅳ": { text: "iv" }, "ⅴ": { text: "v" }, "ⅵ": { text: "vi" }, "ⅶ": { text: "vii" }, "ⅷ": { text: "viii" }, "ⅸ": { text: "ix" }, "ⅹ": { text: "x" }, "ⅺ": { text: "xi" }, "ⅻ": { text: "xii" }, "ⅼ": { text: "l" }, "ⅽ": { text: "c" }, "ⅾ": { text: "d" }, "ⅿ": { text: "m" }, "∕": { text: "/", alt: ["unicode-math"] }, "√": { text: "{\\textsurd}", alt: ["unicode-math"] }, "␢": { text: "{\\textblank}", alt: ["unicode-math"] }, "①": { text: "\\ding{172}" }, "②": { text: "\\ding{173}" }, "③": { text: "\\ding{174}" }, "④": { text: "\\ding{175}" }, "⑤": { text: "\\ding{176}" }, "⑥": { text: "\\ding{177}" }, "⑦": { text: "\\ding{178}" }, "⑧": { text: "\\ding{179}" }, "⑨": { text: "\\ding{180}" }, "⑩": { text: "\\ding{181}" }, "⑪": { text: "(11)" }, "⑫": { text: "(12)" }, "⑬": { text: "(13)" }, "⑭": { text: "(14)" }, "⑮": { text: "(15)" }, "⑯": { text: "(16)" }, "⑰": { text: "(17)" }, "⑱": { text: "(18)" }, "⑲": { text: "(19)" }, "⑳": { text: "(20)" }, "⑴": { text: "(1)" }, "⑵": { text: "(2)" }, "⑶": { text: "(3)" }, "⑷": { text: "(4)" }, "⑸": { text: "(5)" }, "⑹": { text: "(6)" }, "⑺": { text: "(7)" }, "⑻": { text: "(8)" }, "⑼": { text: "(9)" }, "⑽": { text: "(10)" }, "⑾": { text: "(11)" }, "⑿": { text: "(12)" }, "⒀": { text: "(13)" }, "⒁": { text: "(14)" }, "⒂": { text: "(15)" }, "⒃": { text: "(16)" }, "⒄": { text: "(17)" }, "⒅": { text: "(18)" }, "⒆": { text: "(19)" }, "⒇": { text: "(20)" }, "⒈": { text: "1." }, "⒉": { text: "2." }, "⒊": { text: "3." }, "⒋": { text: "4." }, "⒌": { text: "5." }, "⒍": { text: "6." }, "⒎": { text: "7." }, "⒏": { text: "8." }, "⒐": { text: "9." }, "⒑": { text: "10." }, "⒒": { text: "11." }, "⒓": { text: "12." }, "⒔": { text: "13." }, "⒕": { text: "14." }, "⒖": { text: "15." }, "⒗": { text: "16." }, "⒘": { text: "17." }, "⒙": { text: "18." }, "⒚": { text: "19." }, "⒛": { text: "20." }, "⒜": { text: "(a)" }, "⒝": { text: "(b)" }, "⒞": { text: "(c)" }, "⒟": { text: "(d)" }, "⒠": { text: "(e)" }, "⒡": { text: "(f)" }, "⒢": { text: "(g)" }, "⒣": { text: "(h)" }, "⒤": { text: "(i)" }, "⒥": { text: "(j)" }, "⒦": { text: "(k)" }, "⒧": { text: "(l)" }, "⒨": { text: "(m)" }, "⒩": { text: "(n)" }, "⒪": { text: "(o)" }, "⒫": { text: "(p)" }, "⒬": { text: "(q)" }, "⒭": { text: "(r)" }, "⒮": { text: "(s)" }, "⒯": { text: "(t)" }, "⒰": { text: "(u)" }, "⒱": { text: "(v)" }, "⒲": { text: "(w)" }, "⒳": { text: "(x)" }, "⒴": { text: "(y)" }, "⒵": { text: "(z)" }, "─": { text: "-", alt: ["pmboxdraw"] }, "┄": { text: "-" }, "┈": { text: "-" }, "╌": { text: "-" }, "╲": { text: "\\" }, "╳": { text: "X" }, "╼": { text: "-", alt: ["pmboxdraw"] }, "╾": { text: "-", alt: ["pmboxdraw"] }, "■": { text: "\\ding{110}", alt: ["unicode-math"] }, "▲": { text: "\\ding{115}", alt: ["unicode-math"] }, "▼": { text: "\\ding{116}", alt: ["unicode-math"] }, "◗": { text: "\\ding{119}", alt: ["unicode-math"] }, "◦": { text: "{\\textopenbullet}", alt: ["unicode-math"] }, "★": { text: "\\ding{72}", alt: ["unicode-math"] }, "☆": { text: "\\ding{73}", alt: ["unicode-math"] }, "☎": { text: "\\ding{37}" }, "☓": { text: "X" }, "☛": { text: "\\ding{42}" }, "♀": { text: "{\\venus}", alt: ["unicode-math"] }, "♥": { text: "\\ding{170}", alt: ["unicode-math"] }, "♦": { text: "\\ding{169}", alt: ["unicode-math"] }, "♪": { text: "{\\textmusicalnote}", alt: ["unicode-math"] }, "✁": { text: "\\ding{33}" }, "✂": { text: "\\ding{34}" }, "✃": { text: "\\ding{35}" }, "✄": { text: "\\ding{36}" }, "✆": { text: "\\ding{38}" }, "✇": { text: "\\ding{39}" }, "✈": { text: "\\ding{40}" }, "✉": { text: "\\ding{41}" }, "✌": { text: "\\ding{44}" }, "✍": { text: "\\ding{45}" }, "✏": { text: "\\ding{47}" }, "✐": { text: "\\ding{48}" }, "✑": { text: "\\ding{49}" }, "✒": { text: "\\ding{50}" }, "✓": { text: "\\ding{51}", alt: ["unicode-math"] }, "✔": { text: "\\ding{52}" }, "✕": { text: "\\ding{53}" }, "✖": { text: "\\ding{54}" }, "✘": { text: "\\ding{56}" }, "✙": { text: "\\ding{57}" }, "✚": { text: "\\ding{58}" }, "✛": { text: "\\ding{59}" }, "✜": { text: "\\ding{60}" }, "✝": { text: "\\ding{61}" }, "✞": { text: "\\ding{62}" }, "✟": { text: "\\ding{63}" }, "✠": { text: "\\ding{64}", alt: ["unicode-math"] }, "✡": { text: "\\ding{65}" }, "✢": { text: "\\ding{66}" }, "✣": { text: "\\ding{67}" }, "✤": { text: "\\ding{68}" }, "✥": { text: "\\ding{69}" }, "✦": { text: "\\ding{70}" }, "✧": { text: "\\ding{71}" }, "✩": { text: "\\ding{73}" }, "✪": { text: "\\ding{74}", alt: ["unicode-math"] }, "✫": { text: "\\ding{75}" }, "✬": { text: "\\ding{76}" }, "✭": { text: "\\ding{77}" }, "✮": { text: "\\ding{78}" }, "✯": { text: "\\ding{79}" }, "✰": { text: "\\ding{80}" }, "✱": { text: "\\ding{81}" }, "✲": { text: "\\ding{82}" }, "✳": { text: "\\ding{83}" }, "✴": { text: "\\ding{84}" }, "✵": { text: "\\ding{85}" }, "✶": { text: "\\ding{86}", alt: ["unicode-math"] }, "✷": { text: "\\ding{87}" }, "✸": { text: "\\ding{88}" }, "✹": { text: "\\ding{89}" }, "✺": { text: "\\ding{90}" }, "✻": { text: "\\ding{91}" }, "✼": { text: "\\ding{92}" }, "✽": { text: "\\ding{93}", alt: ["unicode-math"] }, "✾": { text: "\\ding{94}" }, "✿": { text: "\\ding{95}" }, "❀": { text: "\\ding{96}" }, "❁": { text: "\\ding{97}" }, "❂": { text: "\\ding{98}" }, "❃": { text: "\\ding{99}" }, "❄": { text: "\\ding{100}" }, "❅": { text: "\\ding{101}" }, "❆": { text: "\\ding{102}" }, "❇": { text: "\\ding{103}" }, "❈": { text: "\\ding{104}" }, "❉": { text: "\\ding{105}" }, "❊": { text: "\\ding{106}" }, "❋": { text: "\\ding{107}" }, "❍": { text: "\\ding{109}" }, "❏": { text: "\\ding{111}" }, "❐": { text: "\\ding{112}" }, "❑": { text: "\\ding{113}" }, "❒": { text: "\\ding{114}" }, "❖": { text: "\\ding{118}" }, "❘": { text: "\\ding{120}" }, "❙": { text: "\\ding{121}" }, "❚": { text: "\\ding{122}" }, "❛": { text: "\\ding{123}" }, "❜": { text: "\\ding{124}" }, "❝": { text: "\\ding{125}" }, "❞": { text: "\\ding{126}" }, "❡": { text: "\\ding{161}" }, "❢": { text: "\\ding{162}" }, "❣": { text: "\\ding{163}" }, "❤": { text: "\\ding{164}" }, "❥": { text: "\\ding{165}" }, "❦": { text: "\\ding{166}" }, "❧": { text: "\\ding{167}" }, "❶": { text: "\\ding{182}" }, "❷": { text: "\\ding{183}" }, "❸": { text: "\\ding{184}" }, "❹": { text: "\\ding{185}" }, "❺": { text: "\\ding{186}" }, "❻": { text: "\\ding{187}" }, "❼": { text: "\\ding{188}" }, "❽": { text: "\\ding{189}" }, "❾": { text: "\\ding{190}" }, "❿": { text: "\\ding{191}" }, "➀": { text: "\\ding{192}" }, "➁": { text: "\\ding{193}" }, "➂": { text: "\\ding{194}" }, "➃": { text: "\\ding{195}" }, "➄": { text: "\\ding{196}" }, "➅": { text: "\\ding{197}" }, "➆": { text: "\\ding{198}" }, "➇": { text: "\\ding{199}" }, "➈": { text: "\\ding{200}" }, "➉": { text: "\\ding{201}" }, "➊": { text: "\\ding{202}" }, "➋": { text: "\\ding{203}" }, "➌": { text: "\\ding{204}" }, "➍": { text: "\\ding{205}" }, "➎": { text: "\\ding{206}" }, "➏": { text: "\\ding{207}" }, "➐": { text: "\\ding{208}" }, "➑": { text: "\\ding{209}" }, "➒": { text: "\\ding{210}" }, "➓": { text: "\\ding{211}" }, "➔": { text: "\\ding{212}" }, "➘": { text: "\\ding{216}" }, "➙": { text: "\\ding{217}" }, "➚": { text: "\\ding{218}" }, "➛": { text: "\\ding{219}", alt: ["unicode-math"] }, "➜": { text: "\\ding{220}" }, "➝": { text: "\\ding{221}" }, "➞": { text: "\\ding{222}" }, "➟": { text: "\\ding{223}" }, "➠": { text: "\\ding{224}" }, "➡": { text: "\\ding{225}" }, "➣": { text: "\\ding{227}" }, "➤": { text: "\\ding{228}" }, "➥": { text: "\\ding{229}" }, "➦": { text: "\\ding{230}" }, "➧": { text: "\\ding{231}" }, "➨": { text: "\\ding{232}" }, "➩": { text: "\\ding{233}" }, "➪": { text: "\\ding{234}" }, "➫": { text: "\\ding{235}" }, "➬": { text: "\\ding{236}" }, "➭": { text: "\\ding{237}" }, "➮": { text: "\\ding{238}" }, "➯": { text: "\\ding{239}" }, "➱": { text: "\\ding{241}" }, "➲": { text: "\\ding{242}" }, "➳": { text: "\\ding{243}" }, "➴": { text: "\\ding{244}" }, "➵": { text: "\\ding{245}" }, "➶": { text: "\\ding{246}" }, "➷": { text: "\\ding{247}" }, "➸": { text: "\\ding{248}" }, "➹": { text: "\\ding{249}" }, "➺": { text: "\\ding{250}" }, "➻": { text: "\\ding{251}" }, "➼": { text: "\\ding{252}" }, "➽": { text: "\\ding{253}" }, "➾": { text: "\\ding{254}" }, ﬀ: { text: "ff" }, ﬁ: { text: "fi" }, ﬂ: { text: "fl" }, ﬃ: { text: "ffi" }, ﬄ: { text: "ffl" }, ﬅ: { text: "st" }, ﬆ: { text: "st" }, "�": { text: "{\\dbend}" }, "⁒": { text: "{\\textdiscount}" }, "‽": { text: "{\\textinterrobang}" }, "※": { text: "{\\textreferencemark}" }, Ŧ: { text: "{\\textTstroke}" }, ŧ: { text: "{\\texttstroke}" }, "ˋ": { text: "{\\textasciigrave}" }, Α: { math: "A", alt: ["unicode-math"] }, Β: { math: "B", alt: ["unicode-math"] }, Ε: { math: "E", alt: ["unicode-math"] }, Ζ: { math: "Z", alt: ["unicode-math"] }, Η: { math: "H", alt: ["unicode-math"] }, Ι: { math: "I", alt: ["unicode-math"] }, Κ: { math: "K", alt: ["unicode-math"] }, Μ: { math: "M", alt: ["unicode-math"] }, Ν: { math: "N", alt: ["unicode-math"] }, Ο: { math: "O", alt: ["unicode-math"] }, Ρ: { math: "P", alt: ["unicode-math"] }, Τ: { math: "T", alt: ["unicode-math"] }, Χ: { math: "X", alt: ["unicode-math"] }, ο: { math: "o", alt: ["unicode-math"] }, ℊ: { math: "g", alt: ["mathrsfs"] }, ℐ: { math: "I", alt: ["mathrsfs"] }, ℒ: { math: "L", alt: ["mathrsfs", "unicode-math"] }, ℛ: { math: "R", alt: ["mathrsfs", "unicode-math"] }, ℬ: { math: "B", alt: ["mathrsfs"] }, ℯ: { math: "e", alt: ["mathrsfs"] }, ℰ: { math: "E", alt: ["mathrsfs"] }, ℱ: { math: "F", alt: ["mathrsfs"] }, ℳ: { math: "M", alt: ["mathrsfs"] }, ℴ: { math: "o", alt: ["mathrsfs"] }, "𝒜": { math: "A", alt: ["mathrsfs", "unicode-math"] }, "𝒞": { math: "C", alt: ["mathrsfs", "unicode-math"] }, "𝒟": { math: "D", alt: ["mathrsfs", "unicode-math"] }, "𝒢": { math: "G", alt: ["mathrsfs", "unicode-math"] }, "𝒥": { math: "J", alt: ["mathrsfs", "unicode-math"] }, "𝒦": { math: "K", alt: ["mathrsfs", "unicode-math"] }, "𝒩": { math: "N", alt: ["mathrsfs", "unicode-math"] }, "𝒪": { math: "O", alt: ["mathrsfs", "unicode-math"] }, "𝒫": { math: "P", alt: ["mathrsfs", "unicode-math"] }, "𝒬": { math: "Q", alt: ["mathrsfs", "unicode-math"] }, "𝒮": { math: "S", alt: ["mathrsfs", "unicode-math"] }, "𝒯": { math: "T", alt: ["mathrsfs", "unicode-math"] }, "𝒰": { math: "U", alt: ["mathrsfs", "unicode-math"] }, "𝒱": { math: "V", alt: ["mathrsfs", "unicode-math"] }, "𝒲": { math: "W", alt: ["mathrsfs", "unicode-math"] }, "𝒳": { math: "X", alt: ["mathrsfs", "unicode-math"] }, "𝒴": { math: "Y", alt: ["mathrsfs", "unicode-math"] }, "𝒵": { math: "Z", alt: ["mathrsfs", "unicode-math"] }, "𝒶": { math: "a", alt: ["mathrsfs", "unicode-math"] }, "𝒷": { math: "b", alt: ["mathrsfs", "unicode-math"] }, "𝒸": { math: "c", alt: ["mathrsfs", "unicode-math"] }, "𝒹": { math: "d", alt: ["mathrsfs", "unicode-math"] }, "𝒻": { math: "f", alt: ["mathrsfs", "unicode-math"] }, "𝒽": { math: "h", alt: ["mathrsfs", "unicode-math"] }, "𝒾": { math: "i", alt: ["mathrsfs", "unicode-math"] }, "𝒿": { math: "j", alt: ["mathrsfs", "unicode-math"] }, "𝓀": { math: "k", alt: ["mathrsfs", "unicode-math"] }, "𝓁": { math: "l", alt: ["mathrsfs", "unicode-math"] }, "𝓂": { math: "m", alt: ["mathrsfs", "unicode-math"] }, "𝓃": { math: "n", alt: ["mathrsfs", "unicode-math"] }, "𝓅": { math: "p", alt: ["mathrsfs", "unicode-math"] }, "𝓆": { math: "q", alt: ["mathrsfs", "unicode-math"] }, "𝓇": { math: "r", alt: ["mathrsfs", "unicode-math"] }, "𝓈": { math: "s", alt: ["mathrsfs", "unicode-math"] }, "𝓉": { math: "t", alt: ["mathrsfs", "unicode-math"] }, "𝓊": { math: "u", alt: ["mathrsfs", "unicode-math"] }, "𝓋": { math: "v", alt: ["mathrsfs", "unicode-math"] }, "𝓌": { math: "w", alt: ["mathrsfs", "unicode-math"] }, "𝓍": { math: "x", alt: ["mathrsfs", "unicode-math"] }, "𝓎": { math: "y", alt: ["mathrsfs", "unicode-math"] }, "𝓏": { math: "z", alt: ["mathrsfs", "unicode-math"] }, "Ⓐ": { text: "(A)" }, "Ⓑ": { text: "(B)" }, "Ⓒ": { text: "(C)" }, "Ⓓ": { text: "(D)" }, "Ⓔ": { text: "(E)" }, "Ⓕ": { text: "(F)" }, "Ⓖ": { text: "(G)" }, "Ⓗ": { text: "(H)" }, "Ⓘ": { text: "(I)" }, "Ⓙ": { text: "(J)" }, "Ⓚ": { text: "(K)" }, "Ⓛ": { text: "(L)" }, "Ⓜ": { text: "(M)" }, "Ⓝ": { text: "(N)" }, "Ⓞ": { text: "(O)" }, "Ⓟ": { text: "(P)" }, "Ⓠ": { text: "(Q)" }, "Ⓡ": { text: "(R)" }, "Ⓣ": { text: "(T)" }, "Ⓤ": { text: "(U)" }, "Ⓥ": { text: "(V)" }, "Ⓦ": { text: "(W)" }, "Ⓧ": { text: "(X)" }, "Ⓨ": { text: "(Y)" }, "Ⓩ": { text: "(Z)" }, "ⓐ": { text: "(a)" }, "ⓑ": { text: "(b)" }, "ⓒ": { text: "(c)" }, "ⓓ": { text: "(d)" }, "ⓔ": { text: "(e)" }, "ⓕ": { text: "(f)" }, "ⓖ": { text: "(g)" }, "ⓗ": { text: "(h)" }, "ⓘ": { text: "(i)" }, "ⓙ": { text: "(j)" }, "ⓚ": { text: "(k)" }, "ⓛ": { text: "(l)" }, "ⓜ": { text: "(m)" }, "ⓝ": { text: "(n)" }, "ⓞ": { text: "(o)" }, "ⓟ": { text: "(p)" }, "ⓠ": { text: "(q)" }, "ⓡ": { text: "(r)" }, "ⓢ": { text: "(s)" }, "ⓣ": { text: "(t)" }, "ⓤ": { text: "(u)" }, "ⓥ": { text: "(v)" }, "ⓦ": { text: "(w)" }, "ⓧ": { text: "(x)" }, "ⓨ": { text: "(y)" }, "ⓩ": { text: "(z)" }, "⓪": { text: "(0)" }, "━": { text: "=", alt: ["pmboxdraw"] }, "│": { text: "|", alt: ["pmboxdraw"] }, "┃": { text: "|", alt: ["pmboxdraw"] }, "┅": { text: "=" }, "┇": { text: "|" }, "┉": { text: "=" }, "┊": { text: "|" }, "┋": { text: "|" }, "╍": { text: "=" }, "╎": { text: "|" }, "╏": { text: "|" }, "═": { text: "=", alt: ["pmboxdraw"] }, "║": { text: "|", alt: ["pmboxdraw"] }, "╽": { text: "|", alt: ["pmboxdraw"] }, "╿": { text: "|", alt: ["pmboxdraw"] } }, package: { wasysym: { "♓": { text: "{\\pisces}", math: "\\pisces" }, "☽": { text: "{\\rightmoon}" }, "☾": { text: "{\\leftmoon}" } }, "unicode-math": { "€": { math: "\\euro" }, "̀": { math: "\\grave" }, "́": { math: "\\acute" }, "̃": { math: "\\tilde" }, "̆": { math: "\\breve" }, "̇": { math: "\\dot" }, "̈": { math: "\\ddot" }, "̉": { math: "\\ovhook" }, "̌": { math: "\\check" }, "̐": { math: "\\candra" }, "̒": { math: "\\oturnedcomma" }, "̕": { math: "\\ocommatopright" }, "̚": { math: "\\droang" }, "͍": { math: "\\underleftrightarrow" }, Α: { math: "\\mupAlpha" }, Β: { math: "\\mupBeta" }, Γ: { math: "\\mupGamma" }, Δ: { math: "\\mupDelta" }, Ε: { math: "\\mupEpsilon" }, Ζ: { math: "\\mupZeta" }, Η: { math: "\\mupEta" }, Θ: { math: "\\mupTheta" }, Ι: { math: "\\mupIota" }, Κ: { math: "\\mupKappa" }, Λ: { math: "\\mupLambda" }, Μ: { math: "\\mupMu" }, Ν: { math: "\\mupNu" }, Ο: { math: "\\mupOmicron" }, Ρ: { math: "\\mupRho" }, Τ: { math: "\\mupTau" }, Χ: { math: "\\mupChi" }, ο: { math: "\\mupomicron" }, ϐ: { math: "\\varbeta" }, ϰ: { math: "\\varkappa" }, "϶": { math: "\\upbackepsilon" }, "𝐀": { math: "\\mbfA" }, "𝐁": { math: "\\mbfB" }, "𝐂": { math: "\\mbfC" }, "𝐃": { math: "\\mbfD" }, "𝐄": { math: "\\mbfE" }, "𝐅": { math: "\\mbfF" }, "𝐆": { math: "\\mbfG" }, "𝐇": { math: "\\mbfH" }, "𝐈": { math: "\\mbfI" }, "𝐉": { math: "\\mbfJ" }, "𝐊": { math: "\\mbfK" }, "𝐋": { math: "\\mbfL" }, "𝐌": { math: "\\mbfM" }, "𝐍": { math: "\\mbfN" }, "𝐎": { math: "\\mbfO" }, "𝐏": { math: "\\mbfP" }, "𝐐": { math: "\\mbfQ" }, "𝐑": { math: "\\mbfR" }, "𝐒": { math: "\\mbfS" }, "𝐓": { math: "\\mbfT" }, "𝐔": { math: "\\mbfU" }, "𝐕": { math: "\\mbfV" }, "𝐖": { math: "\\mbfW" }, "𝐗": { math: "\\mbfX" }, "𝐘": { math: "\\mbfY" }, "𝐙": { math: "\\mbfZ" }, "𝐚": { math: "\\mbfa" }, "𝐛": { math: "\\mbfb" }, "𝐜": { math: "\\mbfc" }, "𝐝": { math: "\\mbfd" }, "𝐞": { math: "\\mbfe" }, "𝐟": { math: "\\mbff" }, "𝐠": { math: "\\mbfg" }, "𝐡": { math: "\\mbfh" }, "𝐢": { math: "\\mbfi" }, "𝐣": { math: "\\mbfj" }, "𝐤": { math: "\\mbfk" }, "𝐥": { math: "\\mbfl" }, "𝐦": { math: "\\mbfm" }, "𝐧": { math: "\\mbfn" }, "𝐨": { math: "\\mbfo" }, "𝐩": { math: "\\mbfp" }, "𝐪": { math: "\\mbfq" }, "𝐫": { math: "\\mbfr" }, "𝐬": { math: "\\mbfs" }, "𝐭": { math: "\\mbft" }, "𝐮": { math: "\\mbfu" }, "𝐯": { math: "\\mbfv" }, "𝐰": { math: "\\mbfw" }, "𝐱": { math: "\\mbfx" }, "𝐲": { math: "\\mbfy" }, "𝐳": { math: "\\mbfz" }, "𝐴": { math: "\\mitA" }, "𝐵": { math: "\\mitB" }, "𝐶": { math: "\\mitC" }, "𝐷": { math: "\\mitD" }, "𝐸": { math: "\\mitE" }, "𝐹": { math: "\\mitF" }, "𝐺": { math: "\\mitG" }, "𝐻": { math: "\\mitH" }, "𝐼": { math: "\\mitI" }, "𝐽": { math: "\\mitJ" }, "𝐾": { math: "\\mitK" }, "𝐿": { math: "\\mitL" }, "𝑀": { math: "\\mitM" }, "𝑁": { math: "\\mitN" }, "𝑂": { math: "\\mitO" }, "𝑃": { math: "\\mitP" }, "𝑄": { math: "\\mitQ" }, "𝑅": { math: "\\mitR" }, "𝑆": { math: "\\mitS" }, "𝑇": { math: "\\mitT" }, "𝑈": { math: "\\mitU" }, "𝑉": { math: "\\mitV" }, "𝑊": { math: "\\mitW" }, "𝑋": { math: "\\mitX" }, "𝑌": { math: "\\mitY" }, "𝑍": { math: "\\mitZ" }, "𝑎": { math: "\\mita" }, "𝑏": { math: "\\mitb" }, "𝑐": { math: "\\mitc" }, "𝑑": { math: "\\mitd" }, "𝑒": { math: "\\mite" }, "𝑓": { math: "\\mitf" }, "𝑔": { math: "\\mitg" }, "𝑖": { math: "\\miti" }, "𝑗": { math: "\\mitj" }, "𝑘": { math: "\\mitk" }, "𝑙": { math: "\\mitl" }, "𝑚": { math: "\\mitm" }, "𝑛": { math: "\\mitn" }, "𝑜": { math: "\\mito" }, "𝑝": { math: "\\mitp" }, "𝑞": { math: "\\mitq" }, "𝑟": { math: "\\mitr" }, "𝑠": { math: "\\mits" }, "𝑡": { math: "\\mitt" }, "𝑢": { math: "\\mitu" }, "𝑣": { math: "\\mitv" }, "𝑤": { math: "\\mitw" }, "𝑥": { math: "\\mitx" }, "𝑦": { math: "\\mity" }, "𝑧": { math: "\\mitz" }, "𝑨": { math: "\\mbfitA" }, "𝑩": { math: "\\mbfitB" }, "𝑪": { math: "\\mbfitC" }, "𝑫": { math: "\\mbfitD" }, "𝑬": { math: "\\mbfitE" }, "𝑭": { math: "\\mbfitF" }, "𝑮": { math: "\\mbfitG" }, "𝑯": { math: "\\mbfitH" }, "𝑰": { math: "\\mbfitI" }, "𝑱": { math: "\\mbfitJ" }, "𝑲": { math: "\\mbfitK" }, "𝑳": { math: "\\mbfitL" }, "𝑴": { math: "\\mbfitM" }, "𝑵": { math: "\\mbfitN" }, "𝑶": { math: "\\mbfitO" }, "𝑷": { math: "\\mbfitP" }, "𝑸": { math: "\\mbfitQ" }, "𝑹": { math: "\\mbfitR" }, "𝑺": { math: "\\mbfitS" }, "𝑻": { math: "\\mbfitT" }, "𝑼": { math: "\\mbfitU" }, "𝑽": { math: "\\mbfitV" }, "𝑾": { math: "\\mbfitW" }, "𝑿": { math: "\\mbfitX" }, "𝒀": { math: "\\mbfitY" }, "𝒁": { math: "\\mbfitZ" }, "𝒂": { math: "\\mbfita" }, "𝒃": { math: "\\mbfitb" }, "𝒄": { math: "\\mbfitc" }, "𝒅": { math: "\\mbfitd" }, "𝒆": { math: "\\mbfite" }, "𝒇": { math: "\\mbfitf" }, "𝒈": { math: "\\mbfitg" }, "𝒉": { math: "\\mbfith" }, "𝒊": { math: "\\mbfiti" }, "𝒋": { math: "\\mbfitj" }, "𝒌": { math: "\\mbfitk" }, "𝒍": { math: "\\mbfitl" }, "𝒎": { math: "\\mbfitm" }, "𝒏": { math: "\\mbfitn" }, "𝒐": { math: "\\mbfito" }, "𝒑": { math: "\\mbfitp" }, "𝒒": { math: "\\mbfitq" }, "𝒓": { math: "\\mbfitr" }, "𝒔": { math: "\\mbfits" }, "𝒕": { math: "\\mbfitt" }, "𝒖": { math: "\\mbfitu" }, "𝒗": { math: "\\mbfitv" }, "𝒘": { math: "\\mbfitw" }, "𝒙": { math: "\\mbfitx" }, "𝒚": { math: "\\mbfity" }, "𝒛": { math: "\\mbfitz" }, "𝒜": { math: "\\mscrA" }, "𝒞": { math: "\\mscrC" }, "𝒟": { math: "\\mscrD" }, "𝒢": { math: "\\mscrG" }, "𝒥": { math: "\\mscrJ" }, "𝒦": { math: "\\mscrK" }, "𝒩": { math: "\\mscrN" }, "𝒪": { math: "\\mscrO" }, "𝒫": { math: "\\mscrP" }, "𝒬": { math: "\\mscrQ" }, "𝒮": { math: "\\mscrS" }, "𝒯": { math: "\\mscrT" }, "𝒰": { math: "\\mscrU" }, "𝒱": { math: "\\mscrV" }, "𝒲": { math: "\\mscrW" }, "𝒳": { math: "\\mscrX" }, "𝒴": { math: "\\mscrY" }, "𝒵": { math: "\\mscrZ" }, "𝒶": { math: "\\mscra" }, "𝒷": { math: "\\mscrb" }, "𝒸": { math: "\\mscrc" }, "𝒹": { math: "\\mscrd" }, "𝒻": { math: "\\mscrf" }, "𝒽": { math: "\\mscrh" }, "𝒾": { math: "\\mscri" }, "𝒿": { math: "\\mscrj" }, "𝓀": { math: "\\mscrk" }, "𝓁": { math: "\\mscrl" }, "𝓂": { math: "\\mscrm" }, "𝓃": { math: "\\mscrn" }, "𝓅": { math: "\\mscrp" }, "𝓆": { math: "\\mscrq" }, "𝓇": { math: "\\mscrr" }, "𝓈": { math: "\\mscrs" }, "𝓉": { math: "\\mscrt" }, "𝓊": { math: "\\mscru" }, "𝓋": { math: "\\mscrv" }, "𝓌": { math: "\\mscrw" }, "𝓍": { math: "\\mscrx" }, "𝓎": { math: "\\mscry" }, "𝓏": { math: "\\mscrz" }, "𝓐": { math: "\\mbfscrA" }, "𝓑": { math: "\\mbfscrB" }, "𝓒": { math: "\\mbfscrC" }, "𝓓": { math: "\\mbfscrD" }, "𝓔": { math: "\\mbfscrE" }, "𝓕": { math: "\\mbfscrF" }, "𝓖": { math: "\\mbfscrG" }, "𝓗": { math: "\\mbfscrH" }, "𝓘": { math: "\\mbfscrI" }, "𝓙": { math: "\\mbfscrJ" }, "𝓚": { math: "\\mbfscrK" }, "𝓛": { math: "\\mbfscrL" }, "𝓜": { math: "\\mbfscrM" }, "𝓝": { math: "\\mbfscrN" }, "𝓞": { math: "\\mbfscrO" }, "𝓟": { math: "\\mbfscrP" }, "𝓠": { math: "\\mbfscrQ" }, "𝓡": { math: "\\mbfscrR" }, "𝓢": { math: "\\mbfscrS" }, "𝓣": { math: "\\mbfscrT" }, "𝓤": { math: "\\mbfscrU" }, "𝓥": { math: "\\mbfscrV" }, "𝓦": { math: "\\mbfscrW" }, "𝓧": { math: "\\mbfscrX" }, "𝓨": { math: "\\mbfscrY" }, "𝓩": { math: "\\mbfscrZ" }, "𝓪": { math: "\\mbfscra" }, "𝓫": { math: "\\mbfscrb" }, "𝓬": { math: "\\mbfscrc" }, "𝓭": { math: "\\mbfscrd" }, "𝓮": { math: "\\mbfscre" }, "𝓯": { math: "\\mbfscrf" }, "𝓰": { math: "\\mbfscrg" }, "𝓱": { math: "\\mbfscrh" }, "𝓲": { math: "\\mbfscri" }, "𝓳": { math: "\\mbfscrj" }, "𝓴": { math: "\\mbfscrk" }, "𝓵": { math: "\\mbfscrl" }, "𝓶": { math: "\\mbfscrm" }, "𝓷": { math: "\\mbfscrn" }, "𝓸": { math: "\\mbfscro" }, "𝓹": { math: "\\mbfscrp" }, "𝓺": { math: "\\mbfscrq" }, "𝓻": { math: "\\mbfscrr" }, "𝓼": { math: "\\mbfscrs" }, "𝓽": { math: "\\mbfscrt" }, "𝓾": { math: "\\mbfscru" }, "𝓿": { math: "\\mbfscrv" }, "𝔀": { math: "\\mbfscrw" }, "𝔁": { math: "\\mbfscrx" }, "𝔂": { math: "\\mbfscry" }, "𝔃": { math: "\\mbfscrz" }, "𝔄": { math: "\\mfrakA" }, "𝔅": { math: "\\mfrakB" }, "𝔇": { math: "\\mfrakD" }, "𝔈": { math: "\\mfrakE" }, "𝔉": { math: "\\mfrakF" }, "𝔊": { math: "\\mfrakG" }, "𝔍": { math: "\\mfrakJ" }, "𝔎": { math: "\\mfrakK" }, "𝔏": { math: "\\mfrakL" }, "𝔐": { math: "\\mfrakM" }, "𝔑": { math: "\\mfrakN" }, "𝔒": { math: "\\mfrakO" }, "𝔓": { math: "\\mfrakP" }, "𝔔": { math: "\\mfrakQ" }, "𝔖": { math: "\\mfrakS" }, "𝔗": { math: "\\mfrakT" }, "𝔘": { math: "\\mfrakU" }, "𝔙": { math: "\\mfrakV" }, "𝔚": { math: "\\mfrakW" }, "𝔛": { math: "\\mfrakX" }, "𝔜": { math: "\\mfrakY" }, "𝔞": { math: "\\mfraka" }, "𝔟": { math: "\\mfrakb" }, "𝔠": { math: "\\mfrakc" }, "𝔡": { math: "\\mfrakd" }, "𝔢": { math: "\\mfrake" }, "𝔣": { math: "\\mfrakf" }, "𝔤": { math: "\\mfrakg" }, "𝔥": { math: "\\mfrakh" }, "𝔦": { math: "\\mfraki" }, "𝔧": { math: "\\mfrakj" }, "𝔨": { math: "\\mfrakk" }, "𝔩": { math: "\\mfrakl" }, "𝔪": { math: "\\mfrakm" }, "𝔫": { math: "\\mfrakn" }, "𝔬": { math: "\\mfrako" }, "𝔭": { math: "\\mfrakp" }, "𝔮": { math: "\\mfrakq" }, "𝔯": { math: "\\mfrakr" }, "𝔰": { math: "\\mfraks" }, "𝔱": { math: "\\mfrakt" }, "𝔲": { math: "\\mfraku" }, "𝔳": { math: "\\mfrakv" }, "𝔴": { math: "\\mfrakw" }, "𝔵": { math: "\\mfrakx" }, "𝔶": { math: "\\mfraky" }, "𝔷": { math: "\\mfrakz" }, "𝔸": { math: "\\BbbA" }, "𝔹": { math: "\\BbbB" }, "𝔻": { math: "\\BbbD" }, "𝔼": { math: "\\BbbE" }, "𝔽": { math: "\\BbbF" }, "𝔾": { math: "\\BbbG" }, "𝕀": { math: "\\BbbI" }, "𝕁": { math: "\\BbbJ" }, "𝕂": { math: "\\BbbK" }, "𝕃": { math: "\\BbbL" }, "𝕄": { math: "\\BbbM" }, "𝕆": { math: "\\BbbO" }, "𝕊": { math: "\\BbbS" }, "𝕋": { math: "\\BbbT" }, "𝕌": { math: "\\BbbU" }, "𝕍": { math: "\\BbbV" }, "𝕎": { math: "\\BbbW" }, "𝕏": { math: "\\BbbX" }, "𝕐": { math: "\\BbbY" }, "𝕒": { math: "\\Bbba" }, "𝕓": { math: "\\Bbbb" }, "𝕔": { math: "\\Bbbc" }, "𝕕": { math: "\\Bbbd" }, "𝕖": { math: "\\Bbbe" }, "𝕗": { math: "\\Bbbf" }, "𝕘": { math: "\\Bbbg" }, "𝕙": { math: "\\Bbbh" }, "𝕚": { math: "\\Bbbi" }, "𝕛": { math: "\\Bbbj" }, "𝕜": { math: "\\Bbbk" }, "𝕝": { math: "\\Bbbl" }, "𝕞": { math: "\\Bbbm" }, "𝕟": { math: "\\Bbbn" }, "𝕠": { math: "\\Bbbo" }, "𝕡": { math: "\\Bbbp" }, "𝕢": { math: "\\Bbbq" }, "𝕣": { math: "\\Bbbr" }, "𝕤": { math: "\\Bbbs" }, "𝕥": { math: "\\Bbbt" }, "𝕦": { math: "\\Bbbu" }, "𝕧": { math: "\\Bbbv" }, "𝕨": { math: "\\Bbbw" }, "𝕩": { math: "\\Bbbx" }, "𝕪": { math: "\\Bbby" }, "𝕫": { math: "\\Bbbz" }, "𝕬": { math: "\\mbffrakA" }, "𝕭": { math: "\\mbffrakB" }, "𝕮": { math: "\\mbffrakC" }, "𝕯": { math: "\\mbffrakD" }, "𝕰": { math: "\\mbffrakE" }, "𝕱": { math: "\\mbffrakF" }, "𝕲": { math: "\\mbffrakG" }, "𝕳": { math: "\\mbffrakH" }, "𝕴": { math: "\\mbffrakI" }, "𝕵": { math: "\\mbffrakJ" }, "𝕶": { math: "\\mbffrakK" }, "𝕷": { math: "\\mbffrakL" }, "𝕸": { math: "\\mbffrakM" }, "𝕹": { math: "\\mbffrakN" }, "𝕺": { math: "\\mbffrakO" }, "𝕻": { math: "\\mbffrakP" }, "𝕼": { math: "\\mbffrakQ" }, "𝕽": { math: "\\mbffrakR" }, "𝕾": { math: "\\mbffrakS" }, "𝕿": { math: "\\mbffrakT" }, "𝖀": { math: "\\mbffrakU" }, "𝖁": { math: "\\mbffrakV" }, "𝖂": { math: "\\mbffrakW" }, "𝖃": { math: "\\mbffrakX" }, "𝖄": { math: "\\mbffrakY" }, "𝖅": { math: "\\mbffrakZ" }, "𝖆": { math: "\\mbffraka" }, "𝖇": { math: "\\mbffrakb" }, "𝖈": { math: "\\mbffrakc" }, "𝖉": { math: "\\mbffrakd" }, "𝖊": { math: "\\mbffrake" }, "𝖋": { math: "\\mbffrakf" }, "𝖌": { math: "\\mbffrakg" }, "𝖍": { math: "\\mbffrakh" }, "𝖎": { math: "\\mbffraki" }, "𝖏": { math: "\\mbffrakj" }, "𝖐": { math: "\\mbffrakk" }, "𝖑": { math: "\\mbffrakl" }, "𝖒": { math: "\\mbffrakm" }, "𝖓": { math: "\\mbffrakn" }, "𝖔": { math: "\\mbffrako" }, "𝖕": { math: "\\mbffrakp" }, "𝖖": { math: "\\mbffrakq" }, "𝖗": { math: "\\mbffrakr" }, "𝖘": { math: "\\mbffraks" }, "𝖙": { math: "\\mbffrakt" }, "𝖚": { math: "\\mbffraku" }, "𝖛": { math: "\\mbffrakv" }, "𝖜": { math: "\\mbffrakw" }, "𝖝": { math: "\\mbffrakx" }, "𝖞": { math: "\\mbffraky" }, "𝖟": { math: "\\mbffrakz" }, "𝖠": { math: "\\msansA" }, "𝖡": { math: "\\msansB" }, "𝖢": { math: "\\msansC" }, "𝖣": { math: "\\msansD" }, "𝖤": { math: "\\msansE" }, "𝖥": { math: "\\msansF" }, "𝖦": { math: "\\msansG" }, "𝖧": { math: "\\msansH" }, "𝖨": { math: "\\msansI" }, "𝖩": { math: "\\msansJ" }, "𝖪": { math: "\\msansK" }, "𝖫": { math: "\\msansL" }, "𝖬": { math: "\\msansM" }, "𝖭": { math: "\\msansN" }, "𝖮": { math: "\\msansO" }, "𝖯": { math: "\\msansP" }, "𝖰": { math: "\\msansQ" }, "𝖱": { math: "\\msansR" }, "𝖲": { math: "\\msansS" }, "𝖳": { math: "\\msansT" }, "𝖴": { math: "\\msansU" }, "𝖵": { math: "\\msansV" }, "𝖶": { math: "\\msansW" }, "𝖷": { math: "\\msansX" }, "𝖸": { math: "\\msansY" }, "𝖹": { math: "\\msansZ" }, "𝖺": { math: "\\msansa" }, "𝖻": { math: "\\msansb" }, "𝖼": { math: "\\msansc" }, "𝖽": { math: "\\msansd" }, "𝖾": { math: "\\msanse" }, "𝖿": { math: "\\msansf" }, "𝗀": { math: "\\msansg" }, "𝗁": { math: "\\msansh" }, "𝗂": { math: "\\msansi" }, "𝗃": { math: "\\msansj" }, "𝗄": { math: "\\msansk" }, "𝗅": { math: "\\msansl" }, "𝗆": { math: "\\msansm" }, "𝗇": { math: "\\msansn" }, "𝗈": { math: "\\msanso" }, "𝗉": { math: "\\msansp" }, "𝗊": { math: "\\msansq" }, "𝗋": { math: "\\msansr" }, "𝗌": { math: "\\msanss" }, "𝗍": { math: "\\msanst" }, "𝗎": { math: "\\msansu" }, "𝗏": { math: "\\msansv" }, "𝗐": { math: "\\msansw" }, "𝗑": { math: "\\msansx" }, "𝗒": { math: "\\msansy" }, "𝗓": { math: "\\msansz" }, "𝗔": { math: "\\mbfsansA" }, "𝗕": { math: "\\mbfsansB" }, "𝗖": { math: "\\mbfsansC" }, "𝗗": { math: "\\mbfsansD" }, "𝗘": { math: "\\mbfsansE" }, "𝗙": { math: "\\mbfsansF" }, "𝗚": { math: "\\mbfsansG" }, "𝗛": { math: "\\mbfsansH" }, "𝗜": { math: "\\mbfsansI" }, "𝗝": { math: "\\mbfsansJ" }, "𝗞": { math: "\\mbfsansK" }, "𝗟": { math: "\\mbfsansL" }, "𝗠": { math: "\\mbfsansM" }, "𝗡": { math: "\\mbfsansN" }, "𝗢": { math: "\\mbfsansO" }, "𝗣": { math: "\\mbfsansP" }, "𝗤": { math: "\\mbfsansQ" }, "𝗥": { math: "\\mbfsansR" }, "𝗦": { math: "\\mbfsansS" }, "𝗧": { math: "\\mbfsansT" }, "𝗨": { math: "\\mbfsansU" }, "𝗩": { math: "\\mbfsansV" }, "𝗪": { math: "\\mbfsansW" }, "𝗫": { math: "\\mbfsansX" }, "𝗬": { math: "\\mbfsansY" }, "𝗭": { math: "\\mbfsansZ" }, "𝗮": { math: "\\mbfsansa" }, "𝗯": { math: "\\mbfsansb" }, "𝗰": { math: "\\mbfsansc" }, "𝗱": { math: "\\mbfsansd" }, "𝗲": { math: "\\mbfsanse" }, "𝗳": { math: "\\mbfsansf" }, "𝗴": { math: "\\mbfsansg" }, "𝗵": { math: "\\mbfsansh" }, "𝗶": { math: "\\mbfsansi" }, "𝗷": { math: "\\mbfsansj" }, "𝗸": { math: "\\mbfsansk" }, "𝗹": { math: "\\mbfsansl" }, "𝗺": { math: "\\mbfsansm" }, "𝗻": { math: "\\mbfsansn" }, "𝗼": { math: "\\mbfsanso" }, "𝗽": { math: "\\mbfsansp" }, "𝗾": { math: "\\mbfsansq" }, "𝗿": { math: "\\mbfsansr" }, "𝘀": { math: "\\mbfsanss" }, "𝘁": { math: "\\mbfsanst" }, "𝘂": { math: "\\mbfsansu" }, "𝘃": { math: "\\mbfsansv" }, "𝘄": { math: "\\mbfsansw" }, "𝘅": { math: "\\mbfsansx" }, "𝘆": { math: "\\mbfsansy" }, "𝘇": { math: "\\mbfsansz" }, "𝘈": { math: "\\mitsansA" }, "𝘉": { math: "\\mitsansB" }, "𝘊": { math: "\\mitsansC" }, "𝘋": { math: "\\mitsansD" }, "𝘌": { math: "\\mitsansE" }, "𝘍": { math: "\\mitsansF" }, "𝘎": { math: "\\mitsansG" }, "𝘏": { math: "\\mitsansH" }, "𝘐": { math: "\\mitsansI" }, "𝘑": { math: "\\mitsansJ" }, "𝘒": { math: "\\mitsansK" }, "𝘓": { math: "\\mitsansL" }, "𝘔": { math: "\\mitsansM" }, "𝘕": { math: "\\mitsansN" }, "𝘖": { math: "\\mitsansO" }, "𝘗": { math: "\\mitsansP" }, "𝘘": { math: "\\mitsansQ" }, "𝘙": { math: "\\mitsansR" }, "𝘚": { math: "\\mitsansS" }, "𝘛": { math: "\\mitsansT" }, "𝘜": { math: "\\mitsansU" }, "𝘝": { math: "\\mitsansV" }, "𝘞": { math: "\\mitsansW" }, "𝘟": { math: "\\mitsansX" }, "𝘠": { math: "\\mitsansY" }, "𝘡": { math: "\\mitsansZ" }, "𝘢": { math: "\\mitsansa" }, "𝘣": { math: "\\mitsansb" }, "𝘤": { math: "\\mitsansc" }, "𝘥": { math: "\\mitsansd" }, "𝘦": { math: "\\mitsanse" }, "𝘧": { math: "\\mitsansf" }, "𝘨": { math: "\\mitsansg" }, "𝘩": { math: "\\mitsansh" }, "𝘪": { math: "\\mitsansi" }, "𝘫": { math: "\\mitsansj" }, "𝘬": { math: "\\mitsansk" }, "𝘭": { math: "\\mitsansl" }, "𝘮": { math: "\\mitsansm" }, "𝘯": { math: "\\mitsansn" }, "𝘰": { math: "\\mitsanso" }, "𝘱": { math: "\\mitsansp" }, "𝘲": { math: "\\mitsansq" }, "𝘳": { math: "\\mitsansr" }, "𝘴": { math: "\\mitsanss" }, "𝘵": { math: "\\mitsanst" }, "𝘶": { math: "\\mitsansu" }, "𝘷": { math: "\\mitsansv" }, "𝘸": { math: "\\mitsansw" }, "𝘹": { math: "\\mitsansx" }, "𝘺": { math: "\\mitsansy" }, "𝘻": { math: "\\mitsansz" }, "𝘼": { math: "\\mbfitsansA" }, "𝘽": { math: "\\mbfitsansB" }, "𝘾": { math: "\\mbfitsansC" }, "𝘿": { math: "\\mbfitsansD" }, "𝙀": { math: "\\mbfitsansE" }, "𝙁": { math: "\\mbfitsansF" }, "𝙂": { math: "\\mbfitsansG" }, "𝙃": { math: "\\mbfitsansH" }, "𝙄": { math: "\\mbfitsansI" }, "𝙅": { math: "\\mbfitsansJ" }, "𝙆": { math: "\\mbfitsansK" }, "𝙇": { math: "\\mbfitsansL" }, "𝙈": { math: "\\mbfitsansM" }, "𝙉": { math: "\\mbfitsansN" }, "𝙊": { math: "\\mbfitsansO" }, "𝙋": { math: "\\mbfitsansP" }, "𝙌": { math: "\\mbfitsansQ" }, "𝙍": { math: "\\mbfitsansR" }, "𝙎": { math: "\\mbfitsansS" }, "𝙏": { math: "\\mbfitsansT" }, "𝙐": { math: "\\mbfitsansU" }, "𝙑": { math: "\\mbfitsansV" }, "𝙒": { math: "\\mbfitsansW" }, "𝙓": { math: "\\mbfitsansX" }, "𝙔": { math: "\\mbfitsansY" }, "𝙕": { math: "\\mbfitsansZ" }, "𝙖": { math: "\\mbfitsansa" }, "𝙗": { math: "\\mbfitsansb" }, "𝙘": { math: "\\mbfitsansc" }, "𝙙": { math: "\\mbfitsansd" }, "𝙚": { math: "\\mbfitsanse" }, "𝙛": { math: "\\mbfitsansf" }, "𝙜": { math: "\\mbfitsansg" }, "𝙝": { math: "\\mbfitsansh" }, "𝙞": { math: "\\mbfitsansi" }, "𝙟": { math: "\\mbfitsansj" }, "𝙠": { math: "\\mbfitsansk" }, "𝙡": { math: "\\mbfitsansl" }, "𝙢": { math: "\\mbfitsansm" }, "𝙣": { math: "\\mbfitsansn" }, "𝙤": { math: "\\mbfitsanso" }, "𝙥": { math: "\\mbfitsansp" }, "𝙦": { math: "\\mbfitsansq" }, "𝙧": { math: "\\mbfitsansr" }, "𝙨": { math: "\\mbfitsanss" }, "𝙩": { math: "\\mbfitsanst" }, "𝙪": { math: "\\mbfitsansu" }, "𝙫": { math: "\\mbfitsansv" }, "𝙬": { math: "\\mbfitsansw" }, "𝙭": { math: "\\mbfitsansx" }, "𝙮": { math: "\\mbfitsansy" }, "𝙯": { math: "\\mbfitsansz" }, "𝙰": { math: "\\mttA" }, "𝙱": { math: "\\mttB" }, "𝙲": { math: "\\mttC" }, "𝙳": { math: "\\mttD" }, "𝙴": { math: "\\mttE" }, "𝙵": { math: "\\mttF" }, "𝙶": { math: "\\mttG" }, "𝙷": { math: "\\mttH" }, "𝙸": { math: "\\mttI" }, "𝙹": { math: "\\mttJ" }, "𝙺": { math: "\\mttK" }, "𝙻": { math: "\\mttL" }, "𝙼": { math: "\\mttM" }, "𝙽": { math: "\\mttN" }, "𝙾": { math: "\\mttO" }, "𝙿": { math: "\\mttP" }, "𝚀": { math: "\\mttQ" }, "𝚁": { math: "\\mttR" }, "𝚂": { math: "\\mttS" }, "𝚃": { math: "\\mttT" }, "𝚄": { math: "\\mttU" }, "𝚅": { math: "\\mttV" }, "𝚆": { math: "\\mttW" }, "𝚇": { math: "\\mttX" }, "𝚈": { math: "\\mttY" }, "𝚉": { math: "\\mttZ" }, "𝚊": { math: "\\mtta" }, "𝚋": { math: "\\mttb" }, "𝚌": { math: "\\mttc" }, "𝚍": { math: "\\mttd" }, "𝚎": { math: "\\mtte" }, "𝚏": { math: "\\mttf" }, "𝚐": { math: "\\mttg" }, "𝚑": { math: "\\mtth" }, "𝚒": { math: "\\mtti" }, "𝚓": { math: "\\mttj" }, "𝚔": { math: "\\mttk" }, "𝚕": { math: "\\mttl" }, "𝚖": { math: "\\mttm" }, "𝚗": { math: "\\mttn" }, "𝚘": { math: "\\mtto" }, "𝚙": { math: "\\mttp" }, "𝚚": { math: "\\mttq" }, "𝚛": { math: "\\mttr" }, "𝚜": { math: "\\mtts" }, "𝚝": { math: "\\mttt" }, "𝚞": { math: "\\mttu" }, "𝚟": { math: "\\mttv" }, "𝚠": { math: "\\mttw" }, "𝚡": { math: "\\mttx" }, "𝚢": { math: "\\mtty" }, "𝚣": { math: "\\mttz" }, "𝚤": { math: "\\imath" }, "𝚥": { math: "\\jmath" }, "𝚨": { math: "\\mbfAlpha" }, "𝚩": { math: "\\mbfBeta" }, "𝚪": { math: "\\mbfGamma" }, "𝚫": { math: "\\mbfDelta" }, "𝚬": { math: "\\mbfEpsilon" }, "𝚭": { math: "\\mbfZeta" }, "𝚮": { math: "\\mbfEta" }, "𝚯": { math: "\\mbfTheta" }, "𝚰": { math: "\\mbfIota" }, "𝚱": { math: "\\mbfKappa" }, "𝚲": { math: "\\mbfLambda" }, "𝚳": { math: "\\mbfMu" }, "𝚴": { math: "\\mbfNu" }, "𝚵": { math: "\\mbfXi" }, "𝚶": { math: "\\mbfOmicron" }, "𝚷": { math: "\\mbfPi" }, "𝚸": { math: "\\mbfRho" }, "𝚹": { math: "\\mbfvarTheta" }, "𝚺": { math: "\\mbfSigma" }, "𝚻": { math: "\\mbfTau" }, "𝚼": { math: "\\mbfUpsilon" }, "𝚽": { math: "\\mbfPhi" }, "𝚾": { math: "\\mbfChi" }, "𝚿": { math: "\\mbfPsi" }, "𝛀": { math: "\\mbfOmega" }, "𝛁": { math: "\\mbfnabla" }, "𝛂": { math: "\\mbfalpha" }, "𝛃": { math: "\\mbfbeta" }, "𝛄": { math: "\\mbfgamma" }, "𝛅": { math: "\\mbfdelta" }, "𝛆": { math: "\\mbfvarepsilon" }, "𝛇": { math: "\\mbfzeta" }, "𝛈": { math: "\\mbfeta" }, "𝛉": { math: "\\mbftheta" }, "𝛊": { math: "\\mbfiota" }, "𝛋": { math: "\\mbfkappa" }, "𝛌": { math: "\\mbflambda" }, "𝛍": { math: "\\mbfmu" }, "𝛎": { math: "\\mbfnu" }, "𝛏": { math: "\\mbfxi" }, "𝛐": { math: "\\mbfomicron" }, "𝛑": { math: "\\mbfpi" }, "𝛒": { math: "\\mbfrho" }, "𝛓": { math: "\\mbfvarsigma" }, "𝛔": { math: "\\mbfsigma" }, "𝛕": { math: "\\mbftau" }, "𝛖": { math: "\\mbfupsilon" }, "𝛗": { math: "\\mbfvarphi" }, "𝛘": { math: "\\mbfchi" }, "𝛙": { math: "\\mbfpsi" }, "𝛚": { math: "\\mbfomega" }, "𝛛": { math: "\\mbfpartial" }, "𝛜": { math: "\\mbfepsilon" }, "𝛝": { math: "\\mbfvartheta" }, "𝛞": { math: "\\mbfvarkappa" }, "𝛟": { math: "\\mbfphi" }, "𝛠": { math: "\\mbfvarrho" }, "𝛡": { math: "\\mbfvarpi" }, "𝛢": { math: "\\mitAlpha" }, "𝛣": { math: "\\mitBeta" }, "𝛤": { math: "\\mitGamma" }, "𝛥": { math: "\\mitDelta" }, "𝛦": { math: "\\mitEpsilon" }, "𝛧": { math: "\\mitZeta" }, "𝛨": { math: "\\mitEta" }, "𝛩": { math: "\\mitTheta" }, "𝛪": { math: "\\mitIota" }, "𝛫": { math: "\\mitKappa" }, "𝛬": { math: "\\mitLambda" }, "𝛭": { math: "\\mitMu" }, "𝛮": { math: "\\mitNu" }, "𝛯": { math: "\\mitXi" }, "𝛰": { math: "\\mitOmicron" }, "𝛱": { math: "\\mitPi" }, "𝛲": { math: "\\mitRho" }, "𝛳": { math: "\\mitvarTheta" }, "𝛴": { math: "\\mitSigma" }, "𝛵": { math: "\\mitTau" }, "𝛶": { math: "\\mitUpsilon" }, "𝛷": { math: "\\mitPhi" }, "𝛸": { math: "\\mitChi" }, "𝛹": { math: "\\mitPsi" }, "𝛺": { math: "\\mitOmega" }, "𝛻": { math: "\\mitnabla" }, "𝛼": { math: "\\mitalpha" }, "𝛽": { math: "\\mitbeta" }, "𝛾": { math: "\\mitgamma" }, "𝛿": { math: "\\mitdelta" }, "𝜀": { math: "\\mitvarepsilon" }, "𝜁": { math: "\\mitzeta" }, "𝜂": { math: "\\miteta" }, "𝜃": { math: "\\mittheta" }, "𝜄": { math: "\\mitiota" }, "𝜅": { math: "\\mitkappa" }, "𝜆": { math: "\\mitlambda" }, "𝜇": { math: "\\mitmu" }, "𝜈": { math: "\\mitnu" }, "𝜉": { math: "\\mitxi" }, "𝜊": { math: "\\mitomicron" }, "𝜋": { math: "\\mitpi" }, "𝜌": { math: "\\mitrho" }, "𝜍": { math: "\\mitvarsigma" }, "𝜎": { math: "\\mitsigma" }, "𝜏": { math: "\\mittau" }, "𝜐": { math: "\\mitupsilon" }, "𝜑": { math: "\\mitvarphi" }, "𝜒": { math: "\\mitchi" }, "𝜓": { math: "\\mitpsi" }, "𝜔": { math: "\\mitomega" }, "𝜕": { math: "\\mitpartial" }, "𝜖": { math: "\\mitepsilon" }, "𝜗": { math: "\\mitvartheta" }, "𝜘": { math: "\\mitvarkappa" }, "𝜙": { math: "\\mitphi" }, "𝜚": { math: "\\mitvarrho" }, "𝜛": { math: "\\mitvarpi" }, "𝜜": { math: "\\mbfitAlpha" }, "𝜝": { math: "\\mbfitBeta" }, "𝜞": { math: "\\mbfitGamma" }, "𝜟": { math: "\\mbfitDelta" }, "𝜠": { math: "\\mbfitEpsilon" }, "𝜡": { math: "\\mbfitZeta" }, "𝜢": { math: "\\mbfitEta" }, "𝜣": { math: "\\mbfitTheta" }, "𝜤": { math: "\\mbfitIota" }, "𝜥": { math: "\\mbfitKappa" }, "𝜦": { math: "\\mbfitLambda" }, "𝜧": { math: "\\mbfitMu" }, "𝜨": { math: "\\mbfitNu" }, "𝜩": { math: "\\mbfitXi" }, "𝜪": { math: "\\mbfitOmicron" }, "𝜫": { math: "\\mbfitPi" }, "𝜬": { math: "\\mbfitRho" }, "𝜭": { math: "\\mbfitvarTheta" }, "𝜮": { math: "\\mbfitSigma" }, "𝜯": { math: "\\mbfitTau" }, "𝜰": { math: "\\mbfitUpsilon" }, "𝜱": { math: "\\mbfitPhi" }, "𝜲": { math: "\\mbfitChi" }, "𝜳": { math: "\\mbfitPsi" }, "𝜴": { math: "\\mbfitOmega" }, "𝜵": { math: "\\mbfitnabla" }, "𝜶": { math: "\\mbfitalpha" }, "𝜷": { math: "\\mbfitbeta" }, "𝜸": { math: "\\mbfitgamma" }, "𝜹": { math: "\\mbfitdelta" }, "𝜺": { math: "\\mbfitvarepsilon" }, "𝜻": { math: "\\mbfitzeta" }, "𝜼": { math: "\\mbfiteta" }, "𝜽": { math: "\\mbfittheta" }, "𝜾": { math: "\\mbfitiota" }, "𝜿": { math: "\\mbfitkappa" }, "𝝀": { math: "\\mbfitlambda" }, "𝝁": { math: "\\mbfitmu" }, "𝝂": { math: "\\mbfitnu" }, "𝝃": { math: "\\mbfitxi" }, "𝝄": { math: "\\mbfitomicron" }, "𝝅": { math: "\\mbfitpi" }, "𝝆": { math: "\\mbfitrho" }, "𝝇": { math: "\\mbfitvarsigma" }, "𝝈": { math: "\\mbfitsigma" }, "𝝉": { math: "\\mbfittau" }, "𝝊": { math: "\\mbfitupsilon" }, "𝝋": { math: "\\mbfitvarphi" }, "𝝌": { math: "\\mbfitchi" }, "𝝍": { math: "\\mbfitpsi" }, "𝝎": { math: "\\mbfitomega" }, "𝝏": { math: "\\mbfitpartial" }, "𝝐": { math: "\\mbfitepsilon" }, "𝝑": { math: "\\mbfitvartheta" }, "𝝒": { math: "\\mbfitvarkappa" }, "𝝓": { math: "\\mbfitphi" }, "𝝔": { math: "\\mbfitvarrho" }, "𝝕": { math: "\\mbfitvarpi" }, "𝝖": { math: "\\mbfsansAlpha" }, "𝝗": { math: "\\mbfsansBeta" }, "𝝘": { math: "\\mbfsansGamma" }, "𝝙": { math: "\\mbfsansDelta" }, "𝝚": { math: "\\mbfsansEpsilon" }, "𝝛": { math: "\\mbfsansZeta" }, "𝝜": { math: "\\mbfsansEta" }, "𝝝": { math: "\\mbfsansTheta" }, "𝝞": { math: "\\mbfsansIota" }, "𝝟": { math: "\\mbfsansKappa" }, "𝝠": { math: "\\mbfsansLambda" }, "𝝡": { math: "\\mbfsansMu" }, "𝝢": { math: "\\mbfsansNu" }, "𝝣": { math: "\\mbfsansXi" }, "𝝤": { math: "\\mbfsansOmicron" }, "𝝥": { math: "\\mbfsansPi" }, "𝝦": { math: "\\mbfsansRho" }, "𝝧": { math: "\\mbfsansvarTheta" }, "𝝨": { math: "\\mbfsansSigma" }, "𝝩": { math: "\\mbfsansTau" }, "𝝪": { math: "\\mbfsansUpsilon" }, "𝝫": { math: "\\mbfsansPhi" }, "𝝬": { math: "\\mbfsansChi" }, "𝝭": { math: "\\mbfsansPsi" }, "𝝮": { math: "\\mbfsansOmega" }, "𝝯": { math: "\\mbfsansnabla" }, "𝝰": { math: "\\mbfsansalpha" }, "𝝱": { math: "\\mbfsansbeta" }, "𝝲": { math: "\\mbfsansgamma" }, "𝝳": { math: "\\mbfsansdelta" }, "𝝴": { math: "\\mbfsansvarepsilon" }, "𝝵": { math: "\\mbfsanszeta" }, "𝝶": { math: "\\mbfsanseta" }, "𝝷": { math: "\\mbfsanstheta" }, "𝝸": { math: "\\mbfsansiota" }, "𝝹": { math: "\\mbfsanskappa" }, "𝝺": { math: "\\mbfsanslambda" }, "𝝻": { math: "\\mbfsansmu" }, "𝝼": { math: "\\mbfsansnu" }, "𝝽": { math: "\\mbfsansxi" }, "𝝾": { math: "\\mbfsansomicron" }, "𝝿": { math: "\\mbfsanspi" }, "𝞀": { math: "\\mbfsansrho" }, "𝞁": { math: "\\mbfsansvarsigma" }, "𝞂": { math: "\\mbfsanssigma" }, "𝞃": { math: "\\mbfsanstau" }, "𝞄": { math: "\\mbfsansupsilon" }, "𝞅": { math: "\\mbfsansvarphi" }, "𝞆": { math: "\\mbfsanschi" }, "𝞇": { math: "\\mbfsanspsi" }, "𝞈": { math: "\\mbfsansomega" }, "𝞉": { math: "\\mbfsanspartial" }, "𝞊": { math: "\\mbfsansepsilon" }, "𝞋": { math: "\\mbfsansvartheta" }, "𝞌": { math: "\\mbfsansvarkappa" }, "𝞍": { math: "\\mbfsansphi" }, "𝞎": { math: "\\mbfsansvarrho" }, "𝞏": { math: "\\mbfsansvarpi" }, "𝞐": { math: "\\mbfitsansAlpha" }, "𝞑": { math: "\\mbfitsansBeta" }, "𝞒": { math: "\\mbfitsansGamma" }, "𝞓": { math: "\\mbfitsansDelta" }, "𝞔": { math: "\\mbfitsansEpsilon" }, "𝞕": { math: "\\mbfitsansZeta" }, "𝞖": { math: "\\mbfitsansEta" }, "𝞗": { math: "\\mbfitsansTheta" }, "𝞘": { math: "\\mbfitsansIota" }, "𝞙": { math: "\\mbfitsansKappa" }, "𝞚": { math: "\\mbfitsansLambda" }, "𝞛": { math: "\\mbfitsansMu" }, "𝞜": { math: "\\mbfitsansNu" }, "𝞝": { math: "\\mbfitsansXi" }, "𝞞": { math: "\\mbfitsansOmicron" }, "𝞟": { math: "\\mbfitsansPi" }, "𝞠": { math: "\\mbfitsansRho" }, "𝞡": { math: "\\mbfitsansvarTheta" }, "𝞢": { math: "\\mbfitsansSigma" }, "𝞣": { math: "\\mbfitsansTau" }, "𝞤": { math: "\\mbfitsansUpsilon" }, "𝞥": { math: "\\mbfitsansPhi" }, "𝞦": { math: "\\mbfitsansChi" }, "𝞧": { math: "\\mbfitsansPsi" }, "𝞨": { math: "\\mbfitsansOmega" }, "𝞩": { math: "\\mbfitsansnabla" }, "𝞪": { math: "\\mbfitsansalpha" }, "𝞫": { math: "\\mbfitsansbeta" }, "𝞬": { math: "\\mbfitsansgamma" }, "𝞭": { math: "\\mbfitsansdelta" }, "𝞮": { math: "\\mbfitsansvarepsilon" }, "𝞯": { math: "\\mbfitsanszeta" }, "𝞰": { math: "\\mbfitsanseta" }, "𝞱": { math: "\\mbfitsanstheta" }, "𝞲": { math: "\\mbfitsansiota" }, "𝞳": { math: "\\mbfitsanskappa" }, "𝞴": { math: "\\mbfitsanslambda" }, "𝞵": { math: "\\mbfitsansmu" }, "𝞶": { math: "\\mbfitsansnu" }, "𝞷": { math: "\\mbfitsansxi" }, "𝞸": { math: "\\mbfitsansomicron" }, "𝞹": { math: "\\mbfitsanspi" }, "𝞺": { math: "\\mbfitsansrho" }, "𝞻": { math: "\\mbfitsansvarsigma" }, "𝞼": { math: "\\mbfitsanssigma" }, "𝞽": { math: "\\mbfitsanstau" }, "𝞾": { math: "\\mbfitsansupsilon" }, "𝞿": { math: "\\mbfitsansvarphi" }, "𝟀": { math: "\\mbfitsanschi" }, "𝟁": { math: "\\mbfitsanspsi" }, "𝟂": { math: "\\mbfitsansomega" }, "𝟃": { math: "\\mbfitsanspartial" }, "𝟄": { math: "\\mbfitsansepsilon" }, "𝟅": { math: "\\mbfitsansvartheta" }, "𝟆": { math: "\\mbfitsansvarkappa" }, "𝟇": { math: "\\mbfitsansphi" }, "𝟈": { math: "\\mbfitsansvarrho" }, "𝟉": { math: "\\mbfitsansvarpi" }, "𝟊": { math: "\\mbfDigamma" }, "𝟋": { math: "\\mbfdigamma" }, "𝟎": { math: "\\mbfzero" }, "𝟏": { math: "\\mbfone" }, "𝟐": { math: "\\mbftwo" }, "𝟑": { math: "\\mbfthree" }, "𝟒": { math: "\\mbffour" }, "𝟓": { math: "\\mbffive" }, "𝟔": { math: "\\mbfsix" }, "𝟕": { math: "\\mbfseven" }, "𝟖": { math: "\\mbfeight" }, "𝟗": { math: "\\mbfnine" }, "𝟘": { math: "\\Bbbzero" }, "𝟙": { math: "\\Bbbone" }, "𝟚": { math: "\\Bbbtwo" }, "𝟛": { math: "\\Bbbthree" }, "𝟜": { math: "\\Bbbfour" }, "𝟝": { math: "\\Bbbfive" }, "𝟞": { math: "\\Bbbsix" }, "𝟟": { math: "\\Bbbseven" }, "𝟠": { math: "\\Bbbeight" }, "𝟡": { math: "\\Bbbnine" }, "𝟢": { math: "\\msanszero" }, "𝟣": { math: "\\msansone" }, "𝟤": { math: "\\msanstwo" }, "𝟥": { math: "\\msansthree" }, "𝟦": { math: "\\msansfour" }, "𝟧": { math: "\\msansfive" }, "𝟨": { math: "\\msanssix" }, "𝟩": { math: "\\msansseven" }, "𝟪": { math: "\\msanseight" }, "𝟫": { math: "\\msansnine" }, "𝟬": { math: "\\mbfsanszero" }, "𝟭": { math: "\\mbfsansone" }, "𝟮": { math: "\\mbfsanstwo" }, "𝟯": { math: "\\mbfsansthree" }, "𝟰": { math: "\\mbfsansfour" }, "𝟱": { math: "\\mbfsansfive" }, "𝟲": { math: "\\mbfsanssix" }, "𝟳": { math: "\\mbfsansseven" }, "𝟴": { math: "\\mbfsanseight" }, "𝟵": { math: "\\mbfsansnine" }, "𝟶": { math: "\\mttzero" }, "𝟷": { math: "\\mttone" }, "𝟸": { math: "\\mtttwo" }, "𝟹": { math: "\\mttthree" }, "𝟺": { math: "\\mttfour" }, "𝟻": { math: "\\mttfive" }, "𝟼": { math: "\\mttsix" }, "𝟽": { math: "\\mttseven" }, "𝟾": { math: "\\mtteight" }, "𝟿": { math: "\\mttnine" }, ữ0: { math: "\\arabicmaj" }, ữ1: { math: "\\arabichad" }, "‐": { math: "\\mathhyphen" }, "―": { math: "\\horizbar" }, "‗": { math: "\\twolowline" }, "‥": { math: "\\enleadertwodots" }, "″": { math: "\\dprime" }, "‴": { math: "\\trprime" }, "‵": { math: "\\backprime" }, "‶": { math: "\\backdprime" }, "‷": { math: "\\backtrprime" }, "‸": { math: "\\caretinsert" }, "‼": { math: "\\Exclam" }, "⁀": { math: "\\tieconcat" }, "⁃": { math: "\\hyphenbullet" }, "⁄": { math: "\\fracslash" }, "⁇": { math: "\\Question" }, "⁐": { math: "\\closure" }, "⁗": { math: "\\qprime" }, "⃒": { math: "\\vertoverlay" }, "⃗": { math: "\\vec" }, "⃛": { math: "\\dddot" }, "⃜": { math: "\\ddddot" }, "⃝": { math: "\\enclosecircle" }, "⃞": { math: "\\enclosesquare" }, "⃟": { math: "\\enclosediamond" }, "⃡": { math: "\\overleftrightarrow" }, "⃤": { math: "\\enclosetriangle" }, "⃧": { math: "\\annuity" }, "⃨": { math: "\\threeunderdot" }, "⃩": { math: "\\widebridgeabove" }, "⃬": { math: "\\underrightharpoondown" }, "⃭": { math: "\\underleftharpoondown" }, "⃮": { math: "\\underleftarrow" }, "⃯": { math: "\\underrightarrow" }, "⃰": { math: "\\asteraccent" }, ℎ: { math: "\\Planckconst" }, ℏ: { math: "\\hslash" }, ℒ: { math: "\\mscrL" }, ℛ: { math: "\\mscrR" }, "℧": { math: "\\mho" }, "℩": { math: "\\turnediota" }, "Ⅎ": { math: "\\Finv" }, ℶ: { math: "\\beth" }, ℷ: { math: "\\gimel" }, ℸ: { math: "\\daleth" }, "⅁": { math: "\\Game" }, "⅂": { math: "\\sansLturned" }, "⅃": { math: "\\sansLmirrored" }, "⅄": { math: "\\Yup" }, "ⅅ": { math: "\\CapitalDifferentialD" }, "⅊": { math: "\\PropertyLine" }, "↚": { math: "\\nleftarrow" }, "↛": { math: "\\nrightarrow" }, "↞": { math: "\\twoheadleftarrow" }, "↟": { math: "\\twoheaduparrow" }, "↠": { math: "\\twoheadrightarrow" }, "↡": { math: "\\twoheaddownarrow" }, "↢": { math: "\\leftarrowtail" }, "↣": { math: "\\rightarrowtail" }, "↤": { math: "\\mapsfrom" }, "↥": { math: "\\mapsup" }, "↧": { math: "\\mapsdown" }, "↨": { math: "\\updownarrowbar" }, "↫": { math: "\\looparrowleft" }, "↬": { math: "\\looparrowright" }, "↭": { math: "\\leftrightsquigarrow" }, "↮": { math: "\\nleftrightarrow" }, "↰": { math: "\\Lsh" }, "↱": { math: "\\Rsh" }, "↳": { text: "\\reflectbox{\\carriagereturn}", math: "\\Rdsh" }, "↴": { math: "\\linefeed" }, "↵": { math: "\\carriagereturn" }, "↶": { math: "\\curvearrowleft" }, "↷": { math: "\\curvearrowright" }, "↸": { math: "\\barovernorthwestarrow" }, "↹": { math: "\\barleftarrowrightarrowbar" }, "↺": { math: "\\circlearrowleft" }, "↾": { math: "\\upharpoonright" }, "↿": { math: "\\upharpoonleft" }, "⇁": { math: "\\rightharpoondown" }, "⇂": { math: "\\downharpoonright" }, "⇃": { math: "\\downharpoonleft" }, "⇄": { math: "\\rightleftarrows" }, "⇆": { math: "\\leftrightarrows" }, "⇇": { math: "\\leftleftarrows" }, "⇈": { math: "\\upuparrows" }, "⇉": { math: "\\rightrightarrows" }, "⇊": { math: "\\downdownarrows" }, "⇋": { math: "\\leftrightharpoons" }, "⇍": { math: "\\nLeftarrow" }, "⇎": { math: "\\nLeftrightarrow" }, "⇏": { math: "\\nRightarrow" }, "⇖": { math: "\\Nwarrow" }, "⇗": { math: "\\Nearrow" }, "⇘": { math: "\\Searrow" }, "⇙": { math: "\\Swarrow" }, "⇚": { math: "\\Lleftarrow" }, "⇛": { math: "\\Rrightarrow" }, "⇜": { math: "\\leftsquigarrow" }, "⇝": { math: "\\rightsquigarrow" }, "⇞": { math: "\\nHuparrow" }, "⇟": { math: "\\nHdownarrow" }, "⇡": { math: "\\updasharrow" }, "⇣": { math: "\\downdasharrow" }, "⇦": { math: "\\leftwhitearrow" }, "⇧": { math: "\\upwhitearrow" }, "⇨": { math: "\\rightwhitearrow" }, "⇩": { math: "\\downwhitearrow" }, "⇪": { math: "\\whitearrowupfrombar" }, "⇴": { math: "\\circleonrightarrow" }, "⇶": { math: "\\rightthreearrows" }, "⇷": { math: "\\nvleftarrow" }, "⇹": { math: "\\nvleftrightarrow" }, "⇺": { math: "\\nVleftarrow" }, "⇼": { math: "\\nVleftrightarrow" }, "⇽": { math: "\\leftarrowtriangle" }, "⇾": { math: "\\rightarrowtriangle" }, "⇿": { math: "\\leftrightarrowtriangle" }, "∁": { math: "\\complement" }, "∄": { math: "\\nexists" }, "∅": { math: "\\varnothing" }, "∆": { math: "\\increment" }, "∇": { math: "\\nabla" }, "∊": { math: "\\smallin" }, "∍": { math: "\\smallni" }, "∎": { math: "\\QED" }, "∔": { math: "\\dotplus" }, "∕": { math: "\\divslash" }, "√": { math: "\\sqrt" }, "∟": { math: "\\rightangle" }, "∡": { math: "\\measuredangle" }, "∢": { math: "\\sphericalangle" }, "∤": { math: "\\nmid" }, "∦": { math: "\\nparallel" }, "∲": { math: "\\lcirclerightint" }, "∴": { math: "\\therefore" }, "∵": { math: "\\because" }, "∷": { math: "\\Colon" }, "∹": { math: "\\eqcolon" }, "∽": { math: "\\backsim" }, "≊": { math: "\\approxeq" }, "≎": { math: "\\Bumpeq" }, "≏": { math: "\\bumpeq" }, "≒": { math: "\\fallingdotseq" }, "≓": { math: "\\risingdotseq" }, "≔": { math: "\\coloneq" }, "≖": { math: "\\eqcirc" }, "≗": { math: "\\circeq" }, "≘": { math: "\\arceq" }, "≚": { math: "\\veeeq" }, "≜": { math: "\\triangleq" }, "≝": { math: "\\eqdef" }, "≞": { math: "\\measeq" }, "≟": { math: "\\questeq" }, "≣": { math: "\\Equiv" }, "≨": { math: "\\lneqq" }, "≩": { math: "\\gneqq" }, "≬": { math: "\\between" }, "≭": { math: "\\nasymp" }, "≴": { math: "\\nlesssim" }, "≵": { math: "\\ngtrsim" }, "≶": { math: "\\lessgtr" }, "≷": { math: "\\gtrless" }, "≼": { math: "\\preccurlyeq" }, "≽": { math: "\\succcurlyeq" }, "⊊": { math: "\\subsetneq" }, "⊋": { math: "\\supsetneq" }, "⊌": { math: "\\cupleftarrow" }, "⊍": { math: "\\cupdot" }, "⊏": { math: "\\sqsubset" }, "⊐": { math: "\\sqsupset" }, "⊚": { math: "\\circledcirc" }, "⊛": { math: "\\circledast" }, "⊜": { math: "\\circledequal" }, "⊝": { math: "\\circleddash" }, "⊞": { math: "\\boxplus" }, "⊟": { math: "\\boxminus" }, "⊠": { math: "\\boxtimes" }, "⊡": { math: "\\boxdot" }, "⊦": { math: "\\assert" }, "⊩": { math: "\\Vdash" }, "⊪": { math: "\\Vvdash" }, "⊫": { math: "\\VDash" }, "⊬": { math: "\\nvdash" }, "⊭": { math: "\\nvDash" }, "⊮": { math: "\\nVdash" }, "⊯": { math: "\\nVDash" }, "⊰": { math: "\\prurel" }, "⊱": { math: "\\scurel" }, "⊲": { math: "\\vartriangleleft" }, "⊳": { math: "\\vartriangleright" }, "⊴": { math: "\\trianglelefteq" }, "⊵": { math: "\\trianglerighteq" }, "⊸": { math: "\\multimap" }, "⊺": { math: "\\intercal" }, "⊻": { math: "\\veebar" }, "⊼": { math: "\\barwedge" }, "⊽": { math: "\\barvee" }, "⊿": { math: "\\varlrtriangle" }, "⋇": { math: "\\divideontimes" }, "⋉": { math: "\\ltimes" }, "⋊": { math: "\\rtimes" }, "⋋": { math: "\\leftthreetimes" }, "⋌": { math: "\\rightthreetimes" }, "⋍": { math: "\\backsimeq" }, "⋎": { math: "\\curlyvee" }, "⋏": { math: "\\curlywedge" }, "⋐": { math: "\\Subset" }, "⋑": { math: "\\Supset" }, "⋒": { math: "\\Cap" }, "⋓": { math: "\\Cup" }, "⋔": { math: "\\pitchfork" }, "⋕": { math: "\\hash" }, "⋖": { math: "\\lessdot" }, "⋗": { math: "\\gtrdot" }, "⋚": { math: "\\lesseqgtr" }, "⋛": { math: "\\gtreqless" }, "⋜": { math: "\\eqless" }, "⋝": { math: "\\eqgtr" }, "⋞": { math: "\\curlyeqprec" }, "⋟": { math: "\\curlyeqsucc" }, "⋠": { math: "\\npreceq" }, "⋡": { math: "\\nsucceq" }, "⋤": { math: "\\sqsubsetneq" }, "⋥": { math: "\\sqsupsetneq" }, "⋦": { math: "\\lnsim" }, "⋧": { math: "\\gnsim" }, "⋨": { math: "\\precedesnotsimilar" }, "⋩": { math: "\\succnsim" }, "⋬": { math: "\\ntrianglelefteq" }, "⋭": { math: "\\ntrianglerighteq" }, "⋲": { math: "\\disin" }, "⋳": { math: "\\varisins" }, "⋴": { math: "\\isins" }, "⋵": { math: "\\isindot" }, "⋷": { math: "\\isinobar" }, "⋸": { math: "\\isinvb" }, "⋹": { math: "\\isinE" }, "⋺": { math: "\\nisd" }, "⋻": { math: "\\varnis" }, "⋼": { math: "\\nis" }, "⋽": { math: "\\varniobar" }, "⋾": { math: "\\niobar" }, "⋿": { math: "\\bagmember" }, "⌀": { math: "\\diameter" }, "⌂": { math: "\\house" }, "⌅": { text: "{\\barwedge}", math: "\\varbarwedge" }, "⌐": { math: "\\invneg" }, "⌒": { math: "\\profline" }, "⌓": { math: "\\profsurf" }, "⌗": { math: "\\viewdata" }, "⌙": { math: "\\turnednot" }, "⌜": { math: "\\ulcorner" }, "⌝": { math: "\\urcorner" }, "⌞": { math: "\\llcorner" }, "⌟": { math: "\\lrcorner" }, "⌠": { math: "\\inttop" }, "⌡": { math: "\\intbottom" }, "⌬": { math: "\\varhexagonlrbonds" }, "⌲": { math: "\\conictaper" }, "⌶": { math: "\\topbot" }, "⌽": { math: "\\obar" }, "⍓": { math: "\\APLboxupcaret" }, "⍰": { math: "\\APLboxquestion" }, "⍼": { math: "\\rangledownzigzagarrow" }, "⎔": { math: "\\hexagon" }, "⎛": { math: "\\lparenuend" }, "⎜": { math: "\\lparenextender" }, "⎝": { math: "\\lparenlend" }, "⎞": { math: "\\rparenuend" }, "⎟": { math: "\\rparenextender" }, "⎠": { math: "\\rparenlend" }, "⎡": { math: "\\lbrackuend" }, "⎢": { math: "\\lbrackextender" }, "⎣": { math: "\\lbracklend" }, "⎤": { math: "\\rbrackuend" }, "⎥": { math: "\\rbrackextender" }, "⎦": { math: "\\rbracklend" }, "⎧": { math: "\\lbraceuend" }, "⎨": { math: "\\lbracemid" }, "⎩": { math: "\\lbracelend" }, "⎪": { math: "\\vbraceextender" }, "⎫": { math: "\\rbraceuend" }, "⎬": { math: "\\rbracemid" }, "⎭": { math: "\\rbracelend" }, "⎮": { math: "\\intextender" }, "⎯": { math: "\\harrowextender" }, "⎲": { math: "\\sumtop" }, "⎳": { math: "\\sumbottom" }, "⎴": { math: "\\overbracket" }, "⎵": { math: "\\underbracket" }, "⎶": { math: "\\bbrktbrk" }, "⎷": { math: "\\sqrtbottom" }, "⎸": { math: "\\lvboxline" }, "⎹": { math: "\\rvboxline" }, "⏎": { math: "\\varcarriagereturn" }, "⏜": { math: "\\overparen" }, "⏝": { math: "\\underparen" }, "⏞": { math: "\\overbrace" }, "⏟": { math: "\\underbrace" }, "⏠": { math: "\\obrbrak" }, "⏡": { math: "\\ubrbrak" }, "⏢": { math: "\\trapezium" }, "⏣": { math: "\\benzenr" }, "⏤": { math: "\\strns" }, "⏥": { math: "\\fltns" }, "⏦": { math: "\\accurrent" }, "⏧": { math: "\\elinters" }, "␢": { math: "\\blanksymbol" }, "␣": { math: "\\mathvisiblespace" }, "┆": { math: "\\bdtriplevdash" }, "▀": { math: "\\blockuphalf" }, "▄": { math: "\\blocklowhalf" }, "█": { math: "\\blockfull" }, "▌": { math: "\\blocklefthalf" }, "▐": { math: "\\blockrighthalf" }, "░": { math: "\\blockqtrshaded" }, "▒": { math: "\\blockhalfshaded" }, "▓": { math: "\\blockthreeqtrshaded" }, "■": { math: "\\mdlgblksquare" }, "▢": { math: "\\squoval" }, "▣": { math: "\\blackinwhitesquare" }, "▤": { math: "\\squarehfill" }, "▥": { math: "\\squarevfill" }, "▦": { math: "\\squarehvfill" }, "▧": { math: "\\squarenwsefill" }, "▨": { math: "\\squareneswfill" }, "▩": { math: "\\squarecrossfill" }, "▪": { math: "\\smblksquare" }, "▫": { math: "\\smwhtsquare" }, "▬": { math: "\\hrectangleblack" }, "▭": { math: "\\hrectangle" }, "▮": { math: "\\vrectangleblack" }, "▯": { math: "\\vrectangle" }, "▰": { math: "\\parallelogramblack" }, "▱": { math: "\\parallelogram" }, "▲": { math: "\\bigblacktriangleup" }, "△": { math: "\\bigtriangleup" }, "▴": { math: "\\blacktriangle" }, "▵": { math: "\\vartriangle" }, "▸": { math: "\\smallblacktriangleright" }, "▹": { math: "\\smalltriangleright" }, "►": { math: "\\blackpointerright" }, "▻": { math: "\\whitepointerright" }, "▼": { math: "\\bigblacktriangledown" }, "▾": { math: "\\blacktriangledown" }, "▿": { math: "\\triangledown" }, "◂": { math: "\\smallblacktriangleleft" }, "◃": { math: "\\smalltriangleleft" }, "◄": { math: "\\blackpointerleft" }, "◅": { math: "\\whitepointerleft" }, "◈": { math: "\\blackinwhitediamond" }, "◉": { math: "\\fisheye" }, "◊": { math: "\\lozenge" }, "◌": { math: "\\dottedcircle" }, "◍": { math: "\\circlevertfill" }, "◎": { math: "\\bullseye" }, "◐": { math: "\\circlelefthalfblack" }, "◑": { math: "\\circlerighthalfblack" }, "◒": { math: "\\circlebottomhalfblack" }, "◓": { math: "\\circletophalfblack" }, "◔": { math: "\\circleurquadblack" }, "◕": { math: "\\blackcircleulquadwhite" }, "◖": { math: "\\blacklefthalfcircle" }, "◗": { math: "\\blackrighthalfcircle" }, "◘": { math: "\\inversebullet" }, "◙": { math: "\\inversewhitecircle" }, "◚": { math: "\\invwhiteupperhalfcircle" }, "◛": { math: "\\invwhitelowerhalfcircle" }, "◜": { math: "\\ularc" }, "◝": { math: "\\urarc" }, "◞": { math: "\\lrarc" }, "◟": { math: "\\llarc" }, "◠": { math: "\\topsemicircle" }, "◡": { math: "\\botsemicircle" }, "◢": { math: "\\lrblacktriangle" }, "◣": { math: "\\llblacktriangle" }, "◤": { math: "\\ulblacktriangle" }, "◥": { math: "\\urblacktriangle" }, "◦": { math: "\\smwhtcircle" }, "◧": { math: "\\squareleftblack" }, "◨": { math: "\\squarerightblack" }, "◩": { math: "\\squareulblack" }, "◪": { math: "\\squarelrblack" }, "◫": { math: "\\boxbar" }, "◬": { math: "\\trianglecdot" }, "◭": { math: "\\triangleleftblack" }, "◮": { math: "\\trianglerightblack" }, "◰": { math: "\\squareulquad" }, "◱": { math: "\\squarellquad" }, "◲": { math: "\\squarelrquad" }, "◳": { math: "\\squareurquad" }, "◴": { math: "\\circleulquad" }, "◵": { math: "\\circlellquad" }, "◶": { math: "\\circlelrquad" }, "◷": { math: "\\circleurquad" }, "◸": { math: "\\ultriangle" }, "◹": { math: "\\urtriangle" }, "◺": { math: "\\lltriangle" }, "◻": { math: "\\mdwhtsquare" }, "◼": { math: "\\mdblksquare" }, "◽": { math: "\\mdsmwhtsquare" }, "◾": { math: "\\mdsmblksquare" }, "◿": { math: "\\lrtriangle" }, "★": { math: "\\bigstar" }, "☆": { math: "\\bigwhitestar" }, "☡": { math: "\\danger" }, "☻": { math: "\\blacksmiley" }, "☼": { math: "\\sun" }, "☽": { math: "\\rightmoon" }, "☾": { math: "\\leftmoon" }, "♀": { math: "\\female" }, "♂": { math: "\\male" }, "♤": { math: "\\varspadesuit" }, "♥": { math: "\\varheartsuit" }, "♦": { math: "\\vardiamondsuit" }, "♧": { math: "\\varclubsuit" }, "♩": { math: "\\quarternote" }, "♪": { math: "\\eighthnote" }, "♫": { math: "\\twonotes" }, "♬": { math: "\\sixteenthnote" }, "♾": { math: "\\acidfree" }, "⚀": { math: "\\dicei" }, "⚁": { math: "\\diceii" }, "⚂": { math: "\\diceiii" }, "⚃": { math: "\\diceiv" }, "⚄": { math: "\\dicev" }, "⚅": { math: "\\dicevi" }, "⚆": { math: "\\circledrightdot" }, "⚇": { math: "\\circledtwodots" }, "⚈": { math: "\\blackcircledrightdot" }, "⚉": { math: "\\blackcircledtwodots" }, "⚥": { math: "\\Hermaphrodite" }, "⚬": { math: "\\mdsmwhtcircle" }, "⚲": { math: "\\neuter" }, "✓": { math: "\\checkmark" }, "✠": { math: "\\maltese" }, "✪": { math: "\\circledstar" }, "✶": { math: "\\varstar" }, "✽": { math: "\\dingasterisk" }, "❲": { math: "\\lbrbrak" }, "❳": { math: "\\rbrbrak" }, "➛": { math: "\\draftingarrow" }, "⟀": { math: "\\threedangle" }, "⟁": { math: "\\whiteinwhitetriangle" }, "⟃": { math: "\\subsetcirc" }, "⟄": { math: "\\supsetcirc" }, "⟇": { math: "\\veedot" }, "⟈": { math: "\\bsolhsub" }, "⟉": { math: "\\suphsol" }, "⟋": { math: "\\diagup" }, "⟌": { math: "\\longdivision" }, "⟍": { math: "\\diagdown" }, "⟑": { math: "\\wedgedot" }, "⟒": { math: "\\upin" }, "⟓": { math: "\\pullback" }, "⟔": { math: "\\pushout" }, "⟕": { math: "\\leftouterjoin" }, "⟖": { math: "\\rightouterjoin" }, "⟗": { math: "\\fullouterjoin" }, "⟘": { math: "\\bigbot" }, "⟙": { math: "\\bigtop" }, "⟚": { math: "\\DashVDash" }, "⟛": { math: "\\dashVdash" }, "⟜": { math: "\\multimapinv" }, "⟝": { math: "\\vlongdash" }, "⟞": { math: "\\longdashv" }, "⟟": { math: "\\cirbot" }, "⟠": { math: "\\lozengeminus" }, "⟡": { math: "\\concavediamond" }, "⟢": { math: "\\concavediamondtickleft" }, "⟣": { math: "\\concavediamondtickright" }, "⟤": { math: "\\whitesquaretickleft" }, "⟥": { math: "\\whitesquaretickright" }, "⟫": { math: "\\rang" }, "⟬": { math: "\\Lbrbrak" }, "⟭": { math: "\\Rbrbrak" }, "⟰": { math: "\\UUparrow" }, "⟱": { math: "\\DDownarrow" }, "⟲": { math: "\\acwgapcirclearrow" }, "⟳": { math: "\\cwgapcirclearrow" }, "⟴": { math: "\\rightarrowonoplus" }, "⟻": { math: "\\longmapsfrom" }, "⟽": { math: "\\Longmapsfrom" }, "⟾": { math: "\\Longmapsto" }, "⟿": { math: "\\longrightsquigarrow" }, "⤁": { math: "\\nVtwoheadrightarrow" }, "⤂": { math: "\\nvLeftarrow" }, "⤃": { math: "\\nvRightarrow" }, "⤄": { math: "\\nvLeftrightarrow" }, "⤅": { math: "\\twoheadmapsto" }, "⤆": { math: "\\Mapsfrom" }, "⤇": { math: "\\Mapsto" }, "⤈": { math: "\\downarrowbarred" }, "⤉": { math: "\\uparrowbarred" }, "⤊": { math: "\\Uuparrow" }, "⤋": { math: "\\Ddownarrow" }, "⤌": { math: "\\leftbkarrow" }, "⤍": { math: "\\rightbkarrow" }, "⤎": { math: "\\leftdbkarrow" }, "⤏": { math: "\\dbkarrow" }, "⤐": { math: "\\drbkarrow" }, "⤑": { math: "\\rightdotarrow" }, "⤗": { math: "\\nvtwoheadrightarrowtail" }, "⤘": { math: "\\nVtwoheadrightarrowtail" }, "⤙": { math: "\\lefttail" }, "⤚": { math: "\\righttail" }, "⤛": { math: "\\leftdbltail" }, "⤜": { math: "\\rightdbltail" }, "⤝": { math: "\\diamondleftarrow" }, "⤞": { math: "\\rightarrowdiamond" }, "⤟": { math: "\\diamondleftarrowbar" }, "⤠": { math: "\\barrightarrowdiamond" }, "⤡": { math: "\\nwsearrow" }, "⤢": { math: "\\neswarrow" }, "⤣": { math: "\\hknwarrow" }, "⤤": { math: "\\hknearrow" }, "⤥": { math: "\\hksearrow" }, "⤦": { math: "\\hkswarrow" }, "⤧": { math: "\\tona" }, "⤨": { math: "\\toea" }, "⤩": { math: "\\tosa" }, "⤪": { math: "\\towa" }, "⤫": { math: "\\rdiagovfdiag" }, "⤬": { math: "\\fdiagovrdiag" }, "⤭": { math: "\\seovnearrow" }, "⤮": { math: "\\neovsearrow" }, "⤯": { math: "\\fdiagovnearrow" }, "⤰": { math: "\\rdiagovsearrow" }, "⤱": { math: "\\neovnwarrow" }, "⤲": { math: "\\nwovnearrow" }, "⤳": { math: "\\rightcurvedarrow" }, "⤴": { math: "\\uprightcurvearrow" }, "⤵": { math: "\\downrightcurvedarrow" }, "⤶": { math: "\\leftdowncurvedarrow" }, "⤷": { math: "\\rightdowncurvedarrow" }, "⤸": { math: "\\cwrightarcarrow" }, "⤹": { math: "\\acwleftarcarrow" }, "⤺": { math: "\\acwoverarcarrow" }, "⤻": { math: "\\acwunderarcarrow" }, "⤼": { math: "\\curvearrowrightminus" }, "⤽": { math: "\\curvearrowleftplus" }, "⤾": { math: "\\cwundercurvearrow" }, "⤿": { math: "\\ccwundercurvearrow" }, "⥂": { math: "\\rightarrowshortleftarrow" }, "⥃": { math: "\\leftarrowshortrightarrow" }, "⥄": { math: "\\shortrightarrowleftarrow" }, "⥅": { math: "\\rightarrowplus" }, "⥆": { math: "\\leftarrowplus" }, "⥇": { math: "\\rightarrowx" }, "⥈": { math: "\\leftrightarrowcircle" }, "⥉": { math: "\\twoheaduparrowcircle" }, "⥌": { math: "\\updownharpoonrightleft" }, "⥍": { math: "\\updownharpoonleftright" }, "⥎": { math: "\\leftrightharpoonupup" }, "⥐": { math: "\\DownLeftRightVector" }, "⥦": { math: "\\leftrightharpoonsup" }, "⥧": { math: "\\leftrightharpoonsdown" }, "⥨": { math: "\\rightleftharpoonsup" }, "⥩": { math: "\\rightleftharpoonsdown" }, "⥱": { math: "\\equalrightarrow" }, "⥲": { math: "\\similarrightarrow" }, "⥳": { math: "\\leftarrowsimilar" }, "⥴": { math: "\\rightarrowsimilar" }, "⥵": { math: "\\rightarrowapprox" }, "⥶": { math: "\\ltlarr" }, "⥷": { math: "\\leftarrowless" }, "⥸": { math: "\\gtrarr" }, "⥹": { math: "\\subrarr" }, "⥺": { math: "\\leftarrowsubset" }, "⥻": { math: "\\suplarr" }, "⥼": { math: "\\leftfishtail" }, "⥽": { math: "\\rightfishtail" }, "⥾": { math: "\\upfishtail" }, "⥿": { math: "\\downfishtail" }, "⦀": { math: "\\Vvert" }, "⦁": { math: "\\spot" }, "⦂": { math: "\\typecolon" }, "⦃": { math: "\\lBrace" }, "⦄": { math: "\\rBrace" }, "⦅": { math: "\\lParen" }, "⦆": { math: "\\Elroang" }, "⦇": { math: "\\limg" }, "⦋": { math: "\\lbrackubar" }, "⦌": { math: "\\rbrackubar" }, "⦍": { math: "\\lbrackultick" }, "⦎": { math: "\\rbracklrtick" }, "⦏": { math: "\\lbracklltick" }, "⦐": { math: "\\rbrackurtick" }, "⦑": { math: "\\langledot" }, "⦒": { math: "\\rangledot" }, "⦓": { math: "\\lparenless" }, "⦔": { math: "\\rparengtr" }, "⦕": { math: "\\Lparengtr" }, "⦖": { math: "\\Rparenless" }, "⦗": { math: "\\lblkbrbrak" }, "⦘": { math: "\\rblkbrbrak" }, "⦙": { math: "\\fourvdots" }, "⦚": { math: "\\vzigzag" }, "⦛": { math: "\\measuredangleleft" }, "⦝": { math: "\\rightanglemdot" }, "⦞": { math: "\\angles" }, "⦟": { math: "\\angdnr" }, "⦠": { math: "\\gtlpar" }, "⦡": { math: "\\sphericalangleup" }, "⦢": { math: "\\turnangle" }, "⦣": { math: "\\revangle" }, "⦤": { math: "\\angleubar" }, "⦥": { math: "\\revangleubar" }, "⦦": { math: "\\wideangledown" }, "⦧": { math: "\\wideangleup" }, "⦨": { math: "\\measanglerutone" }, "⦩": { math: "\\measanglelutonw" }, "⦪": { math: "\\measanglerdtose" }, "⦫": { math: "\\measangleldtosw" }, "⦬": { math: "\\measangleurtone" }, "⦭": { math: "\\measangleultonw" }, "⦮": { math: "\\measangledrtose" }, "⦯": { math: "\\measangledltosw" }, "⦰": { math: "\\revemptyset" }, "⦱": { math: "\\emptysetobar" }, "⦲": { math: "\\emptysetocirc" }, "⦳": { math: "\\emptysetoarr" }, "⦴": { math: "\\emptysetoarrl" }, "⦵": { math: "\\circlehbar" }, "⦶": { math: "\\circledvert" }, "⦷": { math: "\\circledparallel" }, "⦸": { math: "\\circledbslash" }, "⦹": { math: "\\operp" }, "⦺": { math: "\\obot" }, "⦻": { math: "\\olcross" }, "⦼": { math: "\\odotslashdot" }, "⦽": { math: "\\uparrowoncircle" }, "⦾": { math: "\\circledwhitebullet" }, "⦿": { math: "\\circledbullet" }, "⧀": { math: "\\circledless" }, "⧁": { math: "\\circledgtr" }, "⧂": { math: "\\cirscir" }, "⧃": { math: "\\cirE" }, "⧅": { math: "\\boxbslash" }, "⧆": { math: "\\boxast" }, "⧇": { math: "\\boxcircle" }, "⧈": { math: "\\boxbox" }, "⧉": { math: "\\boxonbox" }, "⧊": { math: "\\triangleodot" }, "⧋": { math: "\\triangleubar" }, "⧌": { math: "\\triangles" }, "⧍": { math: "\\triangleserifs" }, "⧎": { math: "\\rtriltri" }, "⧑": { math: "\\lfbowtie" }, "⧒": { math: "\\rfbowtie" }, "⧓": { math: "\\fbowtie" }, "⧔": { math: "\\lftimes" }, "⧕": { math: "\\rftimes" }, "⧖": { math: "\\hourglass" }, "⧗": { math: "\\blackhourglass" }, "⧘": { math: "\\lvzigzag" }, "⧙": { math: "\\rvzigzag" }, "⧚": { math: "\\Lvzigzag" }, "⧛": { math: "\\Rvzigzag" }, "⧜": { math: "\\iinfin" }, "⧝": { math: "\\tieinfty" }, "⧞": { math: "\\nvinfty" }, "⧠": { math: "\\laplac" }, "⧡": { math: "\\lrtriangleeq" }, "⧢": { math: "\\shuffle" }, "⧣": { math: "\\eparsl" }, "⧤": { math: "\\smeparsl" }, "⧥": { math: "\\eqvparsl" }, "⧦": { math: "\\gleichstark" }, "⧧": { math: "\\thermod" }, "⧨": { math: "\\downtriangleleftblack" }, "⧩": { math: "\\downtrianglerightblack" }, "⧪": { math: "\\blackdiamonddownarrow" }, "⧫": { math: "\\blacklozenge" }, "⧬": { math: "\\circledownarrow" }, "⧭": { math: "\\blackcircledownarrow" }, "⧮": { math: "\\errbarsquare" }, "⧯": { math: "\\errbarblacksquare" }, "⧰": { math: "\\errbardiamond" }, "⧱": { math: "\\errbarblackdiamond" }, "⧲": { math: "\\errbarcircle" }, "⧳": { math: "\\errbarblackcircle" }, "⧴": { math: "\\RuleDelayed" }, "⧶": { math: "\\dsol" }, "⧷": { math: "\\rsolbar" }, "⧸": { math: "\\xsol" }, "⧺": { math: "\\doubleplus" }, "⧻": { math: "\\tripleplus" }, "⧼": { math: "\\lcurvyangle" }, "⧽": { math: "\\rcurvyangle" }, "⧾": { math: "\\tplus" }, "⧿": { math: "\\tminus" }, "⨃": { math: "\\bigcupdot" }, "⨄": { math: "\\Elxuplus" }, "⨅": { math: "\\bigsqcap" }, "⨇": { math: "\\conjquant" }, "⨈": { math: "\\disjquant" }, "⨊": { math: "\\modtwosum" }, "⨋": { math: "\\sumint" }, "⨌": { math: "\\iiiint" }, "⨍": { math: "\\intbar" }, "⨎": { math: "\\intBar" }, "⨐": { math: "\\cirfnint" }, "⨑": { math: "\\awint" }, "⨒": { math: "\\rppolint" }, "⨓": { math: "\\scpolint" }, "⨔": { math: "\\npolint" }, "⨕": { math: "\\pointint" }, "⨗": { math: "\\intlarhk" }, "⨘": { math: "\\intx" }, "⨙": { math: "\\intcap" }, "⨚": { math: "\\intcup" }, "⨛": { math: "\\upint" }, "⨜": { math: "\\lowint" }, "⨝": { math: "\\Join" }, "⨞": { math: "\\bigtriangleleft" }, "⨟": { math: "\\zcmp" }, "⨠": { math: "\\zpipe" }, "⨡": { math: "\\zproject" }, "⨢": { math: "\\ringplus" }, "⨣": { math: "\\plushat" }, "⨤": { math: "\\simplus" }, "⨥": { math: "\\plusdot" }, "⨦": { math: "\\plussim" }, "⨧": { math: "\\plussubtwo" }, "⨨": { math: "\\plustrif" }, "⨩": { math: "\\commaminus" }, "⨪": { math: "\\minusdot" }, "⨫": { math: "\\minusfdots" }, "⨬": { math: "\\minusrdots" }, "⨭": { math: "\\opluslhrim" }, "⨮": { math: "\\oplusrhrim" }, "⨯": { math: "\\vectimes" }, "⨰": { math: "\\dottimes" }, "⨱": { math: "\\timesbar" }, "⨲": { math: "\\btimes" }, "⨳": { math: "\\smashtimes" }, "⨴": { math: "\\otimeslhrim" }, "⨵": { math: "\\otimesrhrim" }, "⨶": { math: "\\otimeshat" }, "⨷": { math: "\\Otimes" }, "⨸": { math: "\\odiv" }, "⨹": { math: "\\triangleplus" }, "⨺": { math: "\\triangleminus" }, "⨻": { math: "\\triangletimes" }, "⨼": { math: "\\intprod" }, "⨽": { math: "\\intprodr" }, "⨾": { math: "\\fcmp" }, "⩀": { math: "\\capdot" }, "⩁": { math: "\\uminus" }, "⩂": { math: "\\barcup" }, "⩃": { math: "\\barcap" }, "⩄": { math: "\\capwedge" }, "⩅": { math: "\\cupvee" }, "⩆": { math: "\\cupovercap" }, "⩇": { math: "\\capovercup" }, "⩈": { math: "\\cupbarcap" }, "⩉": { math: "\\capbarcup" }, "⩊": { math: "\\twocups" }, "⩋": { math: "\\twocaps" }, "⩌": { math: "\\closedvarcup" }, "⩍": { math: "\\closedvarcap" }, "⩎": { math: "\\Sqcap" }, "⩏": { math: "\\Sqcup" }, "⩐": { math: "\\closedvarcupsmashprod" }, "⩑": { math: "\\wedgeodot" }, "⩒": { math: "\\veeodot" }, "⩓": { math: "\\Wedge" }, "⩔": { math: "\\Vee" }, "⩕": { math: "\\wedgeonwedge" }, "⩗": { math: "\\bigslopedvee" }, "⩘": { math: "\\bigslopedwedge" }, "⩙": { math: "\\veeonwedge" }, "⩚": { math: "\\wedgemidvert" }, "⩛": { math: "\\veemidvert" }, "⩜": { math: "\\midbarwedge" }, "⩝": { math: "\\midbarvee" }, "⩟": { math: "\\wedgebar" }, "⩠": { math: "\\wedgedoublebar" }, "⩡": { math: "\\varveebar" }, "⩢": { math: "\\doublebarvee" }, "⩣": { math: "\\veedoublebar" }, "⩤": { math: "\\dsub" }, "⩥": { math: "\\rsub" }, "⩦": { math: "\\eqdot" }, "⩧": { math: "\\dotequiv" }, "⩨": { math: "\\equivVert" }, "⩩": { math: "\\equivVvert" }, "⩪": { math: "\\dotsim" }, "⩫": { math: "\\simrdots" }, "⩬": { math: "\\simminussim" }, "⩭": { math: "\\congdot" }, "⩯": { math: "\\hatapprox" }, "⩰": { math: "\\approxeqq" }, "⩱": { math: "\\eqqplus" }, "⩲": { math: "\\pluseqq" }, "⩳": { math: "\\eqqsim" }, "⩴": { math: "\\Coloneqq" }, "⩷": { math: "\\ddotseq" }, "⩸": { math: "\\equivDD" }, "⩹": { math: "\\ltcir" }, "⩺": { math: "\\gtcir" }, "⩻": { math: "\\ltquest" }, "⩼": { math: "\\gtquest" }, "⩽": { math: "\\leqslant" }, "⩾": { math: "\\geqslant" }, "⩿": { math: "\\lesdot" }, "⪀": { math: "\\gesdot" }, "⪁": { math: "\\lesdoto" }, "⪂": { math: "\\gesdoto" }, "⪃": { math: "\\lesdotor" }, "⪄": { math: "\\gesdotol" }, "⪅": { math: "\\lessapprox" }, "⪆": { math: "\\gtrapprox" }, "⪇": { math: "\\lneq" }, "⪈": { math: "\\gneq" }, "⪉": { math: "\\lnapprox" }, "⪊": { math: "\\gnapprox" }, "⪋": { math: "\\lesseqqgtr" }, "⪌": { math: "\\gtreqqless" }, "⪍": { math: "\\lsime" }, "⪎": { math: "\\gsime" }, "⪏": { math: "\\lsimg" }, "⪐": { math: "\\gsiml" }, "⪑": { math: "\\lgE" }, "⪒": { math: "\\glE" }, "⪓": { math: "\\lesges" }, "⪔": { math: "\\gesles" }, "⪕": { math: "\\eqslantless" }, "⪖": { math: "\\eqslantgtr" }, "⪗": { math: "\\elsdot" }, "⪘": { math: "\\egsdot" }, "⪙": { math: "\\eqqless" }, "⪚": { math: "\\eqqgtr" }, "⪛": { math: "\\eqqslantless" }, "⪜": { math: "\\eqqslantgtr" }, "⪝": { math: "\\simless" }, "⪞": { math: "\\simgtr" }, "⪟": { math: "\\simlE" }, "⪠": { math: "\\simgE" }, "⪣": { math: "\\partialmeetcontraction" }, "⪤": { math: "\\glj" }, "⪥": { math: "\\gla" }, "⪨": { math: "\\lescc" }, "⪩": { math: "\\gescc" }, "⪪": { math: "\\smt" }, "⪫": { math: "\\lat" }, "⪬": { math: "\\smte" }, "⪭": { math: "\\late" }, "⪮": { math: "\\bumpeqq" }, "⪱": { math: "\\precneq" }, "⪲": { math: "\\succneq" }, "⪳": { math: "\\preceqq" }, "⪴": { math: "\\succeqq" }, "⪵": { math: "\\precneqq" }, "⪶": { math: "\\succneqq" }, "⪷": { math: "\\precapprox" }, "⪸": { math: "\\succapprox" }, "⪹": { math: "\\precnapprox" }, "⪺": { math: "\\succnapprox" }, "⪽": { math: "\\subsetdot" }, "⪾": { math: "\\supsetdot" }, "⪿": { math: "\\subsetplus" }, "⫀": { math: "\\supsetplus" }, "⫁": { math: "\\submult" }, "⫂": { math: "\\supmult" }, "⫃": { math: "\\subedot" }, "⫄": { math: "\\supedot" }, "⫅": { math: "\\subseteqq" }, "⫆": { math: "\\supseteqq" }, "⫇": { math: "\\subsim" }, "⫈": { math: "\\supsim" }, "⫉": { math: "\\subsetapprox" }, "⫊": { math: "\\supsetapprox" }, "⫋": { math: "\\subsetneqq" }, "⫌": { math: "\\supsetneqq" }, "⫍": { math: "\\lsqhook" }, "⫎": { math: "\\rsqhook" }, "⫏": { math: "\\csub" }, "⫐": { math: "\\csup" }, "⫑": { math: "\\csube" }, "⫒": { math: "\\csupe" }, "⫓": { math: "\\subsup" }, "⫔": { math: "\\supsub" }, "⫕": { math: "\\subsub" }, "⫖": { math: "\\supsup" }, "⫗": { math: "\\suphsub" }, "⫘": { math: "\\supdsub" }, "⫙": { math: "\\forkv" }, "⫚": { math: "\\topfork" }, "⫛": { math: "\\mlcp" }, "⫝̸": { math: "\\forks" }, "⫝": { math: "\\forksnot" }, "⫞": { math: "\\shortlefttack" }, "⫟": { math: "\\shortdowntack" }, "⫠": { math: "\\shortuptack" }, "⫡": { math: "\\perps" }, "⫢": { math: "\\vDdash" }, "⫣": { math: "\\dashV" }, "⫤": { math: "\\Dashv" }, "⫥": { math: "\\DashV" }, "⫦": { math: "\\varVdash" }, "⫧": { math: "\\Barv" }, "⫨": { math: "\\vBar" }, "⫩": { math: "\\vBarv" }, "⫫": { math: "\\Vbar" }, "⫬": { math: "\\Not" }, "⫭": { math: "\\bNot" }, "⫮": { math: "\\revnmid" }, "⫯": { math: "\\cirmid" }, "⫰": { math: "\\midcir" }, "⫱": { math: "\\topcir" }, "⫲": { math: "\\nhpar" }, "⫳": { math: "\\parsim" }, "⫴": { math: "\\interleave" }, "⫵": { math: "\\nhVvert" }, "⫶": { math: "\\threedotcolon" }, "⫷": { math: "\\lllnest" }, "⫸": { math: "\\gggnest" }, "⫹": { math: "\\leqqslant" }, "⫺": { math: "\\geqqslant" }, "⫻": { math: "\\trslash" }, "⫼": { math: "\\biginterleave" }, "⫾": { math: "\\talloblong" }, "⫿": { math: "\\bigtalloblong" }, "⬒": { math: "\\squaretopblack" }, "⬓": { math: "\\squarebotblack" }, "⬔": { math: "\\squareurblack" }, "⬕": { math: "\\squarellblack" }, "⬖": { math: "\\diamondleftblack" }, "⬗": { math: "\\diamondrightblack" }, "⬘": { math: "\\diamondtopblack" }, "⬙": { math: "\\diamondbotblack" }, "⬚": { math: "\\dottedsquare" }, "⬛": { math: "\\lgblksquare" }, "⬜": { math: "\\lgwhtsquare" }, "⬝": { math: "\\vysmblksquare" }, "⬞": { math: "\\vysmwhtsquare" }, "⬟": { math: "\\pentagonblack" }, "⬠": { math: "\\pentagon" }, "⬡": { math: "\\varhexagon" }, "⬢": { math: "\\varhexagonblack" }, "⬣": { math: "\\hexagonblack" }, "⬤": { math: "\\lgblkcircle" }, "⬥": { math: "\\mdblkdiamond" }, "⬦": { math: "\\mdwhtdiamond" }, "⬧": { math: "\\mdblklozenge" }, "⬨": { math: "\\mdwhtlozenge" }, "⬩": { math: "\\smblkdiamond" }, "⬪": { math: "\\smblklozenge" }, "⬫": { math: "\\smwhtlozenge" }, "⬬": { math: "\\blkhorzoval" }, "⬭": { math: "\\whthorzoval" }, "⬮": { math: "\\blkvertoval" }, "⬯": { math: "\\whtvertoval" }, "⬰": { math: "\\circleonleftarrow" }, "⬱": { math: "\\leftthreearrows" }, "⬲": { math: "\\leftarrowonoplus" }, "⬳": { math: "\\longleftsquigarrow" }, "⬴": { math: "\\nvtwoheadleftarrow" }, "⬵": { math: "\\nVtwoheadleftarrow" }, "⬶": { math: "\\twoheadmapsfrom" }, "⬷": { math: "\\twoheadleftdbkarrow" }, "⬸": { math: "\\leftdotarrow" }, "⬹": { math: "\\nvleftarrowtail" }, "⬺": { math: "\\nVleftarrowtail" }, "⬻": { math: "\\twoheadleftarrowtail" }, "⬼": { math: "\\nvtwoheadleftarrowtail" }, "⬽": { math: "\\nVtwoheadleftarrowtail" }, "⬾": { math: "\\leftarrowx" }, "⬿": { math: "\\leftcurvedarrow" }, "⭀": { math: "\\equalleftarrow" }, "⭁": { math: "\\bsimilarleftarrow" }, "⭂": { math: "\\leftarrowbackapprox" }, "⭃": { math: "\\rightarrowgtr" }, "⭄": { math: "\\rightarrowsupset" }, "⭅": { math: "\\LLeftarrow" }, "⭆": { math: "\\RRightarrow" }, "⭇": { math: "\\bsimilarrightarrow" }, "⭈": { math: "\\rightarrowbackapprox" }, "⭉": { math: "\\similarleftarrow" }, "⭊": { math: "\\leftarrowapprox" }, "⭋": { math: "\\leftarrowbsimilar" }, "⭌": { math: "\\rightarrowbsimilar" }, "⭐": { math: "\\medwhitestar" }, "⭑": { math: "\\medblackstar" }, "⭒": { math: "\\smwhitestar" }, "⭓": { math: "\\rightpentagonblack" }, "⭔": { math: "\\rightpentagon" }, "〒": { math: "\\postalmark" }, "〰": { math: "\\hzigzag" } }, amssymb: { ð: { math: "\\eth" }, "⩽": { math: "\\leqslant" }, "⩽̸": { math: "\\nleqslant" }, "⩾": { math: "\\geqslant" }, "⩾̸": { math: "\\ngeqslant" } }, arevmath: { ð: { math: "\\eth" } }, MinionPro: { ϐ: { math: "\\varbeta" }, ϰ: { math: "\\varkappa" } }, mathrsfs: { ℊ: { math: "\\mathscr{g}" }, ℋ: { math: "\\mathscr{H}" }, ℐ: { math: "\\mathscr{I}" }, ℒ: { math: "\\mathscr{L}" }, ℛ: { math: "\\mathscr{R}" }, ℬ: { math: "\\mathscr{B}" }, ℯ: { math: "\\mathscr{e}" }, ℰ: { math: "\\mathscr{E}" }, ℱ: { math: "\\mathscr{F}" }, ℳ: { math: "\\mathscr{M}" }, ℴ: { math: "\\mathscr{o}" }, "𝒜": { math: "\\mathscr{A}" }, "𝒞": { math: "\\mathscr{C}" }, "𝒟": { math: "\\mathscr{D}" }, "𝒢": { math: "\\mathscr{G}" }, "𝒥": { math: "\\mathscr{J}" }, "𝒦": { math: "\\mathscr{K}" }, "𝒩": { math: "\\mathscr{N}" }, "𝒪": { math: "\\mathscr{O}" }, "𝒫": { math: "\\mathscr{P}" }, "𝒬": { math: "\\mathscr{Q}" }, "𝒮": { math: "\\mathscr{S}" }, "𝒯": { math: "\\mathscr{T}" }, "𝒰": { math: "\\mathscr{U}" }, "𝒱": { math: "\\mathscr{V}" }, "𝒲": { math: "\\mathscr{W}" }, "𝒳": { math: "\\mathscr{X}" }, "𝒴": { math: "\\mathscr{Y}" }, "𝒵": { math: "\\mathscr{Z}" }, "𝒶": { math: "\\mathscr{a}" }, "𝒷": { math: "\\mathscr{b}" }, "𝒸": { math: "\\mathscr{c}" }, "𝒹": { math: "\\mathscr{d}" }, "𝒻": { math: "\\mathscr{f}" }, "𝒽": { math: "\\mathscr{h}" }, "𝒾": { math: "\\mathscr{i}" }, "𝒿": { math: "\\mathscr{j}" }, "𝓀": { math: "\\mathscr{k}" }, "𝓁": { math: "\\mathscr{l}" }, "𝓂": { math: "\\mathscr{m}" }, "𝓃": { math: "\\mathscr{n}" }, "𝓅": { math: "\\mathscr{p}" }, "𝓆": { math: "\\mathscr{q}" }, "𝓇": { math: "\\mathscr{r}" }, "𝓈": { math: "\\mathscr{s}" }, "𝓉": { math: "\\mathscr{t}" }, "𝓊": { math: "\\mathscr{u}" }, "𝓋": { math: "\\mathscr{v}" }, "𝓌": { math: "\\mathscr{w}" }, "𝓍": { math: "\\mathscr{x}" }, "𝓎": { math: "\\mathscr{y}" }, "𝓏": { math: "\\mathscr{z}" } }, MnSymbol: { "∲": { math: "\\lcirclerightint" }, "∳": { math: "\\rcirclerightint" } }, mathabx: { "∸": { math: "\\dotdiv" } }, xecjk: { "≂": { math: "\\texteqsim" }, א: { text: "{\\hebalef}" }, ע: { text: "{\\hebayin}" }, ב: { text: "{\\hebbet}" }, ד: { text: "{\\hebdalet}" }, ך: { text: "{\\hebfinalkaf}" }, ם: { text: "{\\hebfinalmem}" }, ן: { text: "{\\hebfinalnun}" }, ף: { text: "{\\hebfinalpe}" }, ץ: { text: "{\\hebfinaltsadi}" }, ג: { text: "{\\hebgimel}" }, ה: { text: "{\\hebhe}" }, ח: { text: "{\\hebhet}" }, כ: { text: "{\\hebkaf}" }, ל: { text: "{\\heblamed}" }, מ: { text: "{\\hebmem}" }, נ: { text: "{\\hebnun}" }, פ: { text: "{\\hebpe}" }, ק: { text: "{\\hebqof}" }, ר: { text: "{\\hebresh}" }, ס: { text: "{\\hebsamekh}" }, ש: { text: "{\\hebshin}" }, ת: { text: "{\\hebtav}" }, ט: { text: "{\\hebtet}" }, צ: { text: "{\\hebtsadi}" }, ו: { text: "{\\hebvav}" }, י: { text: "{\\hebyod}" }, ז: { text: "{\\hebzayin}" }, ĸ: { text: "{\\textkra}" } }, textcomp: { "¢": { text: "{\\textcent}" }, "¤": { text: "{\\textcurrency}" }, "¥": { text: "{\\textyen}" }, "฿": { text: "{\\textbaht}" }, "₡": { text: "{\\textcolonmonetary}" }, "₤": { text: "{\\textlira}" }, "₦": { text: "{\\textnaira}" }, "₧": { text: "{\\textpeseta}" }, "₩": { text: "{\\textwon}" }, "₫": { text: "{\\textdong}" }, "₱": { text: "{\\textpeso}" }, "¦": { text: "{\\textbrokenbar}" }, "©": { text: "{\\textcopyright}" }, ª: { text: "{\\textordfeminine}" }, "°": { text: "{\\textdegree}" }, "¶": { text: "{\\textparagraph}" }, º: { text: "{\\textordmasculine}" }, ð: { text: "{\\textdh}" }, "˙": { text: "{\\textperiodcentered}" }, "•": { text: "{\\textbullet}" }, "‰": { text: "{\\textperthousand}" }, "‱": { text: "{\\textpertenthousand}" }, "℞": { text: "{\\textrecipe}" }, "™": { text: "{\\texttrademark}" }, "↑": { text: "{\\textuparrow}" }, "→": { text: "{\\textrightarrow}" } }, inputenx: { Ħ: { text: "{\\textmalteseH}" }, ɸ: { text: "{\\textphi}" }, "≈": { text: "{\\textapproxequal}" } }, tipa: { ħ: { text: "{\\textcrh}" }, ƕ: { text: "{\\texthvlig}" }, ƞ: { text: "\\textipa{\\textnrleg}" }, ǂ: { text: "{\\textdoublebarpipe}" }, ɐ: { text: "\\textipa{\\textturna}" }, ɒ: { text: "textipa{\\textopeno}" }, ɔ: { text: "\\textipa{O}" }, ɖ: { text: "{\\textrtaild}" }, ə: { text: "{\\textschwa}" }, ɣ: { text: "\\textipa{G}" }, ɤ: { text: "{\\textrevscripta}" }, ɸ: { text: "{\\textphi}" }, ʞ: { text: "{\\textturnk}" }, "˥": { text: "\\tone{55}" }, "˦": { text: "\\tone{44}" }, "˧": { text: "\\tone{33}" }, "˨": { text: "\\tone{22}" }, "˩": { text: "\\tone{11}" }, "̀̄": { text: "{\\textgravemacron}" }, "̀̇": { text: "{\\textgravedot}" }, "́̄": { text: "{\\textacutemacron}" }, "́̌": { text: "{\\textacutewedge}" }, "̂̇": { text: "{\\textcircumdot}" }, "̃̇": { text: "{\\texttildedot}" }, "̄̀": { text: "{\\textgravemacron}" }, "̆̄": { text: "{\\textbrevemacron}" }, "̇́": { text: "{\\textdotacute}" }, "̇̆": { text: "{\\textdotbreve}" }, "̊̄": { text: "{\\textringmacron}" }, "̍": { text: "{\\textvbaraccent}" }, "̎": { text: "{\\textdoublevbaraccent}" }, "̐": { text: "{\\textdotbreve}" }, "̘": { text: "{\\textadvancing}" }, "̙": { text: "{\\textretracting}" }, "̚": { text: "{\\textcorner}" }, "̜": { text: "{\\textsublhalfring}" }, "̝": { text: "{\\textraising}" }, "̞": { text: "{\\textlowering}" }, "̟": { text: "{\\textsubplus}" }, "̤": { text: "{\\textsubumlaut}" }, "̥": { text: "{\\textsubring}" }, "̩": { text: "{\\textsyllabic}" }, "̪": { text: "{\\textsubbridge}" }, "̬": { text: "{\\textsubwedge}" }, "̯": { text: "{\\textsubarch}" }, "̰": { text: "{\\textsubtilde}" }, "̱": { text: "{\\textsubbar}" }, "̴": { text: "{\\textsuperimposetilde}" }, "̹": { text: "{\\textsubrhalfring}" }, "̺": { text: "{\\textinvsubbridge}" }, "̻": { text: "{\\textsubsquare}" }, "̼": { text: "{\\textseagull}" }, "̽": { text: "{\\textovercross}" }, "ₔ": { text: "\\textsubscript{\\textschwa}" } }, ipa: { ɯ: { text: "{\\textturnm}" } }, mathscinet: { ʿ: { text: "{\\lasp}" } }, textalpha: { α: { text: "{\\textalpha}" } }, graphics: { "↳": { text: "\\reflectbox{\\carriagereturn}" } }, pmboxdraw: { "─": { text: "{\\textSFx}" }, "━": { text: "\\pmboxdrawuni{2501}" }, "│": { text: "{\\textSFxi}" }, "┃": { text: "\\pmboxdrawuni{2503}" }, "┌": { text: "{\\textSFi}" }, "┍": { text: "\\pmboxdrawuni{250D}" }, "┎": { text: "\\pmboxdrawuni{250E}" }, "┏": { text: "\\pmboxdrawuni{250F}" }, "┐": { text: "{\\textSFiii}" }, "┑": { text: "\\pmboxdrawuni{2511}" }, "┒": { text: "\\pmboxdrawuni{2512}" }, "┓": { text: "\\pmboxdrawuni{2513}" }, "└": { text: "{\\textSFii}" }, "┕": { text: "\\pmboxdrawuni{2515}" }, "┖": { text: "\\pmboxdrawuni{2516}" }, "┗": { text: "\\pmboxdrawuni{2517}" }, "┘": { text: "{\\textSFiv}" }, "┙": { text: "\\pmboxdrawuni{2519}" }, "┚": { text: "\\pmboxdrawuni{251A}" }, "┛": { text: "\\pmboxdrawuni{251B}" }, "├": { text: "{\\textSFviii}" }, "┝": { text: "\\pmboxdrawuni{251D}" }, "┞": { text: "\\pmboxdrawuni{251E}" }, "┟": { text: "\\pmboxdrawuni{251F}" }, "┠": { text: "\\pmboxdrawuni{2520}" }, "┡": { text: "\\pmboxdrawuni{2521}" }, "┢": { text: "\\pmboxdrawuni{2522}" }, "┣": { text: "\\pmboxdrawuni{2523}" }, "┤": { text: "{\\textSFix}" }, "┥": { text: "\\pmboxdrawuni{2525}" }, "┦": { text: "\\pmboxdrawuni{2526}" }, "┧": { text: "\\pmboxdrawuni{2527}" }, "┨": { text: "\\pmboxdrawuni{2528}" }, "┩": { text: "\\pmboxdrawuni{2529}" }, "┪": { text: "\\pmboxdrawuni{252A}" }, "┫": { text: "\\pmboxdrawuni{252B}" }, "┬": { text: "{\\textSFvi}" }, "┭": { text: "\\pmboxdrawuni{252D}" }, "┮": { text: "\\pmboxdrawuni{252E}" }, "┯": { text: "\\pmboxdrawuni{252F}" }, "┰": { text: "\\pmboxdrawuni{2530}" }, "┱": { text: "\\pmboxdrawuni{2531}" }, "┲": { text: "\\pmboxdrawuni{2532}" }, "┳": { text: "\\pmboxdrawuni{2533}" }, "┴": { text: "{\\textSFvii}" }, "┵": { text: "\\pmboxdrawuni{2535}" }, "┶": { text: "\\pmboxdrawuni{2536}" }, "┷": { text: "\\pmboxdrawuni{2537}" }, "┸": { text: "\\pmboxdrawuni{2538}" }, "┹": { text: "\\pmboxdrawuni{2539}" }, "┺": { text: "\\pmboxdrawuni{253A}" }, "┻": { text: "\\pmboxdrawuni{253B}" }, "┼": { text: "{\\textSFv}" }, "┽": { text: "\\pmboxdrawuni{253D}" }, "┾": { text: "\\pmboxdrawuni{253E}" }, "┿": { text: "\\pmboxdrawuni{253F}" }, "╀": { text: "\\pmboxdrawuni{2540}" }, "╁": { text: "\\pmboxdrawuni{2541}" }, "╂": { text: "\\pmboxdrawuni{2542}" }, "╃": { text: "\\pmboxdrawuni{2543}" }, "╄": { text: "\\pmboxdrawuni{2544}" }, "╅": { text: "\\pmboxdrawuni{2545}" }, "╆": { text: "\\pmboxdrawuni{2546}" }, "╇": { text: "\\pmboxdrawuni{2547}" }, "╈": { text: "\\pmboxdrawuni{2548}" }, "╉": { text: "\\pmboxdrawuni{2549}" }, "╊": { text: "\\pmboxdrawuni{254A}" }, "╋": { text: "\\pmboxdrawuni{254B}" }, "═": { text: "{\\textSFxliii}" }, "║": { text: "{\\textSFxxiv}" }, "╒": { text: "{\\textSFli}" }, "╓": { text: "{\\textSFlii}" }, "╔": { text: "{\\textSFxxxix}" }, "╕": { text: "{\\textSFxxii}" }, "╖": { text: "{\\textSFxxi}" }, "╗": { text: "{\\textSFxxv}" }, "╘": { text: "{\\textSFl}" }, "╙": { text: "{\\textSFxlix}" }, "╚": { text: "{\\textSFxxxviii}" }, "╛": { text: "{\\textSFxxviii}" }, "╜": { text: "{\\textSFxxvii}" }, "╝": { text: "{\\textSFxxvi}" }, "╞": { text: "{\\textSFxxxvi}" }, "╟": { text: "{\\textSFxxxvii}" }, "╠": { text: "{\\textSFxlii}" }, "╡": { text: "{\\textSFxix}" }, "╢": { text: "{\\textSFxx}" }, "╣": { text: "{\\textSFxxiii}" }, "╤": { text: "{\\textSFxlvii}" }, "╥": { text: "{\\textSFxlviii}" }, "╦": { text: "{\\textSFxli}" }, "╧": { text: "{\\textSFxlv}" }, "╨": { text: "{\\textSFxlvi}" }, "╩": { text: "{\\textSFxl}" }, "╪": { text: "{\\textSFliv}" }, "╫": { text: "{\\textSFliii}" }, "╬": { text: "{\\textSFxliv}" }, "╴": { text: "\\pmboxdrawuni{2574}" }, "╵": { text: "\\pmboxdrawuni{2575}" }, "╶": { text: "\\pmboxdrawuni{2576}" }, "╷": { text: "\\pmboxdrawuni{2577}" }, "╸": { text: "\\pmboxdrawuni{2578}" }, "╹": { text: "\\pmboxdrawuni{2579}" }, "╺": { text: "\\pmboxdrawuni{257A}" }, "╻": { text: "\\pmboxdrawuni{257B}" }, "╼": { text: "\\pmboxdrawuni{257C}" }, "╽": { text: "\\pmboxdrawuni{257D}" }, "╾": { text: "\\pmboxdrawuni{257E}" }, "╿": { text: "\\pmboxdrawuni{257F}" }, "▀": { text: "{\\textupblock}" }, "▁": { text: "\\pmboxdrawuni{2581}" }, "▂": { text: "\\pmboxdrawuni{2582}" }, "▃": { text: "\\pmboxdrawuni{2583}" }, "▄": { text: "{\\textdnblock}" }, "▅": { text: "\\pmboxdrawuni{2585}" }, "▆": { text: "\\pmboxdrawuni{2586}" }, "▇": { text: "\\pmboxdrawuni{2587}" }, "█": { text: "{\\textblock}" }, "▉": { text: "\\pmboxdrawuni{2589}" }, "▊": { text: "\\pmboxdrawuni{258A}" }, "▋": { text: "\\pmboxdrawuni{258B}" }, "▌": { text: "{\\textlfblock}" }, "▍": { text: "\\pmboxdrawuni{258D}" }, "▎": { text: "\\pmboxdrawuni{258E}" }, "▏": { text: "\\pmboxdrawuni{258F}" }, "▐": { text: "{\\textrtblock}" }, "░": { text: "{\\textltshade}" }, "▒": { text: "{\\textshade}" }, "▓": { text: "{\\textdkshade}" }, "▔": { text: "\\pmboxdrawuni{2594}" }, "▕": { text: "\\pmboxdrawuni{2595}" }, "▖": { text: "\\pmboxdrawuni{2596}" }, "▗": { text: "\\pmboxdrawuni{2597}" }, "▘": { text: "\\pmboxdrawuni{2598}" }, "▙": { text: "\\pmboxdrawuni{2599}" }, "▚": { text: "\\pmboxdrawuni{259A}" }, "▛": { text: "\\pmboxdrawuni{259B}" }, "▜": { text: "\\pmboxdrawuni{259C}" }, "▝": { text: "\\pmboxdrawuni{259D}" }, "▞": { text: "\\pmboxdrawuni{259E}" }, "▟": { text: "\\pmboxdrawuni{259F}" } } } };
  }
});

// node_modules/unicode2latex/tables/minimal.json
var require_minimal = __commonJS({
  "node_modules/unicode2latex/tables/minimal.json"(exports, module) {
    module.exports = { base: { "#": { text: "\\#", math: "\\#" }, $: { text: "\\$", math: "\\$" }, "%": { text: "\\%", math: "\\%" }, "&": { text: "\\&", math: "\\&" }, _: { text: "\\_", math: "\\_" }, " ": { text: "~", math: "~" }, " ": { text: "\\:", math: "\\:" }, "<": { math: "<" }, ">": { math: ">" }, "\\": { text: "\\textbackslash", math: "\\backslash", macrospacer: true }, " ": { math: "\\quad" }, " ": { math: "\\mkern1mu" }, "^": { text: "\\textasciicircum", macrospacer: true }, "{": { text: "\\{" }, "}": { text: "\\}" }, "~": { text: "\\textasciitilde", macrospacer: true }, " ": { text: "\\enspace", macrospacer: true }, " ": { text: "\\;" }, " ": { text: "\\>" }, " ": { text: "\\hspace{0.166em}" }, " ": { text: "\\hphantom{0}" }, " ": { text: "\\hphantom{,}" }, " ": { text: "\\," }, "​": { text: "\\hspace{0pt}" }, " ": { text: "\\," } }, package: {} };
  }
});

// node_modules/unicode2latex/tables/latex2unicode.json
var require_latex2unicode = __commonJS({
  "node_modules/unicode2latex/tables/latex2unicode.json"(exports, module) {
    module.exports = { "''": { text: "”", math: "''" }, "--": { text: "–", math: "--" }, "---": { text: "—", math: "---" }, "<": { text: "¡", math: "<" }, "<<": { text: "«", math: "<<" }, "<\\kern-0.58em(": "⦓", ">": { text: "¿", math: ">" }, ">>": { text: "»", math: ">>" }, "\\": "\\", '\\"': "̈", '\\"{\\i}': "ï", "\\#": "#", "\\$": "$", "\\%": "%", "\\&": "&", "\\'": "́", "\\'\\i": "í", "\\,": " ", "\\-": "­", "\\.": "̇", "\\/": "", "\\:": " ", "\\;": " ", "\\=": "̄", "\\>": " ", "\\@": "", "\\AA": "Å", "\\AC": "∿", "\\AE": "Æ", "\\APLboxquestion": "⍰", "\\APLboxupcaret": "⍓", "\\APLcomment": "⍝", "\\APLdownarrowbox": "⍗", "\\APLinput": "⍞", "\\APLinv": "⌹", "\\APLleftarrowbox": "⍇", "\\APLlog": "⍟", "\\APLnotbackslash": "⍀", "\\APLnotslash": "⌿", "\\APLrightarrowbox": "⍈", "\\APLuparrowbox": "⍐", "\\Angle": "⦜", "\\Angstroem": "Å", "\\Angstrom": "Å", "\\Barv": "⫧", "\\BbbA": "𝔸", "\\BbbB": "𝔹", "\\BbbC": "ℂ", "\\BbbD": "𝔻", "\\BbbE": "𝔼", "\\BbbF": "𝔽", "\\BbbG": "𝔾", "\\BbbGamma": "ℾ", "\\BbbH": "ℍ", "\\BbbI": "𝕀", "\\BbbJ": "𝕁", "\\BbbK": "𝕂", "\\BbbL": "𝕃", "\\BbbM": "𝕄", "\\BbbN": "ℕ", "\\BbbO": "𝕆", "\\BbbP": "ℙ", "\\BbbPi": "ℿ", "\\BbbQ": "ℚ", "\\BbbR": "ℝ", "\\BbbS": "𝕊", "\\BbbT": "𝕋", "\\BbbU": "𝕌", "\\BbbV": "𝕍", "\\BbbW": "𝕎", "\\BbbX": "𝕏", "\\BbbY": "𝕐", "\\BbbZ": "ℤ", "\\Bbba": "𝕒", "\\Bbbb": "𝕓", "\\Bbbc": "𝕔", "\\Bbbd": "𝕕", "\\Bbbe": "𝕖", "\\Bbbeight": "𝟠", "\\Bbbf": "𝕗", "\\Bbbfive": "𝟝", "\\Bbbfour": "𝟜", "\\Bbbg": "𝕘", "\\Bbbgamma": "ℽ", "\\Bbbh": "𝕙", "\\Bbbi": "𝕚", "\\Bbbj": "𝕛", "\\Bbbk": "𝕜", "\\Bbbl": "𝕝", "\\Bbbm": "𝕞", "\\Bbbn": "𝕟", "\\Bbbnine": "𝟡", "\\Bbbo": "𝕠", "\\Bbbone": "𝟙", "\\Bbbp": "𝕡", "\\Bbbpi": "ℼ", "\\Bbbq": "𝕢", "\\Bbbr": "𝕣", "\\Bbbs": "𝕤", "\\Bbbseven": "𝟟", "\\Bbbsix": "𝟞", "\\Bbbsum": "⅀", "\\Bbbt": "𝕥", "\\Bbbthree": "𝟛", "\\Bbbtwo": "𝟚", "\\Bbbu": "𝕦", "\\Bbbv": "𝕧", "\\Bbbw": "𝕨", "\\Bbbx": "𝕩", "\\Bbby": "𝕪", "\\Bbbz": "𝕫", "\\Bbbzero": "𝟘", "\\Box": "□", "\\Bumpeq": "≎", "\\CIRCLE": "●", "\\Cap": "⋒", "\\CapitalDifferentialD": "ⅅ", "\\CheckedBox": "☑", "\\Colon": "∷", "\\Coloneq": "⩴", "\\Coloneqq": "⩴", "\\ComplexI": "ⅈ", "\\ComplexJ": "ⅉ", "\\Cup": "⋓", "\\DDownarrow": "⟱", "\\DH": "Ð", "\\DJ": "Đ", "\\DashV": "⫥", "\\DashVDash": "⟚", "\\Dashv": "⫤", "\\Ddownarrow": "⤋", "\\Delta": "Δ", "\\Diamond": "◇", "\\Diamondblack": "◆", "\\Diamonddot": "⟐", "\\DifferentialD": "ⅆ", "\\Digamma": "Ϝ", "\\Doteq": "≑", "\\DownArrowBar": "⤓", "\\DownArrowUpArrow": "⇵", "\\DownLeftRightVector": "⥐", "\\DownLeftTeeVector": "⥞", "\\DownLeftVectorBar": "⥖", "\\DownRightTeeVector": "⥟", "\\DownRightVectorBar": "⥗", "\\Downarrow": "⇓", "\\ElOr": "⩖", "\\Elolarr": "⥀", "\\Elorarr": "⥁", "\\Elroang": "⦆", "\\Elxsqcup": "⨆", "\\Elxuplus": "⨄", "\\Equal": "⩵", "\\Equiv": "≣", "\\Euler": "ℇ", "\\Eulerconst": "ℇ", "\\Exclam": "‼", "\\ExponetialE": "ⅇ", "\\Finv": "Ⅎ", "\\Game": "⅁", "\\Gamma": "Γ", "\\Gt": "⪢", "\\H": "̋", "\\Hermaphrodite": "⚥", "\\H{}": "˝", "\\IJ": "Ĳ", "\\Im": "ℑ", "\\Join": "⨝", "\\Koppa": "Ϟ", "\\L": "Ł", "\\LEFTCIRCLE": "◖", "\\LHD": "◀", "\\LLeftarrow": "⭅", "\\LVec": "⃖", "\\Lambda": "Λ", "\\Lbag": "⟅", "\\Lbrbrak": "⟬", "\\Ldsh": "↲", "\\LeftArrowBar": "⇤", "\\LeftDownTeeVector": "⥡", "\\LeftDownVectorBar": "⥙", "\\LeftRightVector": "⥎", "\\LeftTeeVector": "⥚", "\\LeftTriangleBar": "⧏", "\\LeftUpDownVector": "⥑", "\\LeftUpTeeVector": "⥠", "\\LeftUpVectorBar": "⥘", "\\LeftVectorBar": "⥒", "\\Leftarrow": "⇐", "\\Leftrightarrow": "⇔", "\\Lleftarrow": "⇚", "\\Longleftarrow": "⟸", "\\Longleftrightarrow": "⟺", "\\Longmapsfrom": "⟽", "\\Longmapsto": "⟾", "\\Longrightarrow": "⟹", "\\Lparengtr": "⦕", "\\Lsh": "↰", "\\Lt": "⪡", "\\Lvzigzag": "⧚", "\\MapsDown": "↧", "\\MapsUp": "↥", "\\Mapsfrom": "⤆", "\\Mapsto": "⤇", "\\NG": "Ŋ", "\\Nearrow": "⇗", "\\NestedGreaterGreater": "⪢", "\\NestedLessLess": "⪡", "\\Not": "⫬", "\\NotEqualTilde": "≂̸", "\\NotGreaterGreater": "≫̸", "\\NotHumpDownHump": "≎̸", "\\NotHumpEqual": "≏̸", "\\NotLeftTriangleBar": "⧏̸", "\\NotLessLess": "≪̸", "\\NotNestedGreaterGreater": "⪢̸", "\\NotNestedLessLess": "⪡̸", "\\NotPrecedesTilde": "≾̸", "\\NotRightTriangleBar": "⧐̸", "\\NotSquareSubset": "⊏̸", "\\NotSquareSuperset": "⊐̸", "\\NotSucceedsTilde": "≿̸", "\\Nwarrow": "⇖", "\\O": "Ø", "\\OE": "Œ", "\\Omega": "Ω", "\\Otimes": "⨷", "\\P": "¶", "\\Phi": "Φ", "\\Pi": "Π", "\\Pisymbol{ppi020}{105}": "⪞", "\\Pisymbol{ppi020}{117}": "⪝", "\\Pisymbol{ppi022}{87}": "ϐ", "\\Planckconst": "ℎ", "\\Prec": "⪻", "\\PropertyLine": "⅊", "\\Psi": "Ψ", "\\QED": "∎", "\\Qoppa": "Ϙ", "\\Question": "⁇", "\\RHD": "▶", "\\RIGHTCIRCLE": "◗", "\\RRightarrow": "⭆", "\\Rbag": "⟆", "\\Rbrbrak": "⟭", "\\Rdsh": "↳", "\\Re": "ℜ", "\\ReverseUpEquilibrium": "⥯", "\\RightArrowBar": "⇥", "\\RightDownTeeVector": "⥝", "\\RightDownVectorBar": "⥕", "\\RightTeeVector": "⥛", "\\RightTriangleBar": "⧐", "\\RightUpDownVector": "⥏", "\\RightUpTeeVector": "⥜", "\\RightUpVectorBar": "⥔", "\\RightVectorBar": "⥓", "\\Rightarrow": "⇒", "\\RoundImplies": "⥰", "\\Rparenless": "⦖", "\\Rrightarrow": "⇛", "\\Rsh": "↱", "\\RuleDelayed": "⧴", "\\Rvzigzag": "⧛", "\\S": "§", "\\Same": "⩶", "\\Sampi": "Ϡ", "\\Searrow": "⇘", "\\Sigma": "Σ", "\\Sqcap": "⩎", "\\Sqcup": "⩏", "\\Square": "☐", "\\Stigma": "Ϛ", "\\Subset": "⋐", "\\Succ": "⪼", "\\Sun": "☉", "\\Supset": "⋑", "\\Swarrow": "⇙", "\\TH": "Þ", "\\Theta": "Θ", "\\Top": "⫪", "\\UUparrow": "⟰", "\\UpArrowBar": "⤒", "\\UpEquilibrium": "⥮", "\\Uparrow": "⇑", "\\Updownarrow": "⇕", "\\Upsilon": "Υ", "\\Uuparrow": "⤊", "\\VDash": "⊫", "\\Vbar": "⫫", "\\Vdash": "⊩", "\\Vee": "⩔", "\\Vert": "‖", "\\Vvdash": "⊪", "\\Vvert": "⦀", "\\Wedge": "⩓", "\\XBox": "☒", "\\Xi": "Ξ", "\\Yup": "⅄", "\\\\backslash": "ࡱ", "\\^": "̂", "\\^\\j": "ĵ", "\\^{\\i}": "î", "\\_": "_", "\\`": "̀", "\\`\\i": "ì", "\\aa": "å", "\\accurrent": "⏦", "\\acidfree": "♾", "\\acute": "́", "\\acute{\\alpha}": "ά", "\\acute{\\ddot{\\iota}}": "ΐ", "\\acute{\\ddot{\\upsilon}}": "ΰ", "\\acute{\\epsilon}": "έ", "\\acute{\\eta}": "ή", "\\acute{\\iota}": "ί", "\\acute{\\omega}": "ώ", "\\acute{\\upsilon}": "ύ", "\\acwcirclearrow": "⥀", "\\acwgapcirclearrow": "⟲", "\\acwleftarcarrow": "⤹", "\\acwopencirclearrow": "↺", "\\acwoverarcarrow": "⤺", "\\acwunderarcarrow": "⤻", "\\adots": "⋰", "\\ae": "æ", "\\aleph": "ℵ", "\\allequal": "≌", "\\alpha": "α", "\\amalg": "⨿", "\\anchor": "⚓", "\\angdnr": "⦟", "\\angle": "∠", "\\angles": "⦞", "\\angleubar": "⦤", "\\annuity": "⃧", "\\approx": "≈", "\\approxeq": "≊", "\\approxeqq": "⩰", "\\approxident": "≋", "\\approxnotequal": "≆", "\\aquarius": "♒", "\\arabichad": "ữ1", "\\arabicmaj": "ữ0", "\\arceq": "≘", "\\aries": "♈", "\\arrowbullet": "➢", "\\arrowwaveleft": "↜", "\\arrowwaveright": "↝", "\\assert": "⊦", "\\ast": "∗", "\\asteq": "⩮", "\\asteraccent": "⃰", "\\astrosun": "☉", "\\asymp": "≍", "\\awint": "⨑", "\\bNot": "⫭", "\\backcong": "≌", "\\backdprime": "‶", "\\backepsilon": "϶", "\\backprime": "‵", "\\backsim": "∽", "\\backsimeq": "⋍", "\\backslash": "\\", "\\backtrprime": "‷", "\\bagmember": "⋿", "\\ballotx": "✗", "\\bar": "̅", "\\barV": "⫪", "\\barcap": "⩃", "\\barcup": "⩂", "\\bardownharpoonleft": "⥡", "\\bardownharpoonright": "⥝", "\\barin": "⋶", "\\barleftarrow": "⇤", "\\barleftarrowrightarrowbar": "↹", "\\barleftharpoon": "⥫", "\\barleftharpoondown": "⥖", "\\barleftharpoonup": "⥒", "\\barovernorthwestarrow": "↸", "\\barrightarrowdiamond": "⤠", "\\barrightharpoon": "⥭", "\\barrightharpoondown": "⥟", "\\barrightharpoonup": "⥛", "\\baruparrow": "⤒", "\\barupharpoonleft": "⥘", "\\barupharpoonright": "⥔", "\\barvee": "⊽", "\\barwedge": { text: "⌅", math: "⊼" }, "\\bbrktbrk": "⎶", "\\bdtriplevdash": "┆", "\\because": "∵", "\\benzenr": "⏣", "\\beta": "β", "\\beth": "ℶ", "\\between": "≬", "\\bigblacktriangledown": "▼", "\\bigblacktriangleup": "▲", "\\bigbot": "⟘", "\\bigcap": "⋂", "\\bigcirc": "◯", "\\bigcup": "⋃", "\\bigcupdot": "⨃", "\\biginterleave": "⫼", "\\bigodot": "⨀", "\\bigoplus": "⨁", "\\bigotimes": "⨂", "\\bigslopedvee": "⩗", "\\bigslopedwedge": "⩘", "\\bigsqcap": "⨅", "\\bigsqcup": "⨆", "\\bigstar": "★", "\\bigtalloblong": "⫿", "\\bigtimes": "⨉", "\\bigtop": "⟙", "\\bigtriangledown": "▽", "\\bigtriangleleft": "⨞", "\\bigtriangleup": "△", "\\biguplus": "⨄", "\\bigvee": "⋁", "\\bigwedge": "⋀", "\\bigwhitestar": "☆", "\\bij": "⤖", "\\biohazard": "☣", "\\blackcircledownarrow": "⧭", "\\blackcircledrightdot": "⚈", "\\blackcircledtwodots": "⚉", "\\blackcircleulquadwhite": "◕", "\\blackdiamonddownarrow": "⧪", "\\blackhourglass": "⧗", "\\blackinwhitediamond": "◈", "\\blackinwhitesquare": "▣", "\\blacklefthalfcircle": "◖", "\\blacklozenge": "⧫", "\\blackpointerleft": "◄", "\\blackpointerright": "►", "\\blackrighthalfcircle": "◗", "\\blacksmiley": "☻", "\\blacksquare": "⬛", "\\blacktriangle": "▴", "\\blacktriangledown": "▾", "\\blacktriangleleft": "◀", "\\blacktriangleright": "▶", "\\blanksymbol": "␢", "\\blkhorzoval": "⬬", "\\blkvertoval": "⬮", "\\blockfull": "█", "\\blockhalfshaded": "▒", "\\blocklefthalf": "▌", "\\blocklowhalf": "▄", "\\blockqtrshaded": "░", "\\blockrighthalf": "▐", "\\blockthreeqtrshaded": "▓", "\\blockuphalf": "▀", "\\bot": "⊥", "\\botsemicircle": "◡", "\\bowtie": "⋈", "\\boxast": "⧆", "\\boxbar": "◫", "\\boxbox": "⧈", "\\boxbslash": "⧅", "\\boxcircle": "⧇", "\\boxdiag": "⧄", "\\boxdot": "⊡", "\\boxminus": "⊟", "\\boxonbox": "⧉", "\\boxplus": "⊞", "\\boxslash": "⧄", "\\boxtimes": "⊠", "\\breve": "̆", "\\bsimilarleftarrow": "⭁", "\\bsimilarrightarrow": "⭇", "\\bsolhsub": "⟈", "\\btimes": "⨲", "\\bud": "Ъ", "\\bullet": "∙", "\\bullseye": "◎", "\\bumpeq": "≏", "\\bumpeqq": "⪮", "\\c": "̧", "\\cancer": "♋", "\\candra": "̐", "\\cap": "∩", "\\capbarcup": "⩉", "\\capdot": "⩀", "\\capovercup": "⩇", "\\capricornus": "♑", "\\capwedge": "⩄", "\\caretinsert": "‸", "\\carriagereturn": "↵", "\\ccwundercurvearrow": "⤿", "\\cdot": "⋅", "\\cdotp": "·", "\\cdots": "⋯", "\\cdprime": "Ъ", "\\check": "̌", "\\checkmark": "✓", "\\chi": "χ", "\\cirE": "⧃", "\\cirbot": "⟟", "\\circ": "∘", "\\circeq": "≗", "\\circlearrowleft": "↺", "\\circlearrowright": "↻", "\\circlebottomhalfblack": "◒", "\\circledS": "Ⓢ", "\\circledast": "⊛", "\\circledbslash": "⦸", "\\circledbullet": "⦿", "\\circledcirc": "⊚", "\\circleddash": "⊝", "\\circledequal": "⊜", "\\circledgtr": "⧁", "\\circledless": "⧀", "\\circledownarrow": "⧬", "\\circledparallel": "⦷", "\\circledrightdot": "⚆", "\\circledstar": "✪", "\\circledtwodots": "⚇", "\\circledvert": "⦶", "\\circledwhitebullet": "⦾", "\\circlehbar": "⦵", "\\circlelefthalfblack": "◐", "\\circlellquad": "◵", "\\circlelrquad": "◶", "\\circleonleftarrow": "⬰", "\\circleonrightarrow": "⇴", "\\circlerighthalfblack": "◑", "\\circletophalfblack": "◓", "\\circleulquad": "◴", "\\circleurquad": "◷", "\\circleurquadblack": "◔", "\\circlevertfill": "◍", "\\cirfnint": "⨐", "\\cirmid": "⫯", "\\cirscir": "⧂", "\\clockoint": "⨏", "\\closedvarcap": "⩍", "\\closedvarcup": "⩌", "\\closedvarcupsmashprod": "⩐", "\\closure": "⁐", "\\clubsuit": "♣", "\\clwintegral": "∱", "\\coloneq": "≔", "\\commaminus": "⨩", "\\complement": "∁", "\\concavediamond": "⟡", "\\concavediamondtickleft": "⟢", "\\concavediamondtickright": "⟣", "\\cong": "≅", "\\congdot": "⩭", "\\conictaper": "⌲", "\\conjquant": "⨇", "\\coprod": "∐", "\\copyright": "©", "\\cprime": "Ь", "\\csub": "⫏", "\\csube": "⫑", "\\csup": "⫐", "\\csupe": "⫒", "\\cuberoot": "∛", "\\cup": "∪", "\\cupbarcap": "⩈", "\\cupdot": "⊍", "\\cupleftarrow": "⊌", "\\cupovercap": "⩆", "\\cupvee": "⩅", "\\curlyeqprec": "⋞", "\\curlyeqsucc": "⋟", "\\curlyvee": "⋎", "\\curlywedge": "⋏", "\\curvearrowleft": "↶", "\\curvearrowleftplus": "⤽", "\\curvearrowright": "↷", "\\curvearrowrightminus": "⤼", "\\cwcirclearrow": "⥁", "\\cwgapcirclearrow": "⟳", "\\cwopencirclearrow": "↻", "\\cwrightarcarrow": "⤸", "\\cwundercurvearrow": "⤾", "\\cyrchar\\CYRA": "А", "\\cyrchar\\CYRABHCH": "Ҽ", "\\cyrchar\\CYRABHCHDSC": "Ҿ", "\\cyrchar\\CYRABHDZE": "Ӡ", "\\cyrchar\\CYRABHHA": "Ҩ", "\\cyrchar\\CYRAE": "Ӕ", "\\cyrchar\\CYRB": "Б", "\\cyrchar\\CYRBYUS": "Ѫ", "\\cyrchar\\CYRC": "Ц", "\\cyrchar\\CYRCH": "Ч", "\\cyrchar\\CYRCHLDSC": "Ӌ", "\\cyrchar\\CYRCHRDSC": "Ҷ", "\\cyrchar\\CYRCHVCRS": "Ҹ", "\\cyrchar\\CYRD": "Д", "\\cyrchar\\CYRDJE": "Ђ", "\\cyrchar\\CYRDZE": "Ѕ", "\\cyrchar\\CYRDZHE": "Џ", "\\cyrchar\\CYRE": "Е", "\\cyrchar\\CYREREV": "Э", "\\cyrchar\\CYRERY": "Ы", "\\cyrchar\\CYRF": "Ф", "\\cyrchar\\CYRFITA": "Ѳ", "\\cyrchar\\CYRG": "Г", "\\cyrchar\\CYRGHCRS": "Ғ", "\\cyrchar\\CYRGHK": "Ҕ", "\\cyrchar\\CYRGUP": "Ґ", "\\cyrchar\\CYRH": "Х", "\\cyrchar\\CYRHDSC": "Ҳ", "\\cyrchar\\CYRHRDSN": "Ъ", "\\cyrchar\\CYRI": "И", "\\cyrchar\\CYRIE": "Є", "\\cyrchar\\CYRII": "І", "\\cyrchar\\CYRIOTBYUS": "Ѭ", "\\cyrchar\\CYRIOTE": "Ѥ", "\\cyrchar\\CYRIOTLYUS": "Ѩ", "\\cyrchar\\CYRISHRT": "Й", "\\cyrchar\\CYRIZH": "Ѵ", "\\cyrchar\\CYRJE": "Ј", "\\cyrchar\\CYRK": "К", "\\cyrchar\\CYRKBEAK": "Ҡ", "\\cyrchar\\CYRKDSC": "Қ", "\\cyrchar\\CYRKHCRS": "Ҟ", "\\cyrchar\\CYRKHK": "Ӄ", "\\cyrchar\\CYRKOPPA": "Ҁ", "\\cyrchar\\CYRKSI": "Ѯ", "\\cyrchar\\CYRKVCRS": "Ҝ", "\\cyrchar\\CYRL": "Л", "\\cyrchar\\CYRLDSC": "Ӆ", "\\cyrchar\\CYRLJE": "Љ", "\\cyrchar\\CYRLYUS": "Ѧ", "\\cyrchar\\CYRM": "М", "\\cyrchar\\CYRMDSC": "Ӎ", "\\cyrchar\\CYRN": "Н", "\\cyrchar\\CYRNDSC": "Ң", "\\cyrchar\\CYRNG": "Ҥ", "\\cyrchar\\CYRNHK": "Ӈ", "\\cyrchar\\CYRNJE": "Њ", "\\cyrchar\\CYRO": "О", "\\cyrchar\\CYROMEGA": "Ѡ", "\\cyrchar\\CYROMEGARND": "Ѻ", "\\cyrchar\\CYROMEGATITLO": "Ѽ", "\\cyrchar\\CYROT": "Ѿ", "\\cyrchar\\CYROTLD": "Ө", "\\cyrchar\\CYRP": "П", "\\cyrchar\\CYRPHK": "Ҧ", "\\cyrchar\\CYRPSI": "Ѱ", "\\cyrchar\\CYRR": "Р", "\\cyrchar\\CYRRTICK": "Ҏ", "\\cyrchar\\CYRS": "С", "\\cyrchar\\CYRSCHWA": "Ә", "\\cyrchar\\CYRSDSC": "Ҫ", "\\cyrchar\\CYRSEMISFTSN": "Ҍ", "\\cyrchar\\CYRSFTSN": "Ь", "\\cyrchar\\CYRSH": "Ш", "\\cyrchar\\CYRSHCH": "Щ", "\\cyrchar\\CYRSHHA": "Һ", "\\cyrchar\\CYRT": "Т", "\\cyrchar\\CYRTDSC": "Ҭ", "\\cyrchar\\CYRTETSE": "Ҵ", "\\cyrchar\\CYRTSHE": "Ћ", "\\cyrchar\\CYRU": "У", "\\cyrchar\\CYRUK": "Ѹ", "\\cyrchar\\CYRUSHRT": "Ў", "\\cyrchar\\CYRV": "В", "\\cyrchar\\CYRY": "Ү", "\\cyrchar\\CYRYA": "Я", "\\cyrchar\\CYRYAT": "Ѣ", "\\cyrchar\\CYRYHCRS": "Ұ", "\\cyrchar\\CYRYI": "Ї", "\\cyrchar\\CYRYO": "Ё", "\\cyrchar\\CYRYU": "Ю", "\\cyrchar\\CYRZ": "З", "\\cyrchar\\CYRZDSC": "Ҙ", "\\cyrchar\\CYRZH": "Ж", "\\cyrchar\\CYRZHDSC": "Җ", "\\cyrchar\\CYRpalochka": "Ӏ", "\\cyrchar\\cyra": "а", "\\cyrchar\\cyrabhch": "ҽ", "\\cyrchar\\cyrabhchdsc": "ҿ", "\\cyrchar\\cyrabhdze": "ӡ", "\\cyrchar\\cyrabhha": "ҩ", "\\cyrchar\\cyrae": "ӕ", "\\cyrchar\\cyrb": "б", "\\cyrchar\\cyrbyus": "ѫ", "\\cyrchar\\cyrc": "ц", "\\cyrchar\\cyrch": "ч", "\\cyrchar\\cyrchldsc": "ӌ", "\\cyrchar\\cyrchrdsc": "ҷ", "\\cyrchar\\cyrchvcrs": "ҹ", "\\cyrchar\\cyrd": "д", "\\cyrchar\\cyrdje": "ђ", "\\cyrchar\\cyrdze": "ѕ", "\\cyrchar\\cyrdzhe": "џ", "\\cyrchar\\cyre": "е", "\\cyrchar\\cyrerev": "э", "\\cyrchar\\cyrery": "ы", "\\cyrchar\\cyrf": "ф", "\\cyrchar\\cyrfita": "ѳ", "\\cyrchar\\cyrg": "г", "\\cyrchar\\cyrghcrs": "ғ", "\\cyrchar\\cyrghk": "ҕ", "\\cyrchar\\cyrgup": "ґ", "\\cyrchar\\cyrh": "х", "\\cyrchar\\cyrhdsc": "ҳ", "\\cyrchar\\cyrhrdsn": "ъ", "\\cyrchar\\cyrhundredthousands": "҈", "\\cyrchar\\cyri": "и", "\\cyrchar\\cyrie": "є", "\\cyrchar\\cyrii": "і", "\\cyrchar\\cyriotbyus": "ѭ", "\\cyrchar\\cyriote": "ѥ", "\\cyrchar\\cyriotlyus": "ѩ", "\\cyrchar\\cyrishrt": "й", "\\cyrchar\\cyrizh": "ѵ", "\\cyrchar\\cyrje": "ј", "\\cyrchar\\cyrk": "к", "\\cyrchar\\cyrkbeak": "ҡ", "\\cyrchar\\cyrkdsc": "қ", "\\cyrchar\\cyrkhcrs": "ҟ", "\\cyrchar\\cyrkhk": "ӄ", "\\cyrchar\\cyrkoppa": "ҁ", "\\cyrchar\\cyrksi": "ѯ", "\\cyrchar\\cyrkvcrs": "ҝ", "\\cyrchar\\cyrl": "л", "\\cyrchar\\cyrldsc": "ӆ", "\\cyrchar\\cyrlje": "љ", "\\cyrchar\\cyrlyus": "ѧ", "\\cyrchar\\cyrm": "м", "\\cyrchar\\cyrmdsc": "ӎ", "\\cyrchar\\cyrmillions": "҉", "\\cyrchar\\cyrn": "н", "\\cyrchar\\cyrndsc": "ң", "\\cyrchar\\cyrng": "ҥ", "\\cyrchar\\cyrnhk": "ӈ", "\\cyrchar\\cyrnje": "њ", "\\cyrchar\\cyro": "о", "\\cyrchar\\cyromega": "ѡ", "\\cyrchar\\cyromegarnd": "ѻ", "\\cyrchar\\cyromegatitlo": "ѽ", "\\cyrchar\\cyrot": "ѿ", "\\cyrchar\\cyrotld": "ө", "\\cyrchar\\cyrp": "п", "\\cyrchar\\cyrphk": "ҧ", "\\cyrchar\\cyrpsi": "ѱ", "\\cyrchar\\cyrr": "р", "\\cyrchar\\cyrrtick": "ҏ", "\\cyrchar\\cyrs": "с", "\\cyrchar\\cyrschwa": "ә", "\\cyrchar\\cyrsdsc": "ҫ", "\\cyrchar\\cyrsemisftsn": "ҍ", "\\cyrchar\\cyrsftsn": "ь", "\\cyrchar\\cyrsh": "ш", "\\cyrchar\\cyrshch": "щ", "\\cyrchar\\cyrshha": "һ", "\\cyrchar\\cyrt": "т", "\\cyrchar\\cyrtdsc": "ҭ", "\\cyrchar\\cyrtetse": "ҵ", "\\cyrchar\\cyrthousands": "҂", "\\cyrchar\\cyrtshe": "ћ", "\\cyrchar\\cyru": "у", "\\cyrchar\\cyruk": "ѹ", "\\cyrchar\\cyrushrt": "ў", "\\cyrchar\\cyrv": "в", "\\cyrchar\\cyry": "ү", "\\cyrchar\\cyrya": "я", "\\cyrchar\\cyryat": "ѣ", "\\cyrchar\\cyryhcrs": "ұ", "\\cyrchar\\cyryi": "ї", "\\cyrchar\\cyryo": "ё", "\\cyrchar\\cyryu": "ю", "\\cyrchar\\cyrz": "з", "\\cyrchar\\cyrzdsc": "ҙ", "\\cyrchar\\cyrzh": "ж", "\\cyrchar\\cyrzhdsc": "җ", "\\cyrchar{\\'\\CYRG}": "Ѓ", "\\cyrchar{\\'\\CYRK}": "Ќ", "\\cyrchar{\\'\\cyrg}": "ѓ", "\\cyrchar{\\'\\cyrk}": "ќ", "\\c{\\u{E}}": "Ḝ", "\\c{\\u{e}}": "ḝ", "\\d": "̣", "\\dag": "†", "\\dagger": "†", "\\daleth": "ℸ", "\\danger": "☡", "\\dashV": "⫣", "\\dashVdash": "⟛", "\\dashcolon": "∹", "\\dashleftarrow": "⇠", "\\dashleftharpoondown": "⥫", "\\dashrightarrow": "⇢", "\\dashrightharpoondown": "⥭", "\\dashv": "⊣", "\\dbend": "�", "\\dbkarrow": "⤏", "\\dblarrowupdown": "⇅", "\\ddag": "‡", "\\ddagger": "‡", "\\ddddot": "⃜", "\\dddot": "⃛", "\\ddot": "̈", "\\ddots": "⋱", "\\ddotseq": "⩷", "\\ddot{\\iota}": "ϊ", "\\ddot{\\upsilon}": "ϋ", "\\delta": "δ", "\\dh": "ð", "\\diagdown": "⟍", "\\diagup": "⟋", "\\diameter": "⌀", "\\diamond": "♢", "\\diamondbotblack": "⬙", "\\diamondcdot": "⟐", "\\diamondleftarrow": "⤝", "\\diamondleftarrowbar": "⤟", "\\diamondleftblack": "⬖", "\\diamondrightblack": "⬗", "\\diamondsuit": "♢", "\\diamondtopblack": "⬘", "\\dicei": "⚀", "\\diceii": "⚁", "\\diceiii": "⚂", "\\diceiv": "⚃", "\\dicev": "⚄", "\\dicevi": "⚅", "\\digamma": "ϝ", "\\dingasterisk": "✽", "\\ding{100}": "❄", "\\ding{101}": "❅", "\\ding{102}": "❆", "\\ding{103}": "❇", "\\ding{104}": "❈", "\\ding{105}": "❉", "\\ding{106}": "❊", "\\ding{107}": "❋", "\\ding{108}": "●", "\\ding{109}": "❍", "\\ding{110}": "■", "\\ding{111}": "❏", "\\ding{112}": "❐", "\\ding{113}": "❑", "\\ding{114}": "❒", "\\ding{115}": "▲", "\\ding{116}": "▼", "\\ding{117}": "◆", "\\ding{118}": "❖", "\\ding{119}": "◗", "\\ding{120}": "❘", "\\ding{121}": "❙", "\\ding{122}": "❚", "\\ding{123}": "❛", "\\ding{124}": "❜", "\\ding{125}": "❝", "\\ding{126}": "❞", "\\ding{161}": "❡", "\\ding{162}": "❢", "\\ding{163}": "❣", "\\ding{164}": "❤", "\\ding{165}": "❥", "\\ding{166}": "❦", "\\ding{167}": "❧", "\\ding{168}": "♣", "\\ding{169}": "♦", "\\ding{170}": "♥", "\\ding{171}": "♠", "\\ding{172}": "①", "\\ding{173}": "②", "\\ding{174}": "③", "\\ding{175}": "④", "\\ding{176}": "⑤", "\\ding{177}": "⑥", "\\ding{178}": "⑦", "\\ding{179}": "⑧", "\\ding{180}": "⑨", "\\ding{181}": "⑩", "\\ding{182}": "❶", "\\ding{183}": "❷", "\\ding{184}": "❸", "\\ding{185}": "❹", "\\ding{186}": "❺", "\\ding{187}": "❻", "\\ding{188}": "❼", "\\ding{189}": "❽", "\\ding{190}": "❾", "\\ding{191}": "❿", "\\ding{192}": "➀", "\\ding{193}": "➁", "\\ding{194}": "➂", "\\ding{195}": "➃", "\\ding{196}": "➄", "\\ding{197}": "➅", "\\ding{198}": "➆", "\\ding{199}": "➇", "\\ding{200}": "➈", "\\ding{201}": "➉", "\\ding{202}": "➊", "\\ding{203}": "➋", "\\ding{204}": "➌", "\\ding{205}": "➍", "\\ding{206}": "➎", "\\ding{207}": "➏", "\\ding{208}": "➐", "\\ding{209}": "➑", "\\ding{210}": "➒", "\\ding{211}": "➓", "\\ding{212}": "➔", "\\ding{216}": "➘", "\\ding{217}": "➙", "\\ding{218}": "➚", "\\ding{219}": "➛", "\\ding{220}": "➜", "\\ding{221}": "➝", "\\ding{222}": "➞", "\\ding{223}": "➟", "\\ding{224}": "➠", "\\ding{225}": "➡", "\\ding{226}": "➢", "\\ding{227}": "➣", "\\ding{228}": "➤", "\\ding{229}": "➥", "\\ding{230}": "➦", "\\ding{231}": "➧", "\\ding{232}": "➨", "\\ding{233}": "➩", "\\ding{234}": "➪", "\\ding{235}": "➫", "\\ding{236}": "➬", "\\ding{237}": "➭", "\\ding{238}": "➮", "\\ding{239}": "➯", "\\ding{241}": "➱", "\\ding{242}": "➲", "\\ding{243}": "➳", "\\ding{244}": "➴", "\\ding{245}": "➵", "\\ding{246}": "➶", "\\ding{247}": "➷", "\\ding{248}": "➸", "\\ding{249}": "➹", "\\ding{250}": "➺", "\\ding{251}": "➻", "\\ding{252}": "➼", "\\ding{253}": "➽", "\\ding{254}": "➾", "\\ding{33}": "✁", "\\ding{34}": "✂", "\\ding{35}": "✃", "\\ding{36}": "✄", "\\ding{37}": "☎", "\\ding{38}": "✆", "\\ding{39}": "✇", "\\ding{40}": "✈", "\\ding{41}": "✉", "\\ding{42}": "☛", "\\ding{43}": "☞", "\\ding{44}": "✌", "\\ding{45}": "✍", "\\ding{46}": "✎", "\\ding{47}": "✏", "\\ding{48}": "✐", "\\ding{49}": "✑", "\\ding{50}": "✒", "\\ding{51}": "✓", "\\ding{52}": "✔", "\\ding{53}": "✕", "\\ding{54}": "✖", "\\ding{55}": "✗", "\\ding{56}": "✘", "\\ding{57}": "✙", "\\ding{58}": "✚", "\\ding{59}": "✛", "\\ding{60}": "✜", "\\ding{61}": "✝", "\\ding{62}": "✞", "\\ding{63}": "✟", "\\ding{64}": "✠", "\\ding{65}": "✡", "\\ding{66}": "✢", "\\ding{67}": "✣", "\\ding{68}": "✤", "\\ding{69}": "✥", "\\ding{70}": "✦", "\\ding{71}": "✧", "\\ding{72}": "★", "\\ding{73}": "☆", "\\ding{74}": "✪", "\\ding{75}": "✫", "\\ding{76}": "✬", "\\ding{77}": "✭", "\\ding{78}": "✮", "\\ding{79}": "✯", "\\ding{80}": "✰", "\\ding{81}": "✱", "\\ding{82}": "✲", "\\ding{83}": "✳", "\\ding{84}": "✴", "\\ding{85}": "✵", "\\ding{86}": "✶", "\\ding{87}": "✷", "\\ding{88}": "✸", "\\ding{89}": "✹", "\\ding{90}": "✺", "\\ding{91}": "✻", "\\ding{92}": "✼", "\\ding{93}": "✽", "\\ding{94}": "✾", "\\ding{95}": "✿", "\\ding{96}": "❀", "\\ding{97}": "❁", "\\ding{98}": "❂", "\\ding{99}": "❃", "\\disin": "⋲", "\\disjquant": "⨈", "\\div": "÷", "\\divideontimes": "⋇", "\\divslash": "∕", "\\dj": "đ", "\\dlsh": "↲", "\\dot": "̇", "\\dotdiv": "∸", "\\doteq": "≐", "\\doteqdot": "≑", "\\dotequiv": "⩧", "\\dotminus": "∸", "\\dotplus": "∔", "\\dots": "…", "\\dotsim": "⩪", "\\dotsminusdots": "∺", "\\dottedcircle": "◌", "\\dottedsquare": "⬚", "\\dottimes": "⨰", "\\doublebarvee": "⩢", "\\doublebarwedge": "⩞", "\\doubleplus": "⧺", "\\downarrow": "↓", "\\downarrowbar": "⤓", "\\downarrowbarred": "⤈", "\\downdasharrow": "⇣", "\\downdownarrows": "⇊", "\\downdownharpoons": "⥥", "\\downfishtail": "⥿", "\\downharpoonleft": "⇃", "\\downharpoonleftbar": "⥙", "\\downharpoonright": "⇂", "\\downharpoonrightbar": "⥕", "\\downharpoonsleftright": "⥥", "\\downrightcurvedarrow": "⤵", "\\downslopeellipsis": "⋱", "\\downtriangleleftblack": "⧨", "\\downtrianglerightblack": "⧩", "\\downuparrows": "⇵", "\\downupharpoonsleftright": "⥯", "\\downwhitearrow": "⇩", "\\downzigzagarrow": "↯", "\\dprime": "″", "\\draftingarrow": "➛", "\\drbkarrow": "⤐", "\\droang": "̚", "\\dsol": "⧶", "\\dsub": "⩤", "\\dualmap": "⧟", "\\earth": "♁", "\\egsdot": "⪘", "\\eighthnote": "♪", "\\elinters": "⏧", "\\ell": "ℓ", "\\elsdot": "⪗", "\\emptysetoarr": "⦳", "\\emptysetoarrl": "⦴", "\\emptysetobar": "⦱", "\\emptysetocirc": "⦲", "\\enclosecircle": "⃝", "\\enclosediamond": "⃟", "\\enclosesquare": "⃞", "\\enclosetriangle": "⃤", "\\enleadertwodots": "‥", "\\enspace": " ", "\\eparsl": "⧣", "\\epsilon": "ϵ", "\\eqcirc": "≖", "\\eqcolon": "≕", "\\eqdef": "≝", "\\eqdot": "⩦", "\\eqeq": "⩵", "\\eqeqeq": "⩶", "\\eqgtr": "⋝", "\\eqless": "⋜", "\\eqqgtr": "⪚", "\\eqqless": "⪙", "\\eqqplus": "⩱", "\\eqqsim": "⩳", "\\eqqslantgtr": "⪜", "\\eqqslantless": "⪛", "\\eqsim": "≂", "\\eqslantgtr": "⪖", "\\eqslantless": "⪕", "\\equal": "=", "\\equalleftarrow": "⭀", "\\equalparallel": "⋕", "\\equalrightarrow": "⥱", "\\equiv": "≡", "\\equivDD": "⩸", "\\equivVert": "⩨", "\\equivVvert": "⩩", "\\eqvparsl": "⧥", "\\errbarblackcircle": "⧳", "\\errbarblackdiamond": "⧱", "\\errbarblacksquare": "⧯", "\\errbarcircle": "⧲", "\\errbardiamond": "⧰", "\\errbarsquare": "⧮", "\\estimates": "≙", "\\eta": "η", "\\eth": "ð", "\\euro": "€", "\\exists": "∃", "\\fallingdotseq": "≒", "\\fbowtie": "⧓", "\\fbox{~~}": "▭", "\\fcmp": "⨾", "\\fdiagovnearrow": "⤯", "\\fdiagovrdiag": "⤬", "\\female": "♀", "\\ffun": "⇻", "\\finj": "⤕", "\\fint": "⨏", "\\fisheye": "◉", "\\flat": "♭", "\\fltns": "⏥", "\\forall": "∀", "\\forcesextra": "⊨", "\\forks": "⫝̸", "\\forksnot": "⫝", "\\forkv": "⫙", "\\fourthroot": "∜", "\\fourvdots": "⦙", "\\fracslash": "⁄", "\\frac{0}{3}": "↉", "\\frac{1}": "⅟", "\\frac{1}{10}": "⅒", "\\frac{1}{2}": "½", "\\frac{1}{3}": "⅓", "\\frac{1}{4}": "¼", "\\frac{1}{5}": "⅕", "\\frac{1}{6}": "⅙", "\\frac{1}{7}": "⅐", "\\frac{1}{8}": "⅛", "\\frac{1}{9}": "⅑", "\\frac{2}{3}": "⅔", "\\frac{2}{5}": "⅖", "\\frac{3}{4}": "¾", "\\frac{3}{5}": "⅗", "\\frac{3}{8}": "⅜", "\\frac{4}{5}": "⅘", "\\frac{5}{6}": "⅚", "\\frac{5}{8}": "⅝", "\\frac{7}{8}": "⅞", "\\frown": "⌢", "\\frownie": "☹", "\\fullouterjoin": "⟗", "\\gamma": "γ", "\\ge": "≥", "\\gemini": "♊", "\\geq": "≥", "\\geqq": "≧", "\\geqqslant": "⫺", "\\geqslant": "⩾", "\\gescc": "⪩", "\\gesdot": "⪀", "\\gesdoto": "⪂", "\\gesdotol": "⪄", "\\gesles": "⪔", "\\gg": "≫", "\\ggcurly": "⪼", "\\ggg": "⋙", "\\gggnest": "⫸", "\\gimel": "ℷ", "\\glE": "⪒", "\\gla": "⪥", "\\gleichstark": "⧦", "\\glj": "⪤", "\\gnapprox": "⪊", "\\gneq": "⪈", "\\gneqq": "≩", "\\gnsim": "⋧", "\\grave": "̀", "\\greater": ">", "\\greaterequivlnt": "≳", "\\gsime": "⪎", "\\gsiml": "⪐", "\\gtcc": "⪧", "\\gtcir": "⩺", "\\gtlpar": "⦠", "\\gtquest": "⩼", "\\gtrapprox": "⪆", "\\gtrarr": "⥸", "\\gtrdot": "⋗", "\\gtreqless": "⋛", "\\gtreqqless": "⪌", "\\gtrless": "≷", "\\gtrsim": "≳", "\\guillemotleft": "«", "\\guillemotright": "»", "\\guilsinglleft": "‹", "\\guilsinglright": "›", "\\gvertneqq": "≩︀", "\\harrowextender": "⎯", "\\hash": "⋕", "\\hat": "∧", "\\hatapprox": "⩯", "\\hbar": "ħ", "\\heartsuit": "♡", "\\hebalef": "א", "\\hebayin": "ע", "\\hebbet": "ב", "\\hebdalet": "ד", "\\hebfinalkaf": "ך", "\\hebfinalmem": "ם", "\\hebfinalnun": "ן", "\\hebfinalpe": "ף", "\\hebfinaltsadi": "ץ", "\\hebgimel": "ג", "\\hebhe": "ה", "\\hebhet": "ח", "\\hebkaf": "כ", "\\heblamed": "ל", "\\hebmem": "מ", "\\hebnun": "נ", "\\hebpe": "פ", "\\hebqof": "ק", "\\hebresh": "ר", "\\hebsamekh": "ס", "\\hebshin": "ש", "\\hebtav": "ת", "\\hebtet": "ט", "\\hebtsadi": "צ", "\\hebvav": "ו", "\\hebyod": "י", "\\hebzayin": "ז", "\\hermitconjmatrix": "⊹", "\\hermitmatrix": "⊹", "\\hexagon": "⎔", "\\hexagonblack": "⬣", "\\hknearrow": "⤤", "\\hknwarrow": "⤣", "\\hksearrow": "⤥", "\\hkswarrow": "⤦", "\\homothetic": "∻", "\\hookleftarrow": "↩", "\\hookrightarrow": "↪", "\\horizbar": "―", "\\hourglass": "⧖", "\\house": "⌂", "\\hphantom{,}": " ", "\\hphantom{0}": " ", "\\hrectangle": "▭", "\\hrectangleblack": "▬", "\\hslash": "ℏ", "\\hspace{0.166em}": " ", "\\hspace{0.25em}": " ", "\\hspace{0.6em}": " ", "\\hspace{0pt}": "​", "\\hyphenbullet": "⁃", "\\hzigzag": "〰", "\\i": "ı", "\\iiiint": "⨌", "\\iiint": "∭", "\\iinfin": "⧜", "\\iint": "∬", "\\ij": "ĳ", "\\image": "⊷", "\\imageof": "⊷", "\\imath": "𝚤", "\\in": "∈", "\\increment": "∆", "\\infty": "∞", "\\int": "∫", "\\intBar": "⨎", "\\intbar": "⨍", "\\intbottom": "⌡", "\\intcap": "⨙", "\\intclockwise": "∱", "\\intcup": "⨚", "\\intercal": "⊺", "\\interleave": "⫴", "\\intextender": "⎮", "\\intlarhk": "⨗", "\\intprod": "⨼", "\\intprodr": "⨽", "\\inttop": "⌠", "\\intx": "⨘", "\\invamp": "⅋", "\\invdiameter": "⍉", "\\inversebullet": "◘", "\\inversewhitecircle": "◙", "\\invlazys": "∾", "\\invneg": "⌐", "\\invnot": "⌐", "\\invwhitelowerhalfcircle": "◛", "\\invwhiteupperhalfcircle": "◚", "\\iota": "ι", "\\isinE": "⋹", "\\isindot": "⋵", "\\isinobar": "⋷", "\\isins": "⋴", "\\isinvb": "⋸", "\\j": "ȷ", "\\jmath": "𝚥", "\\jupiter": "♃", "\\k": "̨", "\\kappa": "κ", "\\kernelcontraction": "∻", "\\koppa": "ϟ", "\\k{}": "˛", "\\l": "ł", "\\lAngle": "⟪", "\\lBrace": "⦃", "\\lBrack": "⟦", "\\lParen": "⦅", "\\lambda": "λ", "\\lang": "⟪", "\\langle": "⟨", "\\langledot": "⦑", "\\laplac": "⧠", "\\lasp": "ʿ", "\\lat": "⪫", "\\late": "⪭", "\\lazysinv": "∾", "\\lbag": "⟅", "\\lblkbrbrak": "⦗", "\\lblot": "⦉", "\\lbrace": "{", "\\lbracelend": "⎩", "\\lbracemid": "⎨", "\\lbraceuend": "⎧", "\\lbrack": "[", "\\lbrackextender": "⎢", "\\lbracklend": "⎣", "\\lbracklltick": "⦏", "\\lbrackubar": "⦋", "\\lbrackuend": "⎡", "\\lbrackultick": "⦍", "\\lbrbrak": "〔", "\\lceil": "⌈", "\\lcirclerightint": "∲", "\\lcurvyangle": "⧼", "\\ldots": "…", "\\le": "≤", "\\left": "", "\\leftarrow": "←", "\\leftarrowapprox": "⭊", "\\leftarrowbackapprox": "⭂", "\\leftarrowbsimilar": "⭋", "\\leftarrowless": "⥷", "\\leftarrowonoplus": "⬲", "\\leftarrowplus": "⥆", "\\leftarrowshortrightarrow": "⥃", "\\leftarrowsimilar": "⥳", "\\leftarrowsubset": "⥺", "\\leftarrowtail": "↢", "\\leftarrowtriangle": "⇽", "\\leftarrowx": "⬾", "\\leftbarharpoon": "⥪", "\\leftbkarrow": "⤌", "\\leftcurvedarrow": "⬿", "\\leftdasharrow": "⇠", "\\leftdbkarrow": "⤎", "\\leftdbltail": "⤛", "\\leftdotarrow": "⬸", "\\leftdowncurvedarrow": "⤶", "\\leftfishtail": "⥼", "\\leftharpoonaccent": "⃐", "\\leftharpoondown": "↽", "\\leftharpoondownbar": "⥞", "\\leftharpoonsupdown": "⥢", "\\leftharpoonup": "↼", "\\leftharpoonupbar": "⥚", "\\leftharpoonupdash": "⥪", "\\leftleftarrows": "⇇", "\\leftleftharpoons": "⥢", "\\leftmoon": "☾", "\\leftouterjoin": "⟕", "\\leftrightarrow": "↔", "\\leftrightarrowcircle": "⥈", "\\leftrightarrows": "⇆", "\\leftrightarrowtriangle": "⇿", "\\leftrightharpoon": "⥊", "\\leftrightharpoondowndown": "⥐", "\\leftrightharpoondownup": "⥋", "\\leftrightharpoons": "⇋", "\\leftrightharpoonsdown": "⥧", "\\leftrightharpoonsup": "⥦", "\\leftrightharpoonupdown": "⥊", "\\leftrightharpoonupup": "⥎", "\\leftrightsquigarrow": "↭", "\\leftslice": "⪦", "\\leftsquigarrow": "⇜", "\\lefttail": "⤙", "\\leftthreearrows": "⬱", "\\leftthreetimes": "⋋", "\\leftwavearrow": "↜", "\\leftwhitearrow": "⇦", "\\leo": "♌", "\\leq": "≤", "\\leqq": "≦", "\\leqqslant": "⫹", "\\leqslant": "⩽", "\\lescc": "⪨", "\\lesdot": "⩿", "\\lesdoto": "⪁", "\\lesdotor": "⪃", "\\lesges": "⪓", "\\less": "<", "\\lessapprox": "⪅", "\\lessdot": "⋖", "\\lesseqgtr": "⋚", "\\lesseqqgtr": "⪋", "\\lessequivlnt": "≲", "\\lessgtr": "≶", "\\lesssim": "≲", "\\lfbowtie": "⧑", "\\lfloor": "⌊", "\\lftimes": "⧔", "\\lgE": "⪑", "\\lgblkcircle": "⬤", "\\lgblksquare": "⬛", "\\lgroup": "⟮", "\\lgwhtcircle": "◯", "\\lgwhtsquare": "⬜", "\\lhd": "◁", "\\libra": "♎", "\\lightning": "↯", "\\limg": "⦇", "\\linefeed": "↴", "\\ll": "≪", "\\llangle": "⦉", "\\llarc": "◟", "\\llblacktriangle": "◣", "\\llbracket": "⟦", "\\llcorner": "⌞", "\\llcurly": "⪻", "\\lll": "⋘", "\\lllnest": "⫷", "\\llparenthesis": "⦇", "\\lltriangle": "◺", "\\lmoustache": "⎰", "\\lnapprox": "⪉", "\\lneq": "⪇", "\\lneqq": "≨", "\\lnot": "¬", "\\lnsim": "⋦", "\\longdashv": "⟞", "\\longdivision": "⟌", "\\longleftarrow": "⟵", "\\longleftrightarrow": "⟷", "\\longleftsquigarrow": "⬳", "\\longmapsfrom": "⟻", "\\longmapsto": "⟼", "\\longrightarrow": "⟶", "\\longrightsquigarrow": "⟿", "\\looparrowleft": "↫", "\\looparrowright": "↬", "\\lowint": "⨜", "\\lozenge": "◊", "\\lozengeminus": "⟠", "\\lparen": "(", "\\lparenextender": "⎜", "\\lparenlend": "⎝", "\\lparenless": "⦓", "\\lparenuend": "⎛", "\\lrarc": "◞", "\\lrblacktriangle": "◢", "\\lrcorner": "⌟", "\\lrtriangle": "◿", "\\lrtriangleeq": "⧡", "\\lsime": "⪍", "\\lsimg": "⪏", "\\lsqhook": "⫍", "\\ltcc": "⪦", "\\ltcir": "⩹", "\\ltimes": "⋉", "\\ltlarr": "⥶", "\\ltquest": "⩻", "\\ltrivb": "⧏", "\\lvboxline": "⎸", "\\lvec": "⃐", "\\lvertneqq": "≨︀", "\\lvzigzag": "⧘", "\\male": "♂", "\\maltese": "✠", "\\mapsdown": "↧", "\\mapsfrom": "↤", "\\mapsto": "↦", "\\mapsup": "↥", "\\mathampersand": "&", "\\mathatsign": "@", "\\mathbb{0}": "𝟘", "\\mathbb{1}": "𝟙", "\\mathbb{2}": "𝟚", "\\mathbb{3}": "𝟛", "\\mathbb{4}": "𝟜", "\\mathbb{5}": "𝟝", "\\mathbb{6}": "𝟞", "\\mathbb{7}": "𝟟", "\\mathbb{8}": "𝟠", "\\mathbb{9}": "𝟡", "\\mathbb{A}": "𝔸", "\\mathbb{B}": "𝔹", "\\mathbb{C}": "ℂ", "\\mathbb{D}": "𝔻", "\\mathbb{E}": "𝔼", "\\mathbb{F}": "𝔽", "\\mathbb{G}": "𝔾", "\\mathbb{H}": "ℍ", "\\mathbb{I}": "𝕀", "\\mathbb{J}": "𝕁", "\\mathbb{K}": "𝕂", "\\mathbb{L}": "𝕃", "\\mathbb{M}": "𝕄", "\\mathbb{N}": "ℕ", "\\mathbb{O}": "𝕆", "\\mathbb{P}": "ℙ", "\\mathbb{Q}": "ℚ", "\\mathbb{R}": "ℝ", "\\mathbb{S}": "𝕊", "\\mathbb{T}": "𝕋", "\\mathbb{U}": "𝕌", "\\mathbb{V}": "𝕍", "\\mathbb{W}": "𝕎", "\\mathbb{X}": "𝕏", "\\mathbb{Y}": "𝕐", "\\mathbb{Z}": "ℤ", "\\mathbb{\\Gamma}": "ℾ", "\\mathbb{\\Pi}": "ℿ", "\\mathbb{\\Sigma}": "⅀", "\\mathbb{\\gamma}": "ℽ", "\\mathbb{\\pi}": "ℼ", "\\mathbb{a}": "𝕒", "\\mathbb{b}": "𝕓", "\\mathbb{c}": "𝕔", "\\mathbb{d}": "𝕕", "\\mathbb{e}": "𝕖", "\\mathbb{f}": "𝕗", "\\mathbb{g}": "𝕘", "\\mathbb{h}": "𝕙", "\\mathbb{i}": "𝕚", "\\mathbb{j}": "𝕛", "\\mathbb{k}": "𝕜", "\\mathbb{l}": "𝕝", "\\mathbb{m}": "𝕞", "\\mathbb{n}": "𝕟", "\\mathbb{o}": "𝕠", "\\mathbb{p}": "𝕡", "\\mathbb{q}": "𝕢", "\\mathbb{r}": "𝕣", "\\mathbb{s}": "𝕤", "\\mathbb{t}": "𝕥", "\\mathbb{u}": "𝕦", "\\mathbb{v}": "𝕧", "\\mathbb{w}": "𝕨", "\\mathbb{x}": "𝕩", "\\mathbb{y}": "𝕪", "\\mathbb{z}": "𝕫", "\\mathbf{0}": "𝟎", "\\mathbf{1}": "𝟏", "\\mathbf{2}": "𝟐", "\\mathbf{3}": "𝟑", "\\mathbf{4}": "𝟒", "\\mathbf{5}": "𝟓", "\\mathbf{6}": "𝟔", "\\mathbf{7}": "𝟕", "\\mathbf{8}": "𝟖", "\\mathbf{9}": "𝟗", "\\mathbf{A}": "𝐀", "\\mathbf{B}": "𝐁", "\\mathbf{C}": "𝐂", "\\mathbf{D}": "𝐃", "\\mathbf{E}": "𝐄", "\\mathbf{F}": "𝐅", "\\mathbf{G}": "𝐆", "\\mathbf{H}": "𝐇", "\\mathbf{I}": "𝐈", "\\mathbf{J}": "𝐉", "\\mathbf{K}": "𝐊", "\\mathbf{L}": "𝐋", "\\mathbf{M}": "𝐌", "\\mathbf{N}": "𝐍", "\\mathbf{O}": "𝐎", "\\mathbf{P}": "𝐏", "\\mathbf{Q}": "𝐐", "\\mathbf{R}": "𝐑", "\\mathbf{S}": "𝐒", "\\mathbf{T}": "𝐓", "\\mathbf{U}": "𝐔", "\\mathbf{V}": "𝐕", "\\mathbf{W}": "𝐖", "\\mathbf{X}": "𝐗", "\\mathbf{Y}": "𝐘", "\\mathbf{Z}": "𝐙", "\\mathbf{\\Delta}": "𝚫", "\\mathbf{\\Gamma}": "𝚪", "\\mathbf{\\Lambda}": "𝚲", "\\mathbf{\\Omega}": "𝛀", "\\mathbf{\\Phi}": "𝚽", "\\mathbf{\\Pi}": "𝚷", "\\mathbf{\\Psi}": "𝚿", "\\mathbf{\\Sigma}": "𝚺", "\\mathbf{\\Theta}": "𝚯", "\\mathbf{\\Upsilon}": "𝚼", "\\mathbf{\\Xi}": "𝚵", "\\mathbf{\\alpha}": "𝛂", "\\mathbf{\\beta}": "𝛃", "\\mathbf{\\delta}": "𝛅", "\\mathbf{\\epsilon}": "𝛆", "\\mathbf{\\eta}": "𝛈", "\\mathbf{\\gamma}": "𝛄", "\\mathbf{\\lambda}": "𝛌", "\\mathbf{\\nabla}": "𝛁", "\\mathbf{\\omega}": "𝛚", "\\mathbf{\\phi}": "𝛗", "\\mathbf{\\pi}": "𝛑", "\\mathbf{\\psi}": "𝛙", "\\mathbf{\\sigma}": "𝛔", "\\mathbf{\\theta}": "𝛉", "\\mathbf{\\upsilon}": "𝛖", "\\mathbf{\\varkappa}": "𝛞", "\\mathbf{\\varpi}": "𝛡", "\\mathbf{\\varrho}": "𝛠", "\\mathbf{\\varsigma}": "𝛓", "\\mathbf{\\vartheta}": "𝚹", "\\mathbf{\\xi}": "𝛏", "\\mathbf{\\zeta}": "𝛇", "\\mathbf{a}": "𝐚", "\\mathbf{b}": "𝐛", "\\mathbf{c}": "𝐜", "\\mathbf{d}": "𝐝", "\\mathbf{e}": "𝐞", "\\mathbf{f}": "𝐟", "\\mathbf{g}": "𝐠", "\\mathbf{h}": "𝐡", "\\mathbf{i}": "𝐢", "\\mathbf{j}": "𝐣", "\\mathbf{k}": "𝐤", "\\mathbf{l}": "𝐥", "\\mathbf{m}": "𝐦", "\\mathbf{n}": "𝐧", "\\mathbf{o}": "𝐨", "\\mathbf{p}": "𝐩", "\\mathbf{q}": "𝐪", "\\mathbf{r}": "𝐫", "\\mathbf{s}": "𝐬", "\\mathbf{t}": "𝐭", "\\mathbf{u}": "𝐮", "\\mathbf{v}": "𝐯", "\\mathbf{w}": "𝐰", "\\mathbf{x}": "𝐱", "\\mathbf{y}": "𝐲", "\\mathbf{z}": "𝐳", "\\mathbin{{:}\\!\\!{-}\\!\\!{:}}": "∺", "\\mathbit{A}": "𝑨", "\\mathbit{B}": "𝑩", "\\mathbit{C}": "𝑪", "\\mathbit{D}": "𝑫", "\\mathbit{E}": "𝑬", "\\mathbit{F}": "𝑭", "\\mathbit{G}": "𝑮", "\\mathbit{H}": "𝑯", "\\mathbit{I}": "𝑰", "\\mathbit{J}": "𝑱", "\\mathbit{K}": "𝑲", "\\mathbit{L}": "𝑳", "\\mathbit{M}": "𝑴", "\\mathbit{N}": "𝑵", "\\mathbit{O}": "𝑶", "\\mathbit{P}": "𝑷", "\\mathbit{Q}": "𝑸", "\\mathbit{R}": "𝑹", "\\mathbit{S}": "𝑺", "\\mathbit{T}": "𝑻", "\\mathbit{U}": "𝑼", "\\mathbit{V}": "𝑽", "\\mathbit{W}": "𝑾", "\\mathbit{X}": "𝑿", "\\mathbit{Y}": "𝒀", "\\mathbit{Z}": "𝒁", "\\mathbit{\\Delta}": "𝜟", "\\mathbit{\\Gamma}": "𝜞", "\\mathbit{\\Lambda}": "𝜦", "\\mathbit{\\Omega}": "𝜴", "\\mathbit{\\Phi}": "𝜱", "\\mathbit{\\Pi}": "𝜫", "\\mathbit{\\Psi}": "𝜳", "\\mathbit{\\Sigma}": "𝜮", "\\mathbit{\\Theta}": "𝜣", "\\mathbit{\\Upsilon}": "𝜰", "\\mathbit{\\Xi}": "𝜩", "\\mathbit{\\alpha}": "𝜶", "\\mathbit{\\beta}": "𝜷", "\\mathbit{\\chi}": "𝝌", "\\mathbit{\\delta}": "𝜹", "\\mathbit{\\epsilon}": "𝜺", "\\mathbit{\\eta}": "𝜼", "\\mathbit{\\gamma}": "𝜸", "\\mathbit{\\imath}": "𝜾", "\\mathbit{\\kappa}": "𝜿", "\\mathbit{\\lambda}": "𝝀", "\\mathbit{\\nabla}": "𝜵", "\\mathbit{\\omega}": "𝝎", "\\mathbit{\\phi}": "𝝓", "\\mathbit{\\pi}": "𝝅", "\\mathbit{\\psi}": "𝝍", "\\mathbit{\\rho}": "𝝆", "\\mathbit{\\sigma}": "𝝈", "\\mathbit{\\tau}": "𝝉", "\\mathbit{\\theta}": "𝜽", "\\mathbit{\\upsilon}": "𝝊", "\\mathbit{\\varkappa}": "𝝒", "\\mathbit{\\varphi}": "𝝋", "\\mathbit{\\varpi}": "𝝕", "\\mathbit{\\varrho}": "𝝔", "\\mathbit{\\varsigma}": "𝝇", "\\mathbit{\\vartheta}": "𝝑", "\\mathbit{\\xi}": "𝝃", "\\mathbit{\\zeta}": "𝜻", "\\mathbit{a}": "𝒂", "\\mathbit{b}": "𝒃", "\\mathbit{c}": "𝒄", "\\mathbit{d}": "𝒅", "\\mathbit{e}": "𝒆", "\\mathbit{f}": "𝒇", "\\mathbit{g}": "𝒈", "\\mathbit{h}": "𝒉", "\\mathbit{i}": "𝒊", "\\mathbit{j}": "𝒋", "\\mathbit{k}": "𝒌", "\\mathbit{l}": "𝒍", "\\mathbit{m}": "𝒎", "\\mathbit{n}": "𝒏", "\\mathbit{o}": "𝒐", "\\mathbit{p}": "𝒑", "\\mathbit{q}": "𝒒", "\\mathbit{r}": "𝒓", "\\mathbit{s}": "𝒔", "\\mathbit{t}": "𝒕", "\\mathbit{u}": "𝒖", "\\mathbit{v}": "𝒗", "\\mathbit{w}": "𝒘", "\\mathbit{x}": "𝒙", "\\mathbit{y}": "𝒚", "\\mathbit{z}": "𝒛", "\\mathcolon": ":", "\\mathcomma": ",", "\\mathdollar": "$", "\\mathexclam": "!", "\\mathfrak{A}": "𝔄", "\\mathfrak{B}": "𝔅", "\\mathfrak{C}": "ℭ", "\\mathfrak{D}": "𝔇", "\\mathfrak{E}": "𝔈", "\\mathfrak{F}": "𝔉", "\\mathfrak{G}": "𝔊", "\\mathfrak{H}": "ℌ", "\\mathfrak{I}": "ℑ", "\\mathfrak{J}": "𝔍", "\\mathfrak{K}": "𝔎", "\\mathfrak{L}": "𝔏", "\\mathfrak{M}": "𝔐", "\\mathfrak{N}": "𝔑", "\\mathfrak{O}": "𝔒", "\\mathfrak{P}": "𝔓", "\\mathfrak{Q}": "𝔔", "\\mathfrak{R}": "ℜ", "\\mathfrak{S}": "𝔖", "\\mathfrak{T}": "𝔗", "\\mathfrak{U}": "𝔘", "\\mathfrak{V}": "𝔙", "\\mathfrak{W}": "𝔚", "\\mathfrak{X}": "𝔛", "\\mathfrak{Y}": "𝔜", "\\mathfrak{Z}": "ℨ", "\\mathfrak{a}": "𝔞", "\\mathfrak{b}": "𝔟", "\\mathfrak{c}": "𝔠", "\\mathfrak{d}": "𝔡", "\\mathfrak{e}": "𝔢", "\\mathfrak{f}": "𝔣", "\\mathfrak{g}": "𝔤", "\\mathfrak{h}": "𝔥", "\\mathfrak{i}": "𝔦", "\\mathfrak{j}": "𝔧", "\\mathfrak{k}": "𝔨", "\\mathfrak{l}": "𝔩", "\\mathfrak{m}": "𝔪", "\\mathfrak{n}": "𝔫", "\\mathfrak{o}": "𝔬", "\\mathfrak{p}": "𝔭", "\\mathfrak{q}": "𝔮", "\\mathfrak{r}": "𝔯", "\\mathfrak{s}": "𝔰", "\\mathfrak{t}": "𝔱", "\\mathfrak{u}": "𝔲", "\\mathfrak{v}": "𝔳", "\\mathfrak{w}": "𝔴", "\\mathfrak{x}": "𝔵", "\\mathfrak{y}": "𝔶", "\\mathfrak{z}": "𝔷", "\\mathhyphen": "‐", "\\mathmit{A}": "𝓐", "\\mathmit{B}": "𝓑", "\\mathmit{C}": "𝓒", "\\mathmit{D}": "𝓓", "\\mathmit{E}": "𝓔", "\\mathmit{F}": "𝓕", "\\mathmit{G}": "𝓖", "\\mathmit{H}": "𝓗", "\\mathmit{I}": "𝓘", "\\mathmit{J}": "𝓙", "\\mathmit{K}": "𝓚", "\\mathmit{L}": "𝓛", "\\mathmit{M}": "𝓜", "\\mathmit{N}": "𝓝", "\\mathmit{O}": "𝓞", "\\mathmit{P}": "𝓟", "\\mathmit{Q}": "𝓠", "\\mathmit{R}": "𝓡", "\\mathmit{S}": "𝓢", "\\mathmit{T}": "𝓣", "\\mathmit{U}": "𝓤", "\\mathmit{V}": "𝓥", "\\mathmit{W}": "𝓦", "\\mathmit{X}": "𝓧", "\\mathmit{Y}": "𝓨", "\\mathmit{Z}": "𝓩", "\\mathmit{a}": "𝓪", "\\mathmit{b}": "𝓫", "\\mathmit{c}": "𝓬", "\\mathmit{d}": "𝓭", "\\mathmit{e}": "𝓮", "\\mathmit{f}": "𝓯", "\\mathmit{g}": "𝓰", "\\mathmit{h}": "𝓱", "\\mathmit{i}": "𝓲", "\\mathmit{j}": "𝓳", "\\mathmit{k}": "𝓴", "\\mathmit{l}": "𝓵", "\\mathmit{m}": "𝓶", "\\mathmit{n}": "𝓷", "\\mathmit{o}": "𝓸", "\\mathmit{p}": "𝓹", "\\mathmit{q}": "𝓺", "\\mathmit{r}": "𝓻", "\\mathmit{s}": "𝓼", "\\mathmit{t}": "𝓽", "\\mathmit{u}": "𝓾", "\\mathmit{v}": "𝓿", "\\mathmit{w}": "𝔀", "\\mathmit{x}": "𝔁", "\\mathmit{y}": "𝔂", "\\mathmit{z}": "𝔃", "\\mathoctothorpe": "#", "\\mathparagraph": "¶", "\\mathpercent": "%", "\\mathperiod": ".", "\\mathplus": "+", "\\mathquestion": "?", "\\mathratio": "∶", "\\mathring": "̊", "\\mathrm{'Y}": "Ύ", "\\mathrm{'\\Omega}": "Ώ", "\\mathrm{\\ddot{I}}": "Ϊ", "\\mathrm{\\ddot{Y}}": "Ϋ", "\\mathscr{A}": "𝒜", "\\mathscr{B}": "ℬ", "\\mathscr{C}": "𝒞", "\\mathscr{D}": "𝒟", "\\mathscr{E}": "ℰ", "\\mathscr{F}": "ℱ", "\\mathscr{G}": "𝒢", "\\mathscr{H}": "ℋ", "\\mathscr{I}": "ℐ", "\\mathscr{J}": "𝒥", "\\mathscr{K}": "𝒦", "\\mathscr{L}": "ℒ", "\\mathscr{M}": "ℳ", "\\mathscr{N}": "𝒩", "\\mathscr{O}": "𝒪", "\\mathscr{P}": "𝒫", "\\mathscr{Q}": "𝒬", "\\mathscr{R}": "ℛ", "\\mathscr{S}": "𝒮", "\\mathscr{T}": "𝒯", "\\mathscr{U}": "𝒰", "\\mathscr{V}": "𝒱", "\\mathscr{W}": "𝒲", "\\mathscr{X}": "𝒳", "\\mathscr{Y}": "𝒴", "\\mathscr{Z}": "𝒵", "\\mathscr{a}": "𝒶", "\\mathscr{b}": "𝒷", "\\mathscr{c}": "𝒸", "\\mathscr{d}": "𝒹", "\\mathscr{e}": "ℯ", "\\mathscr{f}": "𝒻", "\\mathscr{g}": "ℊ", "\\mathscr{h}": "𝒽", "\\mathscr{i}": "𝒾", "\\mathscr{j}": "𝒿", "\\mathscr{k}": "𝓀", "\\mathscr{l}": "𝓁", "\\mathscr{m}": "𝓂", "\\mathscr{n}": "𝓃", "\\mathscr{o}": "ℴ", "\\mathscr{p}": "𝓅", "\\mathscr{q}": "𝓆", "\\mathscr{r}": "𝓇", "\\mathscr{s}": "𝓈", "\\mathscr{t}": "𝓉", "\\mathscr{u}": "𝓊", "\\mathscr{v}": "𝓋", "\\mathscr{w}": "𝓌", "\\mathscr{x}": "𝓍", "\\mathscr{y}": "𝓎", "\\mathscr{z}": "𝓏", "\\mathsection": "§", "\\mathsemicolon": ";", "\\mathsfbfsl{A}": "𝘼", "\\mathsfbfsl{B}": "𝘽", "\\mathsfbfsl{C}": "𝘾", "\\mathsfbfsl{D}": "𝘿", "\\mathsfbfsl{E}": "𝙀", "\\mathsfbfsl{F}": "𝙁", "\\mathsfbfsl{G}": "𝙂", "\\mathsfbfsl{H}": "𝙃", "\\mathsfbfsl{I}": "𝙄", "\\mathsfbfsl{J}": "𝙅", "\\mathsfbfsl{K}": "𝙆", "\\mathsfbfsl{L}": "𝙇", "\\mathsfbfsl{M}": "𝙈", "\\mathsfbfsl{N}": "𝙉", "\\mathsfbfsl{O}": "𝙊", "\\mathsfbfsl{P}": "𝙋", "\\mathsfbfsl{Q}": "𝙌", "\\mathsfbfsl{R}": "𝙍", "\\mathsfbfsl{S}": "𝙎", "\\mathsfbfsl{T}": "𝙏", "\\mathsfbfsl{U}": "𝙐", "\\mathsfbfsl{V}": "𝙑", "\\mathsfbfsl{W}": "𝙒", "\\mathsfbfsl{X}": "𝙓", "\\mathsfbfsl{Y}": "𝙔", "\\mathsfbfsl{Z}": "𝙕", "\\mathsfbfsl{\\Delta}": "𝞓", "\\mathsfbfsl{\\Gamma}": "𝞒", "\\mathsfbfsl{\\Lambda}": "𝞚", "\\mathsfbfsl{\\Omega}": "𝞨", "\\mathsfbfsl{\\Phi}": "𝞥", "\\mathsfbfsl{\\Pi}": "𝞟", "\\mathsfbfsl{\\Psi}": "𝞧", "\\mathsfbfsl{\\Sigma}": "𝞢", "\\mathsfbfsl{\\Theta}": "𝞗", "\\mathsfbfsl{\\Upsilon}": "𝞤", "\\mathsfbfsl{\\Xi}": "𝞝", "\\mathsfbfsl{\\alpha}": "𝞪", "\\mathsfbfsl{\\beta}": "𝞫", "\\mathsfbfsl{\\chi}": "𝟀", "\\mathsfbfsl{\\delta}": "𝞭", "\\mathsfbfsl{\\eta}": "𝞰", "\\mathsfbfsl{\\gamma}": "𝞬", "\\mathsfbfsl{\\imath}": "𝞲", "\\mathsfbfsl{\\kappa}": "𝞳", "\\mathsfbfsl{\\lambda}": "𝞴", "\\mathsfbfsl{\\nabla}": "𝞩", "\\mathsfbfsl{\\omega}": "𝟂", "\\mathsfbfsl{\\phi}": "𝟇", "\\mathsfbfsl{\\pi}": "𝞹", "\\mathsfbfsl{\\psi}": "𝟁", "\\mathsfbfsl{\\rho}": "𝞺", "\\mathsfbfsl{\\sigma}": "𝞼", "\\mathsfbfsl{\\tau}": "𝞽", "\\mathsfbfsl{\\theta}": "𝞱", "\\mathsfbfsl{\\upsilon}": "𝞾", "\\mathsfbfsl{\\varepsilon}": "𝞮", "\\mathsfbfsl{\\varkappa}": "𝟆", "\\mathsfbfsl{\\varphi}": "𝞿", "\\mathsfbfsl{\\varpi}": "𝟉", "\\mathsfbfsl{\\varrho}": "𝟈", "\\mathsfbfsl{\\varsigma}": "𝞻", "\\mathsfbfsl{\\vartheta}": "𝟅", "\\mathsfbfsl{\\xi}": "𝞷", "\\mathsfbfsl{\\zeta}": "𝞯", "\\mathsfbfsl{a}": "𝙖", "\\mathsfbfsl{b}": "𝙗", "\\mathsfbfsl{c}": "𝙘", "\\mathsfbfsl{d}": "𝙙", "\\mathsfbfsl{e}": "𝙚", "\\mathsfbfsl{f}": "𝙛", "\\mathsfbfsl{g}": "𝙜", "\\mathsfbfsl{h}": "𝙝", "\\mathsfbfsl{i}": "𝙞", "\\mathsfbfsl{j}": "𝙟", "\\mathsfbfsl{k}": "𝙠", "\\mathsfbfsl{l}": "𝙡", "\\mathsfbfsl{m}": "𝙢", "\\mathsfbfsl{n}": "𝙣", "\\mathsfbfsl{o}": "𝙤", "\\mathsfbfsl{p}": "𝙥", "\\mathsfbfsl{q}": "𝙦", "\\mathsfbfsl{r}": "𝙧", "\\mathsfbfsl{s}": "𝙨", "\\mathsfbfsl{t}": "𝙩", "\\mathsfbfsl{u}": "𝙪", "\\mathsfbfsl{v}": "𝙫", "\\mathsfbfsl{w}": "𝙬", "\\mathsfbfsl{x}": "𝙭", "\\mathsfbfsl{y}": "𝙮", "\\mathsfbfsl{z}": "𝙯", "\\mathsfbf{0}": "𝟬", "\\mathsfbf{1}": "𝟭", "\\mathsfbf{2}": "𝟮", "\\mathsfbf{3}": "𝟯", "\\mathsfbf{4}": "𝟰", "\\mathsfbf{5}": "𝟱", "\\mathsfbf{6}": "𝟲", "\\mathsfbf{7}": "𝟳", "\\mathsfbf{8}": "𝟴", "\\mathsfbf{9}": "𝟵", "\\mathsfbf{A}": "𝗔", "\\mathsfbf{B}": "𝗕", "\\mathsfbf{C}": "𝗖", "\\mathsfbf{D}": "𝗗", "\\mathsfbf{E}": "𝗘", "\\mathsfbf{F}": "𝗙", "\\mathsfbf{G}": "𝗚", "\\mathsfbf{H}": "𝗛", "\\mathsfbf{I}": "𝗜", "\\mathsfbf{J}": "𝗝", "\\mathsfbf{K}": "𝗞", "\\mathsfbf{L}": "𝗟", "\\mathsfbf{M}": "𝗠", "\\mathsfbf{N}": "𝗡", "\\mathsfbf{O}": "𝗢", "\\mathsfbf{P}": "𝗣", "\\mathsfbf{Q}": "𝗤", "\\mathsfbf{R}": "𝗥", "\\mathsfbf{S}": "𝗦", "\\mathsfbf{T}": "𝗧", "\\mathsfbf{U}": "𝗨", "\\mathsfbf{V}": "𝗩", "\\mathsfbf{W}": "𝗪", "\\mathsfbf{X}": "𝗫", "\\mathsfbf{Y}": "𝗬", "\\mathsfbf{Z}": "𝗭", "\\mathsfbf{\\Delta}": "𝝙", "\\mathsfbf{\\Gamma}": "𝝘", "\\mathsfbf{\\Lambda}": "𝝠", "\\mathsfbf{\\Omega}": "𝝮", "\\mathsfbf{\\Phi}": "𝝫", "\\mathsfbf{\\Pi}": "𝝥", "\\mathsfbf{\\Psi}": "𝝭", "\\mathsfbf{\\Sigma}": "𝝨", "\\mathsfbf{\\Theta}": "𝝝", "\\mathsfbf{\\Upsilon}": "𝝪", "\\mathsfbf{\\Xi}": "𝝣", "\\mathsfbf{\\alpha}": "𝝰", "\\mathsfbf{\\beta}": "𝝱", "\\mathsfbf{\\chi}": "𝞆", "\\mathsfbf{\\delta}": "𝝳", "\\mathsfbf{\\eta}": "𝝶", "\\mathsfbf{\\gamma}": "𝝲", "\\mathsfbf{\\imath}": "𝝸", "\\mathsfbf{\\kappa}": "𝝹", "\\mathsfbf{\\lambda}": "𝝺", "\\mathsfbf{\\nabla}": "𝝯", "\\mathsfbf{\\omega}": "𝞈", "\\mathsfbf{\\phi}": "𝞍", "\\mathsfbf{\\pi}": "𝝿", "\\mathsfbf{\\psi}": "𝞇", "\\mathsfbf{\\rho}": "𝞀", "\\mathsfbf{\\sigma}": "𝞂", "\\mathsfbf{\\tau}": "𝞃", "\\mathsfbf{\\theta}": "𝝷", "\\mathsfbf{\\upsilon}": "𝞄", "\\mathsfbf{\\varepsilon}": "𝝴", "\\mathsfbf{\\varkappa}": "𝞌", "\\mathsfbf{\\varphi}": "𝞅", "\\mathsfbf{\\varpi}": "𝞏", "\\mathsfbf{\\varrho}": "𝞎", "\\mathsfbf{\\varsigma}": "𝞁", "\\mathsfbf{\\vartheta}": "𝞋", "\\mathsfbf{\\xi}": "𝝽", "\\mathsfbf{\\zeta}": "𝝵", "\\mathsfbf{a}": "𝗮", "\\mathsfbf{b}": "𝗯", "\\mathsfbf{c}": "𝗰", "\\mathsfbf{d}": "𝗱", "\\mathsfbf{e}": "𝗲", "\\mathsfbf{f}": "𝗳", "\\mathsfbf{g}": "𝗴", "\\mathsfbf{h}": "𝗵", "\\mathsfbf{i}": "𝗶", "\\mathsfbf{j}": "𝗷", "\\mathsfbf{k}": "𝗸", "\\mathsfbf{l}": "𝗹", "\\mathsfbf{m}": "𝗺", "\\mathsfbf{n}": "𝗻", "\\mathsfbf{o}": "𝗼", "\\mathsfbf{p}": "𝗽", "\\mathsfbf{q}": "𝗾", "\\mathsfbf{r}": "𝗿", "\\mathsfbf{s}": "𝘀", "\\mathsfbf{t}": "𝘁", "\\mathsfbf{u}": "𝘂", "\\mathsfbf{v}": "𝘃", "\\mathsfbf{w}": "𝘄", "\\mathsfbf{x}": "𝘅", "\\mathsfbf{y}": "𝘆", "\\mathsfbf{z}": "𝘇", "\\mathsfsl{A}": "𝘈", "\\mathsfsl{B}": "𝘉", "\\mathsfsl{C}": "𝘊", "\\mathsfsl{D}": "𝘋", "\\mathsfsl{E}": "𝘌", "\\mathsfsl{F}": "𝘍", "\\mathsfsl{G}": "𝘎", "\\mathsfsl{H}": "𝘏", "\\mathsfsl{I}": "𝘐", "\\mathsfsl{J}": "𝘑", "\\mathsfsl{K}": "𝘒", "\\mathsfsl{L}": "𝘓", "\\mathsfsl{M}": "𝘔", "\\mathsfsl{N}": "𝘕", "\\mathsfsl{O}": "𝘖", "\\mathsfsl{P}": "𝘗", "\\mathsfsl{Q}": "𝘘", "\\mathsfsl{R}": "𝘙", "\\mathsfsl{S}": "𝘚", "\\mathsfsl{T}": "𝘛", "\\mathsfsl{U}": "𝘜", "\\mathsfsl{V}": "𝘝", "\\mathsfsl{W}": "𝘞", "\\mathsfsl{X}": "𝘟", "\\mathsfsl{Y}": "𝘠", "\\mathsfsl{Z}": "𝘡", "\\mathsfsl{a}": "𝘢", "\\mathsfsl{b}": "𝘣", "\\mathsfsl{c}": "𝘤", "\\mathsfsl{d}": "𝘥", "\\mathsfsl{e}": "𝘦", "\\mathsfsl{f}": "𝘧", "\\mathsfsl{g}": "𝘨", "\\mathsfsl{h}": "𝘩", "\\mathsfsl{i}": "𝘪", "\\mathsfsl{j}": "𝘫", "\\mathsfsl{k}": "𝘬", "\\mathsfsl{l}": "𝘭", "\\mathsfsl{m}": "𝘮", "\\mathsfsl{n}": "𝘯", "\\mathsfsl{o}": "𝘰", "\\mathsfsl{p}": "𝘱", "\\mathsfsl{q}": "𝘲", "\\mathsfsl{r}": "𝘳", "\\mathsfsl{s}": "𝘴", "\\mathsfsl{t}": "𝘵", "\\mathsfsl{u}": "𝘶", "\\mathsfsl{v}": "𝘷", "\\mathsfsl{w}": "𝘸", "\\mathsfsl{x}": "𝘹", "\\mathsfsl{y}": "𝘺", "\\mathsfsl{z}": "𝘻", "\\mathsf{0}": "𝟢", "\\mathsf{1}": "𝟣", "\\mathsf{2}": "𝟤", "\\mathsf{3}": "𝟥", "\\mathsf{4}": "𝟦", "\\mathsf{5}": "𝟧", "\\mathsf{6}": "𝟨", "\\mathsf{7}": "𝟩", "\\mathsf{8}": "𝟪", "\\mathsf{9}": "𝟫", "\\mathsf{A}": "𝖠", "\\mathsf{B}": "𝖡", "\\mathsf{C}": "𝖢", "\\mathsf{D}": "𝖣", "\\mathsf{E}": "𝖤", "\\mathsf{F}": "𝖥", "\\mathsf{G}": "𝖦", "\\mathsf{H}": "𝖧", "\\mathsf{I}": "𝖨", "\\mathsf{J}": "𝖩", "\\mathsf{K}": "𝖪", "\\mathsf{L}": "𝖫", "\\mathsf{M}": "𝖬", "\\mathsf{N}": "𝖭", "\\mathsf{O}": "𝖮", "\\mathsf{P}": "𝖯", "\\mathsf{Q}": "𝖰", "\\mathsf{R}": "𝖱", "\\mathsf{S}": "𝖲", "\\mathsf{T}": "𝖳", "\\mathsf{U}": "𝖴", "\\mathsf{V}": "𝖵", "\\mathsf{W}": "𝖶", "\\mathsf{X}": "𝖷", "\\mathsf{Y}": "𝖸", "\\mathsf{Z}": "𝖹", "\\mathsf{a}": "𝖺", "\\mathsf{b}": "𝖻", "\\mathsf{c}": "𝖼", "\\mathsf{d}": "𝖽", "\\mathsf{e}": "𝖾", "\\mathsf{f}": "𝖿", "\\mathsf{g}": "𝗀", "\\mathsf{h}": "𝗁", "\\mathsf{i}": "𝗂", "\\mathsf{j}": "𝗃", "\\mathsf{k}": "𝗄", "\\mathsf{l}": "𝗅", "\\mathsf{m}": "𝗆", "\\mathsf{n}": "𝗇", "\\mathsf{o}": "𝗈", "\\mathsf{p}": "𝗉", "\\mathsf{q}": "𝗊", "\\mathsf{r}": "𝗋", "\\mathsf{s}": "𝗌", "\\mathsf{t}": "𝗍", "\\mathsf{u}": "𝗎", "\\mathsf{v}": "𝗏", "\\mathsf{w}": "𝗐", "\\mathsf{x}": "𝗑", "\\mathsf{y}": "𝗒", "\\mathsf{z}": "𝗓", "\\mathslash": "/", "\\mathsterling": "£", "\\mathtt{0}": "𝟶", "\\mathtt{1}": "𝟷", "\\mathtt{2}": "𝟸", "\\mathtt{3}": "𝟹", "\\mathtt{4}": "𝟺", "\\mathtt{5}": "𝟻", "\\mathtt{6}": "𝟼", "\\mathtt{7}": "𝟽", "\\mathtt{8}": "𝟾", "\\mathtt{9}": "𝟿", "\\mathtt{A}": "𝙰", "\\mathtt{B}": "𝙱", "\\mathtt{C}": "𝙲", "\\mathtt{D}": "𝙳", "\\mathtt{E}": "𝙴", "\\mathtt{F}": "𝙵", "\\mathtt{G}": "𝙶", "\\mathtt{H}": "𝙷", "\\mathtt{I}": "𝙸", "\\mathtt{J}": "𝙹", "\\mathtt{K}": "𝙺", "\\mathtt{L}": "𝙻", "\\mathtt{M}": "𝙼", "\\mathtt{N}": "𝙽", "\\mathtt{O}": "𝙾", "\\mathtt{P}": "𝙿", "\\mathtt{Q}": "𝚀", "\\mathtt{R}": "𝚁", "\\mathtt{S}": "𝚂", "\\mathtt{T}": "𝚃", "\\mathtt{U}": "𝚄", "\\mathtt{V}": "𝚅", "\\mathtt{W}": "𝚆", "\\mathtt{X}": "𝚇", "\\mathtt{Y}": "𝚈", "\\mathtt{Z}": "𝚉", "\\mathtt{a}": "𝚊", "\\mathtt{b}": "𝚋", "\\mathtt{c}": "𝚌", "\\mathtt{d}": "𝚍", "\\mathtt{e}": "𝚎", "\\mathtt{f}": "𝚏", "\\mathtt{g}": "𝚐", "\\mathtt{h}": "𝚑", "\\mathtt{i}": "𝚒", "\\mathtt{j}": "𝚓", "\\mathtt{k}": "𝚔", "\\mathtt{l}": "𝚕", "\\mathtt{m}": "𝚖", "\\mathtt{n}": "𝚗", "\\mathtt{o}": "𝚘", "\\mathtt{p}": "𝚙", "\\mathtt{q}": "𝚚", "\\mathtt{r}": "𝚛", "\\mathtt{s}": "𝚜", "\\mathtt{t}": "𝚝", "\\mathtt{u}": "𝚞", "\\mathtt{v}": "𝚟", "\\mathtt{w}": "𝚠", "\\mathtt{x}": "𝚡", "\\mathtt{y}": "𝚢", "\\mathtt{z}": "𝚣", "\\mathunderbar": "̲", "\\mathvisiblespace": "␣", "\\mbfA": "𝐀", "\\mbfAlpha": "𝚨", "\\mbfB": "𝐁", "\\mbfBeta": "𝚩", "\\mbfC": "𝐂", "\\mbfChi": "𝚾", "\\mbfD": "𝐃", "\\mbfDelta": "𝚫", "\\mbfDigamma": "𝟊", "\\mbfE": "𝐄", "\\mbfEpsilon": "𝚬", "\\mbfEta": "𝚮", "\\mbfF": "𝐅", "\\mbfG": "𝐆", "\\mbfGamma": "𝚪", "\\mbfH": "𝐇", "\\mbfI": "𝐈", "\\mbfIota": "𝚰", "\\mbfJ": "𝐉", "\\mbfK": "𝐊", "\\mbfKappa": "𝚱", "\\mbfL": "𝐋", "\\mbfLambda": "𝚲", "\\mbfM": "𝐌", "\\mbfMu": "𝚳", "\\mbfN": "𝐍", "\\mbfNu": "𝚴", "\\mbfO": "𝐎", "\\mbfOmega": "𝛀", "\\mbfOmicron": "𝚶", "\\mbfP": "𝐏", "\\mbfPhi": "𝚽", "\\mbfPi": "𝚷", "\\mbfPsi": "𝚿", "\\mbfQ": "𝐐", "\\mbfR": "𝐑", "\\mbfRho": "𝚸", "\\mbfS": "𝐒", "\\mbfSigma": "𝚺", "\\mbfT": "𝐓", "\\mbfTau": "𝚻", "\\mbfTheta": "𝚯", "\\mbfU": "𝐔", "\\mbfUpsilon": "𝚼", "\\mbfV": "𝐕", "\\mbfW": "𝐖", "\\mbfX": "𝐗", "\\mbfXi": "𝚵", "\\mbfY": "𝐘", "\\mbfZ": "𝐙", "\\mbfZeta": "𝚭", "\\mbfa": "𝐚", "\\mbfalpha": "𝛂", "\\mbfb": "𝐛", "\\mbfbeta": "𝛃", "\\mbfc": "𝐜", "\\mbfchi": "𝛘", "\\mbfd": "𝐝", "\\mbfdelta": "𝛅", "\\mbfdigamma": "𝟋", "\\mbfe": "𝐞", "\\mbfeight": "𝟖", "\\mbfepsilon": "𝛜", "\\mbfeta": "𝛈", "\\mbff": "𝐟", "\\mbffive": "𝟓", "\\mbffour": "𝟒", "\\mbffrakA": "𝕬", "\\mbffrakB": "𝕭", "\\mbffrakC": "𝕮", "\\mbffrakD": "𝕯", "\\mbffrakE": "𝕰", "\\mbffrakF": "𝕱", "\\mbffrakG": "𝕲", "\\mbffrakH": "𝕳", "\\mbffrakI": "𝕴", "\\mbffrakJ": "𝕵", "\\mbffrakK": "𝕶", "\\mbffrakL": "𝕷", "\\mbffrakM": "𝕸", "\\mbffrakN": "𝕹", "\\mbffrakO": "𝕺", "\\mbffrakP": "𝕻", "\\mbffrakQ": "𝕼", "\\mbffrakR": "𝕽", "\\mbffrakS": "𝕾", "\\mbffrakT": "𝕿", "\\mbffrakU": "𝖀", "\\mbffrakV": "𝖁", "\\mbffrakW": "𝖂", "\\mbffrakX": "𝖃", "\\mbffrakY": "𝖄", "\\mbffrakZ": "𝖅", "\\mbffraka": "𝖆", "\\mbffrakb": "𝖇", "\\mbffrakc": "𝖈", "\\mbffrakd": "𝖉", "\\mbffrake": "𝖊", "\\mbffrakf": "𝖋", "\\mbffrakg": "𝖌", "\\mbffrakh": "𝖍", "\\mbffraki": "𝖎", "\\mbffrakj": "𝖏", "\\mbffrakk": "𝖐", "\\mbffrakl": "𝖑", "\\mbffrakm": "𝖒", "\\mbffrakn": "𝖓", "\\mbffrako": "𝖔", "\\mbffrakp": "𝖕", "\\mbffrakq": "𝖖", "\\mbffrakr": "𝖗", "\\mbffraks": "𝖘", "\\mbffrakt": "𝖙", "\\mbffraku": "𝖚", "\\mbffrakv": "𝖛", "\\mbffrakw": "𝖜", "\\mbffrakx": "𝖝", "\\mbffraky": "𝖞", "\\mbffrakz": "𝖟", "\\mbfg": "𝐠", "\\mbfgamma": "𝛄", "\\mbfh": "𝐡", "\\mbfi": "𝐢", "\\mbfiota": "𝛊", "\\mbfitA": "𝑨", "\\mbfitAlpha": "𝜜", "\\mbfitB": "𝑩", "\\mbfitBeta": "𝜝", "\\mbfitC": "𝑪", "\\mbfitChi": "𝜲", "\\mbfitD": "𝑫", "\\mbfitDelta": "𝜟", "\\mbfitE": "𝑬", "\\mbfitEpsilon": "𝜠", "\\mbfitEta": "𝜢", "\\mbfitF": "𝑭", "\\mbfitG": "𝑮", "\\mbfitGamma": "𝜞", "\\mbfitH": "𝑯", "\\mbfitI": "𝑰", "\\mbfitIota": "𝜤", "\\mbfitJ": "𝑱", "\\mbfitK": "𝑲", "\\mbfitKappa": "𝜥", "\\mbfitL": "𝑳", "\\mbfitLambda": "𝜦", "\\mbfitM": "𝑴", "\\mbfitMu": "𝜧", "\\mbfitN": "𝑵", "\\mbfitNu": "𝜨", "\\mbfitO": "𝑶", "\\mbfitOmega": "𝜴", "\\mbfitOmicron": "𝜪", "\\mbfitP": "𝑷", "\\mbfitPhi": "𝜱", "\\mbfitPi": "𝜫", "\\mbfitPsi": "𝜳", "\\mbfitQ": "𝑸", "\\mbfitR": "𝑹", "\\mbfitRho": "𝜬", "\\mbfitS": "𝑺", "\\mbfitSigma": "𝜮", "\\mbfitT": "𝑻", "\\mbfitTau": "𝜯", "\\mbfitTheta": "𝜣", "\\mbfitU": "𝑼", "\\mbfitUpsilon": "𝜰", "\\mbfitV": "𝑽", "\\mbfitW": "𝑾", "\\mbfitX": "𝑿", "\\mbfitXi": "𝜩", "\\mbfitY": "𝒀", "\\mbfitZ": "𝒁", "\\mbfitZeta": "𝜡", "\\mbfita": "𝒂", "\\mbfitalpha": "𝜶", "\\mbfitb": "𝒃", "\\mbfitbeta": "𝜷", "\\mbfitc": "𝒄", "\\mbfitchi": "𝝌", "\\mbfitd": "𝒅", "\\mbfitdelta": "𝜹", "\\mbfite": "𝒆", "\\mbfitepsilon": "𝝐", "\\mbfiteta": "𝜼", "\\mbfitf": "𝒇", "\\mbfitg": "𝒈", "\\mbfitgamma": "𝜸", "\\mbfith": "𝒉", "\\mbfiti": "𝒊", "\\mbfitiota": "𝜾", "\\mbfitj": "𝒋", "\\mbfitk": "𝒌", "\\mbfitkappa": "𝜿", "\\mbfitl": "𝒍", "\\mbfitlambda": "𝝀", "\\mbfitm": "𝒎", "\\mbfitmu": "𝝁", "\\mbfitn": "𝒏", "\\mbfitnabla": "𝜵", "\\mbfitnu": "𝝂", "\\mbfito": "𝒐", "\\mbfitomega": "𝝎", "\\mbfitomicron": "𝝄", "\\mbfitp": "𝒑", "\\mbfitpartial": "𝝏", "\\mbfitphi": "𝝓", "\\mbfitpi": "𝝅", "\\mbfitpsi": "𝝍", "\\mbfitq": "𝒒", "\\mbfitr": "𝒓", "\\mbfitrho": "𝝆", "\\mbfits": "𝒔", "\\mbfitsansA": "𝘼", "\\mbfitsansAlpha": "𝞐", "\\mbfitsansB": "𝘽", "\\mbfitsansBeta": "𝞑", "\\mbfitsansC": "𝘾", "\\mbfitsansChi": "𝞦", "\\mbfitsansD": "𝘿", "\\mbfitsansDelta": "𝞓", "\\mbfitsansE": "𝙀", "\\mbfitsansEpsilon": "𝞔", "\\mbfitsansEta": "𝞖", "\\mbfitsansF": "𝙁", "\\mbfitsansG": "𝙂", "\\mbfitsansGamma": "𝞒", "\\mbfitsansH": "𝙃", "\\mbfitsansI": "𝙄", "\\mbfitsansIota": "𝞘", "\\mbfitsansJ": "𝙅", "\\mbfitsansK": "𝙆", "\\mbfitsansKappa": "𝞙", "\\mbfitsansL": "𝙇", "\\mbfitsansLambda": "𝞚", "\\mbfitsansM": "𝙈", "\\mbfitsansMu": "𝞛", "\\mbfitsansN": "𝙉", "\\mbfitsansNu": "𝞜", "\\mbfitsansO": "𝙊", "\\mbfitsansOmega": "𝞨", "\\mbfitsansOmicron": "𝞞", "\\mbfitsansP": "𝙋", "\\mbfitsansPhi": "𝞥", "\\mbfitsansPi": "𝞟", "\\mbfitsansPsi": "𝞧", "\\mbfitsansQ": "𝙌", "\\mbfitsansR": "𝙍", "\\mbfitsansRho": "𝞠", "\\mbfitsansS": "𝙎", "\\mbfitsansSigma": "𝞢", "\\mbfitsansT": "𝙏", "\\mbfitsansTau": "𝞣", "\\mbfitsansTheta": "𝞗", "\\mbfitsansU": "𝙐", "\\mbfitsansUpsilon": "𝞤", "\\mbfitsansV": "𝙑", "\\mbfitsansW": "𝙒", "\\mbfitsansX": "𝙓", "\\mbfitsansXi": "𝞝", "\\mbfitsansY": "𝙔", "\\mbfitsansZ": "𝙕", "\\mbfitsansZeta": "𝞕", "\\mbfitsansa": "𝙖", "\\mbfitsansalpha": "𝞪", "\\mbfitsansb": "𝙗", "\\mbfitsansbeta": "𝞫", "\\mbfitsansc": "𝙘", "\\mbfitsanschi": "𝟀", "\\mbfitsansd": "𝙙", "\\mbfitsansdelta": "𝞭", "\\mbfitsanse": "𝙚", "\\mbfitsansepsilon": "𝟄", "\\mbfitsanseta": "𝞰", "\\mbfitsansf": "𝙛", "\\mbfitsansg": "𝙜", "\\mbfitsansgamma": "𝞬", "\\mbfitsansh": "𝙝", "\\mbfitsansi": "𝙞", "\\mbfitsansiota": "𝞲", "\\mbfitsansj": "𝙟", "\\mbfitsansk": "𝙠", "\\mbfitsanskappa": "𝞳", "\\mbfitsansl": "𝙡", "\\mbfitsanslambda": "𝞴", "\\mbfitsansm": "𝙢", "\\mbfitsansmu": "𝞵", "\\mbfitsansn": "𝙣", "\\mbfitsansnabla": "𝞩", "\\mbfitsansnu": "𝞶", "\\mbfitsanso": "𝙤", "\\mbfitsansomega": "𝟂", "\\mbfitsansomicron": "𝞸", "\\mbfitsansp": "𝙥", "\\mbfitsanspartial": "𝟃", "\\mbfitsansphi": "𝟇", "\\mbfitsanspi": "𝞹", "\\mbfitsanspsi": "𝟁", "\\mbfitsansq": "𝙦", "\\mbfitsansr": "𝙧", "\\mbfitsansrho": "𝞺", "\\mbfitsanss": "𝙨", "\\mbfitsanssigma": "𝞼", "\\mbfitsanst": "𝙩", "\\mbfitsanstau": "𝞽", "\\mbfitsanstheta": "𝞱", "\\mbfitsansu": "𝙪", "\\mbfitsansupsilon": "𝞾", "\\mbfitsansv": "𝙫", "\\mbfitsansvarTheta": "𝞡", "\\mbfitsansvarepsilon": "𝞮", "\\mbfitsansvarkappa": "𝟆", "\\mbfitsansvarphi": "𝞿", "\\mbfitsansvarpi": "𝟉", "\\mbfitsansvarrho": "𝟈", "\\mbfitsansvarsigma": "𝞻", "\\mbfitsansvartheta": "𝟅", "\\mbfitsansw": "𝙬", "\\mbfitsansx": "𝙭", "\\mbfitsansxi": "𝞷", "\\mbfitsansy": "𝙮", "\\mbfitsansz": "𝙯", "\\mbfitsanszeta": "𝞯", "\\mbfitsigma": "𝝈", "\\mbfitt": "𝒕", "\\mbfittau": "𝝉", "\\mbfittheta": "𝜽", "\\mbfitu": "𝒖", "\\mbfitupsilon": "𝝊", "\\mbfitv": "𝒗", "\\mbfitvarTheta": "𝜭", "\\mbfitvarepsilon": "𝜺", "\\mbfitvarkappa": "𝝒", "\\mbfitvarphi": "𝝋", "\\mbfitvarpi": "𝝕", "\\mbfitvarrho": "𝝔", "\\mbfitvarsigma": "𝝇", "\\mbfitvartheta": "𝝑", "\\mbfitw": "𝒘", "\\mbfitx": "𝒙", "\\mbfitxi": "𝝃", "\\mbfity": "𝒚", "\\mbfitz": "𝒛", "\\mbfitzeta": "𝜻", "\\mbfj": "𝐣", "\\mbfk": "𝐤", "\\mbfkappa": "𝛋", "\\mbfl": "𝐥", "\\mbflambda": "𝛌", "\\mbfm": "𝐦", "\\mbfmu": "𝛍", "\\mbfn": "𝐧", "\\mbfnabla": "𝛁", "\\mbfnine": "𝟗", "\\mbfnu": "𝛎", "\\mbfo": "𝐨", "\\mbfomega": "𝛚", "\\mbfomicron": "𝛐", "\\mbfone": "𝟏", "\\mbfp": "𝐩", "\\mbfpartial": "𝛛", "\\mbfphi": "𝛟", "\\mbfpi": "𝛑", "\\mbfpsi": "𝛙", "\\mbfq": "𝐪", "\\mbfr": "𝐫", "\\mbfrho": "𝛒", "\\mbfs": "𝐬", "\\mbfsansA": "𝗔", "\\mbfsansAlpha": "𝝖", "\\mbfsansB": "𝗕", "\\mbfsansBeta": "𝝗", "\\mbfsansC": "𝗖", "\\mbfsansChi": "𝝬", "\\mbfsansD": "𝗗", "\\mbfsansDelta": "𝝙", "\\mbfsansE": "𝗘", "\\mbfsansEpsilon": "𝝚", "\\mbfsansEta": "𝝜", "\\mbfsansF": "𝗙", "\\mbfsansG": "𝗚", "\\mbfsansGamma": "𝝘", "\\mbfsansH": "𝗛", "\\mbfsansI": "𝗜", "\\mbfsansIota": "𝝞", "\\mbfsansJ": "𝗝", "\\mbfsansK": "𝗞", "\\mbfsansKappa": "𝝟", "\\mbfsansL": "𝗟", "\\mbfsansLambda": "𝝠", "\\mbfsansM": "𝗠", "\\mbfsansMu": "𝝡", "\\mbfsansN": "𝗡", "\\mbfsansNu": "𝝢", "\\mbfsansO": "𝗢", "\\mbfsansOmega": "𝝮", "\\mbfsansOmicron": "𝝤", "\\mbfsansP": "𝗣", "\\mbfsansPhi": "𝝫", "\\mbfsansPi": "𝝥", "\\mbfsansPsi": "𝝭", "\\mbfsansQ": "𝗤", "\\mbfsansR": "𝗥", "\\mbfsansRho": "𝝦", "\\mbfsansS": "𝗦", "\\mbfsansSigma": "𝝨", "\\mbfsansT": "𝗧", "\\mbfsansTau": "𝝩", "\\mbfsansTheta": "𝝝", "\\mbfsansU": "𝗨", "\\mbfsansUpsilon": "𝝪", "\\mbfsansV": "𝗩", "\\mbfsansW": "𝗪", "\\mbfsansX": "𝗫", "\\mbfsansXi": "𝝣", "\\mbfsansY": "𝗬", "\\mbfsansZ": "𝗭", "\\mbfsansZeta": "𝝛", "\\mbfsansa": "𝗮", "\\mbfsansalpha": "𝝰", "\\mbfsansb": "𝗯", "\\mbfsansbeta": "𝝱", "\\mbfsansc": "𝗰", "\\mbfsanschi": "𝞆", "\\mbfsansd": "𝗱", "\\mbfsansdelta": "𝝳", "\\mbfsanse": "𝗲", "\\mbfsanseight": "𝟴", "\\mbfsansepsilon": "𝞊", "\\mbfsanseta": "𝝶", "\\mbfsansf": "𝗳", "\\mbfsansfive": "𝟱", "\\mbfsansfour": "𝟰", "\\mbfsansg": "𝗴", "\\mbfsansgamma": "𝝲", "\\mbfsansh": "𝗵", "\\mbfsansi": "𝗶", "\\mbfsansiota": "𝝸", "\\mbfsansj": "𝗷", "\\mbfsansk": "𝗸", "\\mbfsanskappa": "𝝹", "\\mbfsansl": "𝗹", "\\mbfsanslambda": "𝝺", "\\mbfsansm": "𝗺", "\\mbfsansmu": "𝝻", "\\mbfsansn": "𝗻", "\\mbfsansnabla": "𝝯", "\\mbfsansnine": "𝟵", "\\mbfsansnu": "𝝼", "\\mbfsanso": "𝗼", "\\mbfsansomega": "𝞈", "\\mbfsansomicron": "𝝾", "\\mbfsansone": "𝟭", "\\mbfsansp": "𝗽", "\\mbfsanspartial": "𝞉", "\\mbfsansphi": "𝞍", "\\mbfsanspi": "𝝿", "\\mbfsanspsi": "𝞇", "\\mbfsansq": "𝗾", "\\mbfsansr": "𝗿", "\\mbfsansrho": "𝞀", "\\mbfsanss": "𝘀", "\\mbfsansseven": "𝟳", "\\mbfsanssigma": "𝞂", "\\mbfsanssix": "𝟲", "\\mbfsanst": "𝘁", "\\mbfsanstau": "𝞃", "\\mbfsanstheta": "𝝷", "\\mbfsansthree": "𝟯", "\\mbfsanstwo": "𝟮", "\\mbfsansu": "𝘂", "\\mbfsansupsilon": "𝞄", "\\mbfsansv": "𝘃", "\\mbfsansvarTheta": "𝝧", "\\mbfsansvarepsilon": "𝝴", "\\mbfsansvarkappa": "𝞌", "\\mbfsansvarphi": "𝞅", "\\mbfsansvarpi": "𝞏", "\\mbfsansvarrho": "𝞎", "\\mbfsansvarsigma": "𝞁", "\\mbfsansvartheta": "𝞋", "\\mbfsansw": "𝘄", "\\mbfsansx": "𝘅", "\\mbfsansxi": "𝝽", "\\mbfsansy": "𝘆", "\\mbfsansz": "𝘇", "\\mbfsanszero": "𝟬", "\\mbfsanszeta": "𝝵", "\\mbfscrA": "𝓐", "\\mbfscrB": "𝓑", "\\mbfscrC": "𝓒", "\\mbfscrD": "𝓓", "\\mbfscrE": "𝓔", "\\mbfscrF": "𝓕", "\\mbfscrG": "𝓖", "\\mbfscrH": "𝓗", "\\mbfscrI": "𝓘", "\\mbfscrJ": "𝓙", "\\mbfscrK": "𝓚", "\\mbfscrL": "𝓛", "\\mbfscrM": "𝓜", "\\mbfscrN": "𝓝", "\\mbfscrO": "𝓞", "\\mbfscrP": "𝓟", "\\mbfscrQ": "𝓠", "\\mbfscrR": "𝓡", "\\mbfscrS": "𝓢", "\\mbfscrT": "𝓣", "\\mbfscrU": "𝓤", "\\mbfscrV": "𝓥", "\\mbfscrW": "𝓦", "\\mbfscrX": "𝓧", "\\mbfscrY": "𝓨", "\\mbfscrZ": "𝓩", "\\mbfscra": "𝓪", "\\mbfscrb": "𝓫", "\\mbfscrc": "𝓬", "\\mbfscrd": "𝓭", "\\mbfscre": "𝓮", "\\mbfscrf": "𝓯", "\\mbfscrg": "𝓰", "\\mbfscrh": "𝓱", "\\mbfscri": "𝓲", "\\mbfscrj": "𝓳", "\\mbfscrk": "𝓴", "\\mbfscrl": "𝓵", "\\mbfscrm": "𝓶", "\\mbfscrn": "𝓷", "\\mbfscro": "𝓸", "\\mbfscrp": "𝓹", "\\mbfscrq": "𝓺", "\\mbfscrr": "𝓻", "\\mbfscrs": "𝓼", "\\mbfscrt": "𝓽", "\\mbfscru": "𝓾", "\\mbfscrv": "𝓿", "\\mbfscrw": "𝔀", "\\mbfscrx": "𝔁", "\\mbfscry": "𝔂", "\\mbfscrz": "𝔃", "\\mbfseven": "𝟕", "\\mbfsigma": "𝛔", "\\mbfsix": "𝟔", "\\mbft": "𝐭", "\\mbftau": "𝛕", "\\mbftheta": "𝛉", "\\mbfthree": "𝟑", "\\mbftwo": "𝟐", "\\mbfu": "𝐮", "\\mbfupsilon": "𝛖", "\\mbfv": "𝐯", "\\mbfvarTheta": "𝚹", "\\mbfvarepsilon": "𝛆", "\\mbfvarkappa": "𝛞", "\\mbfvarphi": "𝛗", "\\mbfvarpi": "𝛡", "\\mbfvarrho": "𝛠", "\\mbfvarsigma": "𝛓", "\\mbfvartheta": "𝛝", "\\mbfw": "𝐰", "\\mbfx": "𝐱", "\\mbfxi": "𝛏", "\\mbfy": "𝐲", "\\mbfz": "𝐳", "\\mbfzero": "𝟎", "\\mbfzeta": "𝛇", "\\mdblkcircle": "⚫", "\\mdblkdiamond": "⬥", "\\mdblklozenge": "⬧", "\\mdblksquare": "◼", "\\mdlgblkcircle": "●", "\\mdlgblkdiamond": "◆", "\\mdlgblklozenge": "⧫", "\\mdlgblksquare": "■", "\\mdlgwhtcircle": "○", "\\mdlgwhtdiamond": "◇", "\\mdlgwhtlozenge": "◊", "\\mdlgwhtsquare": "□", "\\mdsmblkcircle": "⦁", "\\mdsmblksquare": "◾", "\\mdsmwhtcircle": "⚬", "\\mdsmwhtsquare": "◽", "\\mdwhtcircle": "⚪", "\\mdwhtdiamond": "⬦", "\\mdwhtlozenge": "⬨", "\\mdwhtsquare": "◻", "\\measangledltosw": "⦯", "\\measangledrtose": "⦮", "\\measangleldtosw": "⦫", "\\measanglelutonw": "⦩", "\\measanglerdtose": "⦪", "\\measanglerutone": "⦨", "\\measangleultonw": "⦭", "\\measangleurtone": "⦬", "\\measeq": "≞", "\\measuredangle": "∡", "\\measuredangleleft": "⦛", "\\measuredrightangle": "⊾", "\\medblackstar": "⭑", "\\medbullet": "⚫", "\\medcirc": "⚪", "\\medspace": " ", "\\medwhitestar": "⭐", "\\mercury": "☿", "\\mfrakA": "𝔄", "\\mfrakB": "𝔅", "\\mfrakC": "ℭ", "\\mfrakD": "𝔇", "\\mfrakE": "𝔈", "\\mfrakF": "𝔉", "\\mfrakG": "𝔊", "\\mfrakH": "ℌ", "\\mfrakJ": "𝔍", "\\mfrakK": "𝔎", "\\mfrakL": "𝔏", "\\mfrakM": "𝔐", "\\mfrakN": "𝔑", "\\mfrakO": "𝔒", "\\mfrakP": "𝔓", "\\mfrakQ": "𝔔", "\\mfrakS": "𝔖", "\\mfrakT": "𝔗", "\\mfrakU": "𝔘", "\\mfrakV": "𝔙", "\\mfrakW": "𝔚", "\\mfrakX": "𝔛", "\\mfrakY": "𝔜", "\\mfrakZ": "ℨ", "\\mfraka": "𝔞", "\\mfrakb": "𝔟", "\\mfrakc": "𝔠", "\\mfrakd": "𝔡", "\\mfrake": "𝔢", "\\mfrakf": "𝔣", "\\mfrakg": "𝔤", "\\mfrakh": "𝔥", "\\mfraki": "𝔦", "\\mfrakj": "𝔧", "\\mfrakk": "𝔨", "\\mfrakl": "𝔩", "\\mfrakm": "𝔪", "\\mfrakn": "𝔫", "\\mfrako": "𝔬", "\\mfrakp": "𝔭", "\\mfrakq": "𝔮", "\\mfrakr": "𝔯", "\\mfraks": "𝔰", "\\mfrakt": "𝔱", "\\mfraku": "𝔲", "\\mfrakv": "𝔳", "\\mfrakw": "𝔴", "\\mfrakx": "𝔵", "\\mfraky": "𝔶", "\\mfrakz": "𝔷", "\\mho": "℧", "\\mid": "∣", "\\midbarvee": "⩝", "\\midbarwedge": "⩜", "\\midcir": "⫰", "\\minus": "−", "\\minusdot": "⨪", "\\minusfdots": "⨫", "\\minusrdots": "⨬", "\\mitA": "𝐴", "\\mitAlpha": "𝛢", "\\mitB": "𝐵", "\\mitBbbD": "ⅅ", "\\mitBbbd": "ⅆ", "\\mitBbbe": "ⅇ", "\\mitBbbi": "ⅈ", "\\mitBbbj": "ⅉ", "\\mitBeta": "𝛣", "\\mitC": "𝐶", "\\mitChi": "𝛸", "\\mitD": "𝐷", "\\mitDelta": "𝛥", "\\mitE": "𝐸", "\\mitEpsilon": "𝛦", "\\mitEta": "𝛨", "\\mitF": "𝐹", "\\mitG": "𝐺", "\\mitGamma": "𝛤", "\\mitH": "𝐻", "\\mitI": "𝐼", "\\mitIota": "𝛪", "\\mitJ": "𝐽", "\\mitK": "𝐾", "\\mitKappa": "𝛫", "\\mitL": "𝐿", "\\mitLambda": "𝛬", "\\mitM": "𝑀", "\\mitMu": "𝛭", "\\mitN": "𝑁", "\\mitNu": "𝛮", "\\mitO": "𝑂", "\\mitOmega": "𝛺", "\\mitOmicron": "𝛰", "\\mitP": "𝑃", "\\mitPhi": "𝛷", "\\mitPi": "𝛱", "\\mitPsi": "𝛹", "\\mitQ": "𝑄", "\\mitR": "𝑅", "\\mitRho": "𝛲", "\\mitS": "𝑆", "\\mitSigma": "𝛴", "\\mitT": "𝑇", "\\mitTau": "𝛵", "\\mitTheta": "𝛩", "\\mitU": "𝑈", "\\mitUpsilon": "𝛶", "\\mitV": "𝑉", "\\mitW": "𝑊", "\\mitX": "𝑋", "\\mitXi": "𝛯", "\\mitY": "𝑌", "\\mitZ": "𝑍", "\\mitZeta": "𝛧", "\\mita": "𝑎", "\\mitalpha": "𝛼", "\\mitb": "𝑏", "\\mitbeta": "𝛽", "\\mitc": "𝑐", "\\mitchi": "𝜒", "\\mitd": "𝑑", "\\mitdelta": "𝛿", "\\mite": "𝑒", "\\mitepsilon": "𝜖", "\\miteta": "𝜂", "\\mitf": "𝑓", "\\mitg": "𝑔", "\\mitgamma": "𝛾", "\\miti": "𝑖", "\\mitiota": "𝜄", "\\mitj": "𝑗", "\\mitk": "𝑘", "\\mitkappa": "𝜅", "\\mitl": "𝑙", "\\mitlambda": "𝜆", "\\mitm": "𝑚", "\\mitmu": "𝜇", "\\mitn": "𝑛", "\\mitnabla": "𝛻", "\\mitnu": "𝜈", "\\mito": "𝑜", "\\mitomega": "𝜔", "\\mitomicron": "𝜊", "\\mitp": "𝑝", "\\mitpartial": "𝜕", "\\mitphi": "𝜙", "\\mitpi": "𝜋", "\\mitpsi": "𝜓", "\\mitq": "𝑞", "\\mitr": "𝑟", "\\mitrho": "𝜌", "\\mits": "𝑠", "\\mitsansA": "𝘈", "\\mitsansB": "𝘉", "\\mitsansC": "𝘊", "\\mitsansD": "𝘋", "\\mitsansE": "𝘌", "\\mitsansF": "𝘍", "\\mitsansG": "𝘎", "\\mitsansH": "𝘏", "\\mitsansI": "𝘐", "\\mitsansJ": "𝘑", "\\mitsansK": "𝘒", "\\mitsansL": "𝘓", "\\mitsansM": "𝘔", "\\mitsansN": "𝘕", "\\mitsansO": "𝘖", "\\mitsansP": "𝘗", "\\mitsansQ": "𝘘", "\\mitsansR": "𝘙", "\\mitsansS": "𝘚", "\\mitsansT": "𝘛", "\\mitsansU": "𝘜", "\\mitsansV": "𝘝", "\\mitsansW": "𝘞", "\\mitsansX": "𝘟", "\\mitsansY": "𝘠", "\\mitsansZ": "𝘡", "\\mitsansa": "𝘢", "\\mitsansb": "𝘣", "\\mitsansc": "𝘤", "\\mitsansd": "𝘥", "\\mitsanse": "𝘦", "\\mitsansf": "𝘧", "\\mitsansg": "𝘨", "\\mitsansh": "𝘩", "\\mitsansi": "𝘪", "\\mitsansj": "𝘫", "\\mitsansk": "𝘬", "\\mitsansl": "𝘭", "\\mitsansm": "𝘮", "\\mitsansn": "𝘯", "\\mitsanso": "𝘰", "\\mitsansp": "𝘱", "\\mitsansq": "𝘲", "\\mitsansr": "𝘳", "\\mitsanss": "𝘴", "\\mitsanst": "𝘵", "\\mitsansu": "𝘶", "\\mitsansv": "𝘷", "\\mitsansw": "𝘸", "\\mitsansx": "𝘹", "\\mitsansy": "𝘺", "\\mitsansz": "𝘻", "\\mitsigma": "𝜎", "\\mitt": "𝑡", "\\mittau": "𝜏", "\\mittheta": "𝜃", "\\mitu": "𝑢", "\\mitupsilon": "𝜐", "\\mitv": "𝑣", "\\mitvarTheta": "𝛳", "\\mitvarepsilon": "𝜀", "\\mitvarkappa": "𝜘", "\\mitvarphi": "𝜑", "\\mitvarpi": "𝜛", "\\mitvarrho": "𝜚", "\\mitvarsigma": "𝜍", "\\mitvartheta": "𝜗", "\\mitw": "𝑤", "\\mitx": "𝑥", "\\mitxi": "𝜉", "\\mity": "𝑦", "\\mitz": "𝑧", "\\mitzeta": "𝜁", "\\mkern1mu": " ", "\\mlcp": "⫛", "\\models": "⊧", "\\modtwosum": "⨊", "\\mp": "∓", "\\msansA": "𝖠", "\\msansB": "𝖡", "\\msansC": "𝖢", "\\msansD": "𝖣", "\\msansE": "𝖤", "\\msansF": "𝖥", "\\msansG": "𝖦", "\\msansH": "𝖧", "\\msansI": "𝖨", "\\msansJ": "𝖩", "\\msansK": "𝖪", "\\msansL": "𝖫", "\\msansM": "𝖬", "\\msansN": "𝖭", "\\msansO": "𝖮", "\\msansP": "𝖯", "\\msansQ": "𝖰", "\\msansR": "𝖱", "\\msansS": "𝖲", "\\msansT": "𝖳", "\\msansU": "𝖴", "\\msansV": "𝖵", "\\msansW": "𝖶", "\\msansX": "𝖷", "\\msansY": "𝖸", "\\msansZ": "𝖹", "\\msansa": "𝖺", "\\msansb": "𝖻", "\\msansc": "𝖼", "\\msansd": "𝖽", "\\msanse": "𝖾", "\\msanseight": "𝟪", "\\msansf": "𝖿", "\\msansfive": "𝟧", "\\msansfour": "𝟦", "\\msansg": "𝗀", "\\msansh": "𝗁", "\\msansi": "𝗂", "\\msansj": "𝗃", "\\msansk": "𝗄", "\\msansl": "𝗅", "\\msansm": "𝗆", "\\msansn": "𝗇", "\\msansnine": "𝟫", "\\msanso": "𝗈", "\\msansone": "𝟣", "\\msansp": "𝗉", "\\msansq": "𝗊", "\\msansr": "𝗋", "\\msanss": "𝗌", "\\msansseven": "𝟩", "\\msanssix": "𝟨", "\\msanst": "𝗍", "\\msansthree": "𝟥", "\\msanstwo": "𝟤", "\\msansu": "𝗎", "\\msansv": "𝗏", "\\msansw": "𝗐", "\\msansx": "𝗑", "\\msansy": "𝗒", "\\msansz": "𝗓", "\\msanszero": "𝟢", "\\mscrA": "𝒜", "\\mscrB": "ℬ", "\\mscrC": "𝒞", "\\mscrD": "𝒟", "\\mscrE": "ℰ", "\\mscrF": "ℱ", "\\mscrG": "𝒢", "\\mscrH": "ℋ", "\\mscrI": "ℐ", "\\mscrJ": "𝒥", "\\mscrK": "𝒦", "\\mscrL": "ℒ", "\\mscrM": "ℳ", "\\mscrN": "𝒩", "\\mscrO": "𝒪", "\\mscrP": "𝒫", "\\mscrQ": "𝒬", "\\mscrR": "ℛ", "\\mscrS": "𝒮", "\\mscrT": "𝒯", "\\mscrU": "𝒰", "\\mscrV": "𝒱", "\\mscrW": "𝒲", "\\mscrX": "𝒳", "\\mscrY": "𝒴", "\\mscrZ": "𝒵", "\\mscra": "𝒶", "\\mscrb": "𝒷", "\\mscrc": "𝒸", "\\mscrd": "𝒹", "\\mscre": "ℯ", "\\mscrf": "𝒻", "\\mscrg": "ℊ", "\\mscrh": "𝒽", "\\mscri": "𝒾", "\\mscrj": "𝒿", "\\mscrk": "𝓀", "\\mscrl": "𝓁", "\\mscrm": "𝓂", "\\mscrn": "𝓃", "\\mscro": "ℴ", "\\mscrp": "𝓅", "\\mscrq": "𝓆", "\\mscrr": "𝓇", "\\mscrs": "𝓈", "\\mscrt": "𝓉", "\\mscru": "𝓊", "\\mscrv": "𝓋", "\\mscrw": "𝓌", "\\mscrx": "𝓍", "\\mscry": "𝓎", "\\mscrz": "𝓏", "\\mttA": "𝙰", "\\mttB": "𝙱", "\\mttC": "𝙲", "\\mttD": "𝙳", "\\mttE": "𝙴", "\\mttF": "𝙵", "\\mttG": "𝙶", "\\mttH": "𝙷", "\\mttI": "𝙸", "\\mttJ": "𝙹", "\\mttK": "𝙺", "\\mttL": "𝙻", "\\mttM": "𝙼", "\\mttN": "𝙽", "\\mttO": "𝙾", "\\mttP": "𝙿", "\\mttQ": "𝚀", "\\mttR": "𝚁", "\\mttS": "𝚂", "\\mttT": "𝚃", "\\mttU": "𝚄", "\\mttV": "𝚅", "\\mttW": "𝚆", "\\mttX": "𝚇", "\\mttY": "𝚈", "\\mttZ": "𝚉", "\\mtta": "𝚊", "\\mttb": "𝚋", "\\mttc": "𝚌", "\\mttd": "𝚍", "\\mtte": "𝚎", "\\mtteight": "𝟾", "\\mttf": "𝚏", "\\mttfive": "𝟻", "\\mttfour": "𝟺", "\\mttg": "𝚐", "\\mtth": "𝚑", "\\mtti": "𝚒", "\\mttj": "𝚓", "\\mttk": "𝚔", "\\mttl": "𝚕", "\\mttm": "𝚖", "\\mttn": "𝚗", "\\mttnine": "𝟿", "\\mtto": "𝚘", "\\mttone": "𝟷", "\\mttp": "𝚙", "\\mttq": "𝚚", "\\mttr": "𝚛", "\\mtts": "𝚜", "\\mttseven": "𝟽", "\\mttsix": "𝟼", "\\mttt": "𝚝", "\\mttthree": "𝟹", "\\mtttwo": "𝟸", "\\mttu": "𝚞", "\\mttv": "𝚟", "\\mttw": "𝚠", "\\mttx": "𝚡", "\\mtty": "𝚢", "\\mttz": "𝚣", "\\mttzero": "𝟶", "\\mu": "𝜇", "\\multimap": "⊸", "\\multimapboth": "⧟", "\\multimapinv": "⟜", "\\mupAlpha": "Α", "\\mupBeta": "Β", "\\mupChi": "Χ", "\\mupDelta": "Δ", "\\mupEpsilon": "Ε", "\\mupEta": "Η", "\\mupGamma": "Γ", "\\mupIota": "Ι", "\\mupKappa": "Κ", "\\mupLambda": "Λ", "\\mupMu": "Μ", "\\mupNu": "Ν", "\\mupOmega": "Ω", "\\mupOmicron": "Ο", "\\mupPhi": "Φ", "\\mupPi": "Π", "\\mupPsi": "Ψ", "\\mupRho": "Ρ", "\\mupSigma": "Σ", "\\mupTau": "Τ", "\\mupTheta": "Θ", "\\mupUpsilon": "Υ", "\\mupXi": "Ξ", "\\mupZeta": "Ζ", "\\mupalpha": "α", "\\mupbeta": "β", "\\mupchi": "χ", "\\mupdelta": "δ", "\\mupepsilon": "ϵ", "\\mupeta": "η", "\\mupgamma": "γ", "\\mupiota": "ι", "\\mupkappa": "κ", "\\muplambda": "λ", "\\mupmu": "μ", "\\mupnu": "ν", "\\mupomega": "ω", "\\mupomicron": "ο", "\\mupphi": "ϕ", "\\muppi": "π", "\\muppsi": "ψ", "\\muprho": "ρ", "\\mupsigma": "σ", "\\muptau": "τ", "\\muptheta": "θ", "\\mupupsilon": "υ", "\\mupvarTheta": "ϴ", "\\mupvarepsilon": "ε", "\\mupvarkappa": "ϰ", "\\mupvarphi": "φ", "\\mupvarpi": "ϖ", "\\mupvarrho": "ϱ", "\\mupvarsigma": "ς", "\\mupvartheta": "ϑ", "\\mupxi": "ξ", "\\mupzeta": "ζ", "\\m{e}": "ε", "\\nHdownarrow": "⇟", "\\nHuparrow": "⇞", "\\nLeftarrow": "⇍", "\\nLeftrightarrow": "⇎", "\\nRightarrow": "⇏", "\\nVDash": "⊯", "\\nVdash": "⊮", "\\nVleftarrow": "⇺", "\\nVleftarrowtail": "⬺", "\\nVleftrightarrow": "⇼", "\\nVrightarrow": "⇻", "\\nVrightarrowtail": "⤕", "\\nVtwoheadleftarrow": "⬵", "\\nVtwoheadleftarrowtail": "⬽", "\\nVtwoheadrightarrow": "⤁", "\\nVtwoheadrightarrowtail": "⤘", "\\nabla": "𝛻", "\\napprox": "≉", "\\nasymp": "≭", "\\natural": "♮", "\\ncong": "≇", "\\ne": "≠", "\\nearrow": "↗", "\\neg": "¬", "\\neovnwarrow": "⤱", "\\neovsearrow": "⤮", "\\neptune": "♆", "\\neq": "≠", "\\nequiv": "≢", "\\neswarrow": "⤢", "\\neuter": "⚲", "\\nexists": "∄", "\\ng": "ŋ", "\\ngeq": "≱", "\\ngeqslant": "⩾̸", "\\ngtr": "≯", "\\ngtrless": "≹", "\\ngtrsim": "≵", "\\nhVvert": "⫵", "\\nhpar": "⫲", "\\ni": "∋", "\\niobar": "⋾", "\\nis": "⋼", "\\nisd": "⋺", "\\nleftarrow": "↚", "\\nleftrightarrow": "↮", "\\nleq": "≰", "\\nleqslant": "⩽̸", "\\nless": "≮", "\\nlessgtr": "≸", "\\nlesssim": "≴", "\\nmid": "∤", "\\nni": "∌", "\\nobreakspace": " ", "\\nolinebreak": "⁠", "\\not": "̸", "\\not<": "≮", "\\not>": "≯", "\\not\\apid": "≋̸", "\\not\\approx": "≉", "\\not\\cong": "≇", "\\not\\doteq": "≐̸", "\\not\\equiv": "≢", "\\not\\geq": "≱", "\\not\\in": "∉", "\\not\\leq": "≰", "\\not\\ni": "∌", "\\not\\prec": "⊀", "\\not\\preceq": "⪯̸", "\\not\\sim": "≁", "\\not\\simeq": "≄", "\\not\\sqsubseteq": "⋢", "\\not\\sqsupseteq": "⋣", "\\not\\subset": "⊄", "\\not\\subseteq": "⊈", "\\not\\succ": "⊁", "\\not\\succeq": "⪰̸", "\\not\\supset": "⊅", "\\not\\supseteq": "⊉", "\\notaccent": "̸", "\\notbackslash": "⍀", "\\notgreaterless": "≹", "\\notin": "∉", "\\notlessgreater": "≸", "\\notslash": "⌿", "\\nparallel": "∦", "\\npolint": "⨔", "\\nprec": "⊀", "\\npreccurlyeq": "⋠", "\\npreceq": "⋠", "\\nrightarrow": "↛", "\\nsim": "≁", "\\nsime": "≄", "\\nsimeq": "≄", "\\nsqsubseteq": "⋢", "\\nsqsupseteq": "⋣", "\\nsubset": "⊄", "\\nsubseteq": "⊈", "\\nsubseteqq": "⫅̸", "\\nsucc": "⊁", "\\nsucccurlyeq": "⋡", "\\nsucceq": "⋡", "\\nsupset": "⊅", "\\nsupseteq": "⊉", "\\nsupseteqq": "⫆̸", "\\ntriangleleft": "⋪", "\\ntrianglelefteq": "⋬", "\\ntriangleright": "⋫", "\\ntrianglerighteq": "⋭", "\\nu": "ν", "\\nvDash": "⊭", "\\nvLeftarrow": "⤂", "\\nvLeftrightarrow": "⤄", "\\nvRightarrow": "⤃", "\\nvartriangleleft": "⋪", "\\nvartriangleright": "⋫", "\\nvdash": "⊬", "\\nvinfty": "⧞", "\\nvleftarrow": "⇷", "\\nvleftarrowtail": "⬹", "\\nvleftrightarrow": "⇹", "\\nvrightarrow": "⇸", "\\nvrightarrowtail": "⤔", "\\nvtwoheadleftarrow": "⬴", "\\nvtwoheadleftarrowtail": "⬼", "\\nvtwoheadrightarrow": "⤀", "\\nvtwoheadrightarrowtail": "⤗", "\\nwarrow": "↖", "\\nwovnearrow": "⤲", "\\nwsearrow": "⤡", "\\o": "ø", "\\obar": "⌽", "\\obot": "⦺", "\\obrbrak": "⏠", "\\obslash": "⦸", "\\ocirc": "̊", "\\ocirc{u}": "ů", "\\ocommatopright": "̕", "\\odiv": "⨸", "\\odot": "⊙", "\\odotslashdot": "⦼", "\\oe": "œ", "\\ogreaterthan": "⧁", "\\oiiint": "∰", "\\oiint": "∯", "\\oint": "∮", "\\ointctrclockwise": "∳", "\\olcross": "⦻", "\\olessthan": "⧀", "\\omega": "ω", "\\ominus": "⊖", "\\openbracketleft": "〚", "\\openbracketright": "〛", "\\operp": "⦹", "\\oplus": "⊕", "\\opluslhrim": "⨭", "\\oplusrhrim": "⨮", "\\original": "⊶", "\\origof": "⊶", "\\oslash": "⊘", "\\otimes": "⊗", "\\otimeshat": "⨶", "\\otimeslhrim": "⨴", "\\otimesrhrim": "⨵", "\\oturnedcomma": "̒", "\\overbar": "̅", "\\overbrace": "⏞", "\\overbracket": "⎴", "\\overleftarrow.unicode-math": "⃖", "\\overleftharpoon": "⃐", "\\overleftrightarrow": "⃡", "\\overline": "̅", "\\overparen": "⏜", "\\overrightarrow": "⃗", "\\overrightharpoon": "⃑", "\\ovhook": "̉", "\\parallel": "∥", "\\parallelogram": "▱", "\\parallelogramblack": "▰", "\\parsim": "⫳", "\\partial": "∂", "\\partialmeetcontraction": "⪣", "\\pencil": "✎", "\\pentagon": "⬠", "\\pentagonblack": "⬟", "\\perp": "⟂", "\\perps": "⫡", "\\perspcorrespond": "⩞", "\\pfun": "⇸", "\\phi": "ϕ", "\\pi": "π", "\\pinj": "⤔", "\\pisces": "♓", "\\pitchfork": "⋔", "\\plusdot": "⨥", "\\pluseqq": "⩲", "\\plushat": "⨣", "\\plussim": "⨦", "\\plussubtwo": "⨧", "\\plustrif": "⨨", "\\pluto": "♇", "\\pm": "±", "\\pmboxdrawuni{2501}": "━", "\\pmboxdrawuni{2503}": "┃", "\\pmboxdrawuni{250D}": "┍", "\\pmboxdrawuni{250E}": "┎", "\\pmboxdrawuni{250F}": "┏", "\\pmboxdrawuni{2511}": "┑", "\\pmboxdrawuni{2512}": "┒", "\\pmboxdrawuni{2513}": "┓", "\\pmboxdrawuni{2515}": "┕", "\\pmboxdrawuni{2516}": "┖", "\\pmboxdrawuni{2517}": "┗", "\\pmboxdrawuni{2519}": "┙", "\\pmboxdrawuni{251A}": "┚", "\\pmboxdrawuni{251B}": "┛", "\\pmboxdrawuni{251D}": "┝", "\\pmboxdrawuni{251E}": "┞", "\\pmboxdrawuni{251F}": "┟", "\\pmboxdrawuni{2520}": "┠", "\\pmboxdrawuni{2521}": "┡", "\\pmboxdrawuni{2522}": "┢", "\\pmboxdrawuni{2523}": "┣", "\\pmboxdrawuni{2525}": "┥", "\\pmboxdrawuni{2526}": "┦", "\\pmboxdrawuni{2527}": "┧", "\\pmboxdrawuni{2528}": "┨", "\\pmboxdrawuni{2529}": "┩", "\\pmboxdrawuni{252A}": "┪", "\\pmboxdrawuni{252B}": "┫", "\\pmboxdrawuni{252D}": "┭", "\\pmboxdrawuni{252E}": "┮", "\\pmboxdrawuni{252F}": "┯", "\\pmboxdrawuni{2530}": "┰", "\\pmboxdrawuni{2531}": "┱", "\\pmboxdrawuni{2532}": "┲", "\\pmboxdrawuni{2533}": "┳", "\\pmboxdrawuni{2535}": "┵", "\\pmboxdrawuni{2536}": "┶", "\\pmboxdrawuni{2537}": "┷", "\\pmboxdrawuni{2538}": "┸", "\\pmboxdrawuni{2539}": "┹", "\\pmboxdrawuni{253A}": "┺", "\\pmboxdrawuni{253B}": "┻", "\\pmboxdrawuni{253D}": "┽", "\\pmboxdrawuni{253E}": "┾", "\\pmboxdrawuni{253F}": "┿", "\\pmboxdrawuni{2540}": "╀", "\\pmboxdrawuni{2541}": "╁", "\\pmboxdrawuni{2542}": "╂", "\\pmboxdrawuni{2543}": "╃", "\\pmboxdrawuni{2544}": "╄", "\\pmboxdrawuni{2545}": "╅", "\\pmboxdrawuni{2546}": "╆", "\\pmboxdrawuni{2547}": "╇", "\\pmboxdrawuni{2548}": "╈", "\\pmboxdrawuni{2549}": "╉", "\\pmboxdrawuni{254A}": "╊", "\\pmboxdrawuni{254B}": "╋", "\\pmboxdrawuni{2574}": "╴", "\\pmboxdrawuni{2575}": "╵", "\\pmboxdrawuni{2576}": "╶", "\\pmboxdrawuni{2577}": "╷", "\\pmboxdrawuni{2578}": "╸", "\\pmboxdrawuni{2579}": "╹", "\\pmboxdrawuni{257A}": "╺", "\\pmboxdrawuni{257B}": "╻", "\\pmboxdrawuni{257C}": "╼", "\\pmboxdrawuni{257D}": "╽", "\\pmboxdrawuni{257E}": "╾", "\\pmboxdrawuni{257F}": "╿", "\\pmboxdrawuni{2581}": "▁", "\\pmboxdrawuni{2582}": "▂", "\\pmboxdrawuni{2583}": "▃", "\\pmboxdrawuni{2585}": "▅", "\\pmboxdrawuni{2586}": "▆", "\\pmboxdrawuni{2587}": "▇", "\\pmboxdrawuni{2589}": "▉", "\\pmboxdrawuni{258A}": "▊", "\\pmboxdrawuni{258B}": "▋", "\\pmboxdrawuni{258D}": "▍", "\\pmboxdrawuni{258E}": "▎", "\\pmboxdrawuni{258F}": "▏", "\\pmboxdrawuni{2594}": "▔", "\\pmboxdrawuni{2595}": "▕", "\\pmboxdrawuni{2596}": "▖", "\\pmboxdrawuni{2597}": "▗", "\\pmboxdrawuni{2598}": "▘", "\\pmboxdrawuni{2599}": "▙", "\\pmboxdrawuni{259A}": "▚", "\\pmboxdrawuni{259B}": "▛", "\\pmboxdrawuni{259C}": "▜", "\\pmboxdrawuni{259D}": "▝", "\\pmboxdrawuni{259E}": "▞", "\\pmboxdrawuni{259F}": "▟", "\\pointint": "⨕", "\\pointright": "☞", "\\postalmark": "〒", "\\pounds": "£", "\\prec": "≺", "\\precapprox": "⪷", "\\preccurlyeq": "≼", "\\precedesnotsimilar": "⋨", "\\preceq": "⪯", "\\preceqq": "⪳", "\\precnapprox": "⪹", "\\precneq": "⪱", "\\precneqq": "⪵", "\\precnsim": "⋨", "\\precsim": "≾", "\\prime": "′", "\\prod": "∏", "\\profline": "⌒", "\\profsurf": "⌓", "\\propto": "∝", "\\prurel": "⊰", "\\psi": "ψ", "\\psur": "⤀", "\\pullback": "⟓", "\\pushout": "⟔", "\\qoppa": "ϙ", "\\qprime": "⁗", "\\qquad": "  ", "\\quad": " ", "\\quarternote": "♩", "\\questeq": "≟", "\\quotedblbase": "‟", "\\quotesinglbase": "‚", "\\r": "̊", "\\rAngle": "⟫", "\\rBrace": "⦄", "\\rBrack": "⟧", "\\rParen": "⦆", "\\radiation": "☢", "\\rang": "⟫", "\\rangle": "⟩", "\\rangledot": "⦒", "\\rangledownzigzagarrow": "⍼", "\\rbag": "⟆", "\\rblkbrbrak": "⦘", "\\rblot": "⦊", "\\rbrace": "}", "\\rbracelend": "⎭", "\\rbracemid": "⎬", "\\rbraceuend": "⎫", "\\rbrack": "]", "\\rbrackextender": "⎥", "\\rbracklend": "⎦", "\\rbracklrtick": "⦎", "\\rbrackubar": "⦌", "\\rbrackuend": "⎤", "\\rbrackurtick": "⦐", "\\rbrbrak": "〕", "\\rceil": "⌉", "\\rcirclerightint": "∳", "\\rcurvyangle": "⧽", "\\rdiagovfdiag": "⤫", "\\rdiagovsearrow": "⤰", "\\recorder": "⌕", "\\recycle": "♻", "\\reflectbox{\\carriagereturn}": "↳", "\\revangle": "⦣", "\\revangleubar": "⦥", "\\revemptyset": "⦰", "\\reversesolidus": "⧵", "\\revnmid": "⫮", "\\rfbowtie": "⧒", "\\rfloor": "⌋", "\\rftimes": "⧕", "\\rgroup": "⟯", "\\rhd": "▷", "\\rho": "ρ", "\\right": "", "\\rightangle": "∟", "\\rightanglearc": "⊾", "\\rightanglemdot": "⦝", "\\rightanglesqr": "⦜", "\\rightarrow": "→", "\\rightarrowapprox": "⥵", "\\rightarrowbackapprox": "⭈", "\\rightarrowbar": "⇥", "\\rightarrowbsimilar": "⭌", "\\rightarrowdiamond": "⤞", "\\rightarrowgtr": "⭃", "\\rightarrowonoplus": "⟴", "\\rightarrowplus": "⥅", "\\rightarrowshortleftarrow": "⥂", "\\rightarrowsimilar": "⥴", "\\rightarrowsupset": "⭄", "\\rightarrowtail": "↣", "\\rightarrowtriangle": "⇾", "\\rightarrowx": "⥇", "\\rightbarharpoon": "⥬", "\\rightbkarrow": "⤍", "\\rightcurvedarrow": "⤳", "\\rightdasharrow": "⇢", "\\rightdbltail": "⤜", "\\rightdotarrow": "⤑", "\\rightdowncurvedarrow": "⤷", "\\rightfishtail": "⥽", "\\rightharpoonaccent": "⃑", "\\rightharpoondown": "⇁", "\\rightharpoondownbar": "⥗", "\\rightharpoonsupdown": "⥤", "\\rightharpoonup": "⇀", "\\rightharpoonupbar": "⥓", "\\rightharpoonupdash": "⥬", "\\rightimply": "⥰", "\\rightleftarrows": "⇄", "\\rightleftharpoon": "⥋", "\\rightleftharpoons": "⇌", "\\rightleftharpoonsdown": "⥩", "\\rightleftharpoonsup": "⥨", "\\rightmoon": "☽", "\\rightouterjoin": "⟖", "\\rightpentagon": "⭔", "\\rightpentagonblack": "⭓", "\\rightrightarrows": "⇉", "\\rightrightharpoons": "⥤", "\\rightslice": "⪧", "\\rightsquigarrow": "⇝", "\\righttail": "⤚", "\\rightthreearrows": "⇶", "\\rightthreetimes": "⋌", "\\rightwavearrow": "↝", "\\rightwhitearrow": "⇨", "\\rimg": "⦈", "\\ringplus": "⨢", "\\risingdotseq": "≓", "\\rmoustache": "⎱", "\\rparen": ")", "\\rparenextender": "⎟", "\\rparengtr": "⦔", "\\rparenlend": "⎠", "\\rparenuend": "⎞", "\\rppolint": "⨒", "\\rrangle": "⦊", "\\rrbracket": "⟧", "\\rrparenthesis": "⦈", "\\rsolbar": "⧷", "\\rsqhook": "⫎", "\\rsub": "⩥", "\\rtimes": "⋊", "\\rtriltri": "⧎", "\\ruledelayed": "⧴", "\\rule{1em}{1pt}": "―", "\\rvboxline": "⎹", "\\rvzigzag": "⧙", "\\r{}": "˚", "\\sagittarius": "♐", "\\sampi": "ϡ", "\\sansLmirrored": "⅃", "\\sansLturned": "⅂", "\\saturn": "♄", "\\scorpio": "♏", "\\scpolint": "⨓", "\\scurel": "⊱", "\\searrow": "↘", "\\seovnearrow": "⤭", "\\setminus": "⧵", "\\sharp": "♯", "\\shortdowntack": "⫟", "\\shortlefttack": "⫞", "\\shortrightarrowleftarrow": "⥄", "\\shortuptack": "⫠", "\\shuffle": "⧢", "\\sigma": "σ", "\\sim": "∼", "\\sim\\joinrel\\leadsto": "⟿", "\\sime": "≃", "\\simeq": "≃", "\\simgE": "⪠", "\\simgtr": "⪞", "\\similarleftarrow": "⭉", "\\similarrightarrow": "⥲", "\\simlE": "⪟", "\\simless": "⪝", "\\simminussim": "⩬", "\\simneqq": "≆", "\\simplus": "⨤", "\\simrdots": "⩫", "\\sinewave": "∿", "\\sixteenthnote": "♬", "\\skull": "☠", "\\slash": "/​", "\\smallblacktriangleleft": "◂", "\\smallblacktriangleright": "▸", "\\smallin": "∊", "\\smallni": "∍", "\\smalltriangleleft": "◃", "\\smalltriangleright": "▹", "\\smashtimes": "⨳", "\\smblkcircle": "•", "\\smblkdiamond": "⬩", "\\smblklozenge": "⬪", "\\smblksquare": "▪", "\\smeparsl": "⧤", "\\smile": "⌣", "\\smiley": "☺", "\\smt": "⪪", "\\smte": "⪬", "\\smwhitestar": "⭒", "\\smwhtcircle": "◦", "\\smwhtdiamond": "⋄", "\\smwhtlozenge": "⬫", "\\smwhtsquare": "▫", "\\spadesuit": "♠", "\\sphericalangle": "∢", "\\sphericalangleup": "⦡", "\\spot": "⦁", "\\sqcap": "⊓", "\\sqcup": "⊔", "\\sqint": "⨖", "\\sqlozenge": "⌑", "\\sqrint": "⨖", "\\sqrt": "√", "\\sqrt[3]": "∛", "\\sqrt[4]": "∜", "\\sqrtbottom": "⎷", "\\sqsubset": "⊏", "\\sqsubseteq": "⊑", "\\sqsubsetneq": "⋤", "\\sqsupset": "⊐", "\\sqsupseteq": "⊒", "\\sqsupsetneq": "⋥", "\\square": "◻", "\\squarebotblack": "⬓", "\\squarecrossfill": "▩", "\\squarehfill": "▤", "\\squarehvfill": "▦", "\\squareleftblack": "◧", "\\squarellblack": "⬕", "\\squarellquad": "◱", "\\squarelrblack": "◪", "\\squarelrquad": "◲", "\\squareneswfill": "▨", "\\squarenwsefill": "▧", "\\squarerightblack": "◨", "\\squaretopblack": "⬒", "\\squareulblack": "◩", "\\squareulquad": "◰", "\\squareurblack": "⬔", "\\squareurquad": "◳", "\\squarevfill": "▥", "\\squoval": "▢", "\\ss": "ß", "\\sslash": "⫽", "\\stackrel{*}{=}": "⩮", "\\star": "⋆", "\\stareq": "≛", "\\starequal": "≛", "\\steaming": "☕", "\\stigma": "ϛ", "\\strns": "⏤", "\\subedot": "⫃", "\\submult": "⫁", "\\subrarr": "⥹", "\\subset": "⊂", "\\subsetapprox": "⫉", "\\subsetcirc": "⟃", "\\subsetdot": "⪽", "\\subseteq": "⊆", "\\subseteqq": "⫅", "\\subsetneq": "⊊", "\\subsetneqq": "⫋", "\\subsetplus": "⪿", "\\subsim": "⫇", "\\subsub": "⫕", "\\subsup": "⫓", "\\succ": "≻", "\\succapprox": "⪸", "\\succcurlyeq": "≽", "\\succeq": "⪰", "\\succeqq": "⪴", "\\succnapprox": "⪺", "\\succneq": "⪲", "\\succneqq": "⪶", "\\succnsim": "⋩", "\\succsim": "≿", "\\sum": "∑", "\\sumbottom": "⎳", "\\sumint": "⨋", "\\sumtop": "⎲", "\\sun": "☼", "\\supdsub": "⫘", "\\supedot": "⫄", "\\suphsol": "⟉", "\\suphsub": "⫗", "\\suplarr": "⥻", "\\supmult": "⫂", "\\supset": "⊃", "\\supsetapprox": "⫊", "\\supsetcirc": "⟄", "\\supsetdot": "⪾", "\\supseteq": "⊇", "\\supseteqq": "⫆", "\\supsetneq": "⊋", "\\supsetneqq": "⫌", "\\supsetplus": "⫀", "\\supsim": "⫈", "\\supsub": "⫔", "\\supsup": "⫖", "\\surd": "√", "\\surfintegral": "∯", "\\swarrow": "↙", "\\swords": "⚔", "\\talloblong": "⫾", "\\tau": "τ", "\\taurus": "♉", "\\textGamma": "Γ", "\\textOmega": "Ω", "\\textPhi": "Φ", "\\textSFi": "┌", "\\textSFii": "└", "\\textSFiii": "┐", "\\textSFiv": "┘", "\\textSFix": "┤", "\\textSFl": "╘", "\\textSFli": "╒", "\\textSFlii": "╓", "\\textSFliii": "╫", "\\textSFliv": "╪", "\\textSFv": "┼", "\\textSFvi": "┬", "\\textSFvii": "┴", "\\textSFviii": "├", "\\textSFx": "─", "\\textSFxi": "│", "\\textSFxix": "╡", "\\textSFxl": "╩", "\\textSFxli": "╦", "\\textSFxlii": "╠", "\\textSFxliii": "═", "\\textSFxliv": "╬", "\\textSFxlix": "╙", "\\textSFxlv": "╧", "\\textSFxlvi": "╨", "\\textSFxlvii": "╤", "\\textSFxlviii": "╥", "\\textSFxx": "╢", "\\textSFxxi": "╖", "\\textSFxxii": "╕", "\\textSFxxiii": "╣", "\\textSFxxiv": "║", "\\textSFxxv": "╗", "\\textSFxxvi": "╝", "\\textSFxxvii": "╜", "\\textSFxxviii": "╛", "\\textSFxxxix": "╔", "\\textSFxxxvi": "╞", "\\textSFxxxvii": "╟", "\\textSFxxxviii": "╚", "\\textSigma": "Σ", "\\textTheta": "ϴ", "\\textTstroke": "Ŧ", "\\textacutedbl": "˝", "\\textacutemacron": "́̄", "\\textacutewedge": "́̌", "\\textadvancing": "̘", "\\textalpha": "α", "\\textapproxequal": "≈", "\\textasciiacute": "´", "\\textasciibreve": "˘", "\\textasciicaron": "ˇ", "\\textasciicircum": "^", "\\textasciidieresis": "¨", "\\textasciigrave": "ˋ", "\\textasciimacron": "¯", "\\textasciitilde": "~", "\\textasteriskcentered": "*", "\\textbackslash": "\\", "\\textbaht": "฿", "\\textbar": "|", "\\textbardbl": "‖", "\\textbeta": "β", "\\textbigcircle": "◯", "\\textblacksquare": "■", "\\textblank": "␢", "\\textblock": "█", "\\textbraceleft": "{", "\\textbraceright": "}", "\\textbrevemacron": "̆̄", "\\textbrokenbar": "¦", "\\textbullet": "•", "\\textcap": "∧", "\\textcelsius": "℃", "\\textcent": "¢", "\\textcircledP": "℗", "\\textcircled{R}": "®", "\\textcircumdot": "̂̇", "\\textcolonmonetary": "₡", "\\textcommabelow": "̦", "\\textcompwordmark": "‌", "\\textcontourintegral": "∮", "\\textcopyright": "©", "\\textcorner": "̚", "\\textcrh": "ħ", "\\textcurrency": "¤", "\\textdagger": "†", "\\textdaggerdbl": "‡", "\\textdbllowline": "‗", "\\textdegree": "°", "\\textdelta": "δ", "\\textdh": "ð", "\\textdiscount": "⁒", "\\textdiv": "÷", "\\textdkshade": "▓", "\\textdnblock": "▄", "\\textdollar": "$", "\\textdong": "₫", "\\textdotacute": "̇́", "\\textdotbreve": "̐", "\\textdoublebarpipe": "ǂ", "\\textdoublegrave": "̏", "\\textdoublepipe": "ǂ", "\\textdoublevbaraccent": "̎", "\\textdownarrow": "↓", "\\textelement": "∈", "\\textellipsis": "…", "\\textemdash": "—", "\\textendash": "–", "\\texteopen": "ε", "\\textepsilon": "ε", "\\texteqsim": "≂", "\\textequivalence": "≡", "\\textesh": "ƪ", "\\textestimated": "℮", "\\texteuro": "€", "\\textexclamdown": "¡", "\\textflorin": "ƒ", "\\textfractionsolidus": "⁄", "\\textfrac{0}{3}": "↉", "\\textfrac{1}": "⅟", "\\textfrac{1}{10}": "⅒", "\\textfrac{1}{3}": "⅓", "\\textfrac{1}{5}": "⅕", "\\textfrac{1}{6}": "⅙", "\\textfrac{1}{7}": "⅐", "\\textfrac{1}{8}": "⅛", "\\textfrac{1}{9}": "⅑", "\\textfrac{2}{3}": "⅔", "\\textfrac{2}{5}": "⅖", "\\textfrac{3}{5}": "⅗", "\\textfrac{3}{8}": "⅜", "\\textfrac{4}{5}": "⅘", "\\textfrac{5}{6}": "⅚", "\\textfrac{5}{8}": "⅝", "\\textfrac{7}{8}": "⅞", "\\textgravedot": "̀̇", "\\textgravemacron": "̀̄", "\\textgreater": ">", "\\textgreaterequal": "≥", "\\texthorizontalbar": "―", "\\texthvlig": "ƕ", "\\textincrement": "∆", "\\textinfinity": "∞", "\\textintegral": "∫", "\\textinterrobang": "‽", "\\textintersection": "∩", "\\textinvsubbridge": "̺", "\\textipa{O}": "ɔ", "\\textipa{\\textnrleg}": "ƞ", "\\textipa{\\textturna}": "ɐ", "\\textkra": "ĸ", "\\textlangle": "〈", "\\textleftarrow": "←", "\\textless": "<", "\\textlessequal": "≤", "\\textlfblock": "▌", "\\textlira": "₤", "\\textlnot": "¬", "\\textlowering": "̞", "\\textlozenge": "◊", "\\textltshade": "░", "\\textmalteseH": "Ħ", "\\textmalteseh": "ħ", "\\textmho": "℧", "\\textmu": "µ", "\\textmusicalnote": "♪", "\\textnaira": "₦", "\\textniepsilon": "ε", "\\textnotequal": "≠", "\\textnsuperior": "ⁿ", "\\textnumero": "№", "\\textohm": "Ω", "\\textonehalf": "½", "\\textonequarter": "¼", "\\textonesuperior": "¹", "\\textopenbullet": "◦", "\\textordfeminine": "ª", "\\textordmasculine": "º", "\\textovercross": "̽", "\\textparagraph": "¶", "\\textpartial": "∂", "\\textperiodcentered": "˙", "\\textpertenthousand": "‱", "\\textperthousand": "‰", "\\textpeseta": "₧", "\\textpeso": "₱", "\\textphi": "ɸ", "\\textpi": "π", "\\textpm": "±", "\\textproduct": "∏", "\\textquestiondown": "¿", "\\textquotedbl": '"', "\\textquotedblleft": "“", "\\textquotedblright": "”", "\\textquoteleft": "‘", "\\textquoteright": "’", "\\textraising": "̝", "\\textrangle": "〉", "\\textrecipe": "℞", "\\textreferencemark": "※", "\\textregistered": "®", "\\textretracting": "̙", "\\textrevlogicalnot": "⌐", "\\textrevscripta": "ɤ", "\\textrightarrow": "→", "\\textringmacron": "̊̄", "\\textriota": "℩", "\\textrtaild": "ɖ", "\\textrtblock": "▐", "\\textschwa": "ə", "\\textseagull": "̼", "\\textsection": "§", "\\textservicemark": "℠", "\\textshade": "▒", "\\textsigma": "σ", "\\textsterling": "£", "\\textsubarch": "̯", "\\textsubbar": "̱", "\\textsubbridge": "̪", "\\textsubbridge{d}": "ɖ", "\\textsubgrave": "̖", "\\textsublhalfring": "̜", "\\textsubplus": "̟", "\\textsubrhalfring": "̹", "\\textsubring": "̥", "\\textsubscript{0}": "₀", "\\textsubscript{1}": "₁", "\\textsubscript{2}": "₂", "\\textsubscript{3}": "₃", "\\textsubscript{4}": "₄", "\\textsubscript{5}": "₅", "\\textsubscript{6}": "₆", "\\textsubscript{7}": "₇", "\\textsubscript{8}": "₈", "\\textsubscript{9}": "₉", "\\textsubscript{\\textschwa}": "ₔ", "\\textsubscript{a}": "ₐ", "\\textsubscript{e}": "ₑ", "\\textsubscript{h}": "ₕ", "\\textsubscript{k}": "ₖ", "\\textsubscript{l}": "ₗ", "\\textsubscript{m}": "ₘ", "\\textsubscript{n}": "ₙ", "\\textsubscript{o}": "ₒ", "\\textsubscript{p}": "ₚ", "\\textsubscript{s}": "ₛ", "\\textsubscript{t}": "ₜ", "\\textsubscript{x}": "ₓ", "\\textsubsquare": "̻", "\\textsubtilde": "̰", "\\textsubumlaut": "̤", "\\textsubwedge": "̬", "\\textsummation": "∑", "\\textsuperimposetilde": "̴", "\\textsuperscript{1}": "¹", "\\textsuperscript{2}": "²", "\\textsuperscript{3}": "³", "\\textsuperscript{4}": "⁴", "\\textsuperscript{5}": "⁵", "\\textsuperscript{6}": "⁶", "\\textsuperscript{7}": "⁷", "\\textsuperscript{8}": "⁸", "\\textsuperscript{9}": "⁹", "\\textsuperscript{A}": "ᴬ", "\\textsuperscript{a}": "ᵃ", "\\textsuperscript{b}": "ᵇ", "\\textsuperscript{c}": "ᶜ", "\\textsuperscript{d}": "ᵈ", "\\textsuperscript{e}": "ᵉ", "\\textsuperscript{f}": "ᶠ", "\\textsuperscript{g}": "ᵍ", "\\textsuperscript{h}": "ʰ", "\\textsuperscript{i}": "ⁱ", "\\textsuperscript{j}": "ʲ", "\\textsuperscript{k}": "ᵏ", "\\textsuperscript{l}": "ˡ", "\\textsuperscript{m}": "ᵐ", "\\textsuperscript{n}": "ⁿ", "\\textsuperscript{o}": "ᵒ", "\\textsuperscript{p}": "ᵖ", "\\textsuperscript{r}": "ʳ", "\\textsuperscript{s}": "ˢ", "\\textsuperscript{t}": "ᵗ", "\\textsuperscript{u}": "ᵘ", "\\textsuperscript{v}": "ᵛ", "\\textsuperscript{w}": "ʷ", "\\textsuperscript{x}": "ˣ", "\\textsuperscript{y}": "ʸ", "\\textsuperscript{z}": "ᶻ", "\\textsurd": "√", "\\textsyllabic": "̩", "\\texttau": "τ", "\\texttheta": "θ", "\\textthreequarters": "¾", "\\textthreesuperior": "³", "\\texttildedot": "̃̇", "\\texttildelow": "˜", "\\texttimes": "×", "\\texttrademark": "™", "\\texttstroke": "ŧ", "\\textturnk": "ʞ", "\\textturnm": "ɯ", "\\texttwosuperior": "²", "\\textunderscore": "_", "\\textuparrow": "↑", "\\textupblock": "▀", "\\textvartheta": "ϑ", "\\textvbaraccent": "̍", "\\textvisiblespace": "⊔", "\\textwon": "₩", "\\textyen": "¥", "\\th": "þ", "\\therefore": "∴", "\\thermod": "⧧", "\\theta": "θ", "\\thickspace": " ", "\\thinspace": " ", "\\threedangle": "⟀", "\\threedotcolon": "⫶", "\\threeunderdot": "⃨", "\\tieconcat": "⁀", "\\tieinfty": "⧝", "\\tilde": "̃", "\\tildetrpl": "≋", "\\times": "×", "\\timesbar": "⨱", "\\tminus": "⧿", "\\to": "→", "\\toea": "⤨", "\\tona": "⤧", "\\tone{11}": "˩", "\\tone{22}": "˨", "\\tone{33}": "˧", "\\tone{44}": "˦", "\\tone{55}": "˥", "\\top": "⊤", "\\topbot": "⌶", "\\topcir": "⫱", "\\topfork": "⫚", "\\topsemicircle": "◠", "\\tosa": "⤩", "\\towa": "⤪", "\\tplus": "⧾", "\\trapezium": "⏢", "\\trianglecdot": "◬", "\\triangledown": "▿", "\\triangleleft": "◁", "\\triangleleftblack": "◭", "\\trianglelefteq": "⊴", "\\triangleminus": "⨺", "\\triangleodot": "⧊", "\\triangleplus": "⨹", "\\triangleq": "≜", "\\triangleright": "▷", "\\trianglerightblack": "◮", "\\trianglerighteq": "⊵", "\\triangles": "⧌", "\\triangleserifs": "⧍", "\\triangletimes": "⨻", "\\triangleubar": "⧋", "\\tripleplus": "⧻", "\\trprime": "‴", "\\trslash": "⫻", "\\truestate": "⊧", "\\turnangle": "⦢", "\\turnediota": "℩", "\\turnednot": "⌙", "\\twocaps": "⩋", "\\twocups": "⩊", "\\twoheaddownarrow": "↡", "\\twoheadleftarrow": "↞", "\\twoheadleftarrowtail": "⬻", "\\twoheadleftdbkarrow": "⬷", "\\twoheadmapsfrom": "⬶", "\\twoheadmapsto": "⤅", "\\twoheadrightarrow": "↠", "\\twoheadrightarrowtail": "⤖", "\\twoheaduparrow": "↟", "\\twoheaduparrowcircle": "⥉", "\\twolowline": "‗", "\\twonotes": "♫", "\\typecolon": "⦂", "\\t{ia}": "i︠a︡", "\\u": "̆", "\\ubrbrak": "⏡", "\\ularc": "◜", "\\ulblacktriangle": "◤", "\\ulcorner": "⌜", "\\ultriangle": "◸", "\\uminus": "⩁", "\\underbar": "̱", "\\underbrace": "⏟", "\\underbracket": "⎵", "\\underleftarrow": "⃮", "\\underleftharpoondown": "⃭", "\\underleftrightarrow": "͍", "\\underline": "̲", "\\underparen": "⏝", "\\underrightarrow": "⃯", "\\underrightharpoondown": "⃬", "\\unicodecdots": "⋯", "\\unicodeellipsis": "…", "\\upDigamma": "Ϝ", "\\upand": "⅋", "\\uparrow": "↑", "\\uparrowbarred": "⤉", "\\uparrowoncircle": "⦽", "\\upbackepsilon": "϶", "\\updasharrow": "⇡", "\\updigamma": "ϝ", "\\updownarrow": "↕", "\\updownarrowbar": "↨", "\\updownarrows": "⇅", "\\updownharpoonleftleft": "⥑", "\\updownharpoonleftright": "⥍", "\\updownharpoonrightleft": "⥌", "\\updownharpoonrightright": "⥏", "\\updownharpoonsleftright": "⥮", "\\upfishtail": "⥾", "\\upharpoonleft": "↿", "\\upharpoonleftbar": "⥠", "\\upharpoonright": "↾", "\\upharpoonrightbar": "⥜", "\\upharpoonsleftright": "⥣", "\\upin": "⟒", "\\upint": "⨛", "\\uplus": "⊎", "\\uprightcurvearrow": "⤴", "\\upsilon": "υ", "\\upslopeellipsis": "⋰", "\\upuparrows": "⇈", "\\upupharpoons": "⥣", "\\upvarTheta": "ϴ", "\\upwhitearrow": "⇧", "\\uranus": "♅", "\\urarc": "◝", "\\urblacktriangle": "◥", "\\urcorner": "⌝", "\\urtriangle": "◹", "\\utilde": "̰", "\\v": "̌", "\\vBar": "⫨", "\\vBarv": "⫩", "\\vDash": "⊨", "\\vDdash": "⫢", "\\varGamma": "Γ", "\\varVdash": "⫦", "\\varbarwedge": "⌅", "\\varbeta": "ϐ", "\\varcarriagereturn": "⏎", "\\varclubsuit": "♧", "\\vardiamondsuit": "♦", "\\vardoublebarwedge": "⌆", "\\varepsilon": "ε", "\\varheartsuit": "♥", "\\varhexagon": "⬡", "\\varhexagonblack": "⬢", "\\varhexagonlrbonds": "⌬", "\\varisinobar": "⋶", "\\varisins": "⋳", "\\varkappa": "ϰ", "\\varlrtriangle": "⊿", "\\varniobar": "⋽", "\\varnis": "⋻", "\\varnothing": "∅", "\\varointclockwise": "∲", "\\varphi": "φ", "\\varpi": "ϖ", "\\varprod": "⨉", "\\varrho": "ϱ", "\\varsigma": "ς", "\\varspadesuit": "♤", "\\varstar": "✶", "\\varsubsetneqq": "⊊︀", "\\varsupsetneq": "⊋︀", "\\vartheta": "ϑ", "\\vartriangle": "▵", "\\vartriangleleft": "⊲", "\\vartriangleright": "⊳", "\\varveebar": "⩡", "\\vbraceextender": "⎪", "\\vbrtri": "⧐", "\\vdash": "⊢", "\\vdots": "⋮", "\\vec": "⃗", "\\vectimes": "⨯", "\\vee": "∨", "\\veebar": "⊻", "\\veedot": "⟇", "\\veedoublebar": "⩣", "\\veeeq": "≚", "\\veemidvert": "⩛", "\\veeodot": "⩒", "\\veeonvee": "⩖", "\\veeonwedge": "⩙", "\\venus": "♀", "\\vert": "|", "\\vertoverlay": "⃒", "\\verymuchgreater": "⋙", "\\verymuchless": "⋘", "\\viewdata": "⌗", "\\virgo": "♍", "\\vlongdash": "⟝", "\\volintegral": "∰", "\\vrectangle": "▯", "\\vrectangleblack": "▮", "\\vysmblkcircle": "∙", "\\vysmblksquare": "⬝", "\\vysmwhtcircle": "∘", "\\vysmwhtsquare": "⬞", "\\vzigzag": "⦚", "\\v{\\i}": "ǐ", "\\v{\\j}": "ǰ", "\\warning": "⚠", "\\wasylozenge": "⌑", "\\wedge": "∧", "\\wedgebar": "⩟", "\\wedgedot": "⟑", "\\wedgedoublebar": "⩠", "\\wedgemidvert": "⩚", "\\wedgeodot": "⩑", "\\wedgeonwedge": "⩕", "\\wedgeq": "≙", "\\whitearrowupfrombar": "⇪", "\\whiteinwhitetriangle": "⟁", "\\whitepointerleft": "◅", "\\whitepointerright": "▻", "\\whitesquaretickleft": "⟤", "\\whitesquaretickright": "⟥", "\\whthorzoval": "⬭", "\\whtvertoval": "⬯", "\\wideangledown": "⦦", "\\wideangleup": "⦧", "\\widebreve": "̆", "\\widebridgeabove": "⃩", "\\widecheck": "̌", "\\widehat": "∧", "\\wideoverbar": "̅", "\\widetilde": "̃", "\\wideutilde": "̰", "\\wp": "℘", "\\wr": "≀", "\\xbsol": "⧹", "\\xi": "ξ", "\\xsol": "⧸", "\\yinyang": "☯", "\\zcmp": "⨟", "\\zeta": "ζ", "\\zhide": "⧹", "\\zpipe": "⨠", "\\zproject": "⨡", "\\{": "{", "\\}": "}", "\\~": "̃", "\\~{\\i}": "ĩ", "\\´": "́", "^\\circ": "°", "^{(}": "⁽", "^{)}": "⁾", "^{+}": "⁺", "^{-}": "⁻", "^{0}": "⁰", "^{1}": "¹", "^{2}": "²", "^{3}": "³", "^{4}": "⁴", "^{5}": "⁵", "^{6}": "⁶", "^{7}": "⁷", "^{8}": "⁸", "^{9}": "⁹", "^{=}": "⁼", "^{A}": "ᴬ", "^{a}": "ᵃ", "^{b}": "ᵇ", "^{c}": "ᶜ", "^{d}": "ᵈ", "^{e}": "ᵉ", "^{f}": "ᶠ", "^{g}": "ᵍ", "^{h}": "ʰ", "^{i}": "ⁱ", "^{j}": "ʲ", "^{k}": "ᵏ", "^{l}": "ˡ", "^{m}": "ᵐ", "^{n}": "ⁿ", "^{o}": "ᵒ", "^{p}": "ᵖ", "^{r}": "ʳ", "^{s}": "ˢ", "^{t}": "ᵗ", "^{u}": "ᵘ", "^{v}": "ᵛ", "^{w}": "ʷ", "^{x}": "ˣ", "^{y}": "ʸ", "^{z}": "ᶻ", "_\\infty": " ͚", "_{(}": "₍", "_{)}": "₎", "_{+}": "₊", "_{-}": "₋", "_{0}": "₀", "_{1}": "₁", "_{2}": "₂", "_{3}": "₃", "_{4}": "₄", "_{5}": "₅", "_{6}": "₆", "_{7}": "₇", "_{8}": "₈", "_{9}": "₉", "_{=}": "₌", "_{a}": "ₐ", "_{e}": "ₑ", "_{h}": "ₕ", "_{k}": "ₖ", "_{l}": "ₗ", "_{m}": "ₘ", "_{n}": "ₙ", "_{o}": "ₒ", "_{p}": "ₚ", "_{s}": "ₛ", "_{t}": "ₜ", "_{x}": "ₓ", "``": { text: "“", math: "``" }, "textipa{\\textopeno}": "ɒ", "{'''}": { text: "{'''}", math: "‴" }, "{''}": { text: "{''}", math: "″" }, "{\\'{}I}": "Ί", "{\\'{}O}": "Ό", "{\\aftergroup\\ignorespaces}": "‌", "{\\int\\!\\int\\!\\int}": "∭", "{\\int\\!\\int}": "∬", '{\\mathchar"2208}': "⌖", "{\\not\\kern-0.3em\\times}": "≭", "{\\r A}": "Å", "{\\r U}": "Ů", "{\\r a}": "å", "{\\r u}": "ů", "{\\rlap{\\textbackslash}{{/}\\!\\!{/}}}": "⫽⃥", "{\\u \\i}": "ĭ", "{_\\ast}": "∗", "{{/}\\!\\!{/}}": "⫽", "~": " " };
  }
});

// node_modules/unicode2latex/tables/combining.json
var require_combining = __commonJS({
  "node_modules/unicode2latex/tables/combining.json"(exports, module) {
    module.exports = { macros: ["acute", "bar", "breve", "c", "candra", "check", "d", "ddot", "dot", "droang", "grave", "hat", "k", "mathring", "ocirc", "overbar", "overline", "r", "textacutemacron", "textacutewedge", "textadvancing", "textbrevemacron", "textcircumdot", "textcommabelow", "textcorner", "textdotacute", "textdotbreve", "textdoublegrave", "textdoublevbaraccent", "textgravedot", "textgravemacron", "textinvsubbridge", "textlowering", "textovercross", "textraising", "textretracting", "textringmacron", "textseagull", "textsubarch", "textsubbar", "textsubbridge", "textsubgrave", "textsublhalfring", "textsubplus", "textsubrhalfring", "textsubring", "textsubsquare", "textsubtilde", "textsubumlaut", "textsubwedge", "textsuperimposetilde", "textsyllabic", "texttildedot", "textvbaraccent", "tilde", "u", "underbar", "utilde", "v", "widebreve", "widecheck", "widehat", "wideoverbar", "widetilde", "wideutilde"], tolatex: { "̀": { mode: "text", macro: "`" }, "́": { mode: "text", macro: "'" }, "̃": { mode: "text", macro: "~" }, "̅": { mode: "math", macro: "overline" }, "̆": { mode: "text", macro: "u" }, "̇": { mode: "text", macro: "." }, "̈": { mode: "text", macro: '"' }, "̊": { mode: "text", macro: "r" }, "̌": { mode: "text", macro: "v" }, "̐": { mode: "text", macro: "textdotbreve" }, "̚": { mode: "text", macro: "textcorner" }, "̱": { mode: "text", macro: "textsubbar" }, "¸": { mode: "text", macro: "c" }, "̀̄": { mode: "text", macro: "textgravemacron" }, "̀̇": { mode: "text", macro: "textgravedot" }, "́̄": { mode: "text", macro: "textacutemacron" }, "́̌": { mode: "text", macro: "textacutewedge" }, "̂̇": { mode: "text", macro: "textcircumdot" }, "̂": { mode: "text", macro: "^" }, "̃̇": { mode: "text", macro: "texttildedot" }, "̄": { mode: "text", macro: "=" }, "̄̀": { mode: "text", macro: "textgravemacron" }, "̆̄": { mode: "text", macro: "textbrevemacron" }, "̇́": { mode: "text", macro: "textdotacute" }, "̇̆": { mode: "text", macro: "textdotbreve" }, "̊̄": { mode: "text", macro: "textringmacron" }, "̋": { mode: "text", macro: "H" }, "̍": { mode: "text", macro: "textvbaraccent" }, "̎": { mode: "text", macro: "textdoublevbaraccent" }, "̏": { mode: "text", macro: "textdoublegrave" }, "̖": { mode: "text", macro: "textsubgrave" }, "̘": { mode: "text", macro: "textadvancing" }, "̙": { mode: "text", macro: "textretracting" }, "̜": { mode: "text", macro: "textsublhalfring" }, "̝": { mode: "text", macro: "textraising" }, "̞": { mode: "text", macro: "textlowering" }, "̟": { mode: "text", macro: "textsubplus" }, "̣": { mode: "text", macro: "d" }, "̤": { mode: "text", macro: "textsubumlaut" }, "̥": { mode: "text", macro: "textsubring" }, "̦": { mode: "text", macro: "textcommabelow" }, "̧": { mode: "text", macro: "c" }, "̨": { mode: "text", macro: "k" }, "̩": { mode: "text", macro: "textsyllabic" }, "̪": { mode: "text", macro: "textsubbridge" }, "̬": { mode: "text", macro: "textsubwedge" }, "̯": { mode: "text", macro: "textsubarch" }, "̰": { mode: "text", macro: "textsubtilde" }, "̴": { mode: "text", macro: "textsuperimposetilde" }, "̹": { mode: "text", macro: "textsubrhalfring" }, "̺": { mode: "text", macro: "textinvsubbridge" }, "̻": { mode: "text", macro: "textsubsquare" }, "̼": { mode: "text", macro: "textseagull" }, "̽": { mode: "text", macro: "textovercross" } }, tounicode: { grave: "̀", acute: "́", widetilde: "̃", tilde: "̃", overbar: "̅", bar: "̅", wideoverbar: "̅", overline: "̅", widebreve: "̆", breve: "̆", dot: "̇", ddot: "̈", ocirc: "̊", mathring: "̊", widecheck: "̌", check: "̌", candra: "̐", droang: "̚", utilde: "̰", wideutilde: "̰", underbar: "̱", widehat: "∧", hat: "∧", "`": "̀", textgravemacron: "̀̄", textgravedot: "̀̇", "'": "́", "´": "́", textacutemacron: "́̄", textacutewedge: "́̌", textcircumdot: "̂̇", "^": "̂", "~": "̃", texttildedot: "̃̇", "=": "̄", u: "̆", textbrevemacron: "̆̄", ".": "̇", textdotacute: "̇́", '"': "̈", r: "̊", textringmacron: "̊̄", H: "̋", v: "̌", textvbaraccent: "̍", textdoublevbaraccent: "̎", textdoublegrave: "̏", textdotbreve: "̐", textsubgrave: "̖", textadvancing: "̘", textretracting: "̙", textcorner: "̚", textsublhalfring: "̜", textraising: "̝", textlowering: "̞", textsubplus: "̟", d: "̣", textsubumlaut: "̤", textsubring: "̥", textcommabelow: "̦", c: "̧", k: "̨", textsyllabic: "̩", textsubbridge: "̪", textsubwedge: "̬", textsubarch: "̯", textsubtilde: "̰", textsubbar: "̱", textsuperimposetilde: "̴", textsubrhalfring: "̹", textinvsubbridge: "̺", textsubsquare: "̻", textseagull: "̼", textovercross: "̽" }, regex: "(̀̄|̄̀)|(̀̇|̇̀)|(́̄|̄́)|(́̌|̌́)|(̂̇|̇̂)|(̃̇|̇̃)|(̄̀|̀̄)|(̆̄|̄̆)|(̇́|́̇)|(̇̆|̆̇)|(̊̄|̄̊)|[̰̰̱̀́̃̃̅̅̅̅̆̆̇̈̊̊̌̌̐̚∧∧¸̴̧̨̖̘̙̜̝̞̟̣̤̥̦̩̪̬̯̰̱̹̺̻̼̀́́̂̃̄̆̇̈̊̋̌̍̎̏̐̽̚]" };
  }
});

// node_modules/unicode2latex/index.js
var require_unicode2latex = __commonJS({
  "node_modules/unicode2latex/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transform = exports.replace_macro_spacers = exports.combining = exports.latex2unicode = exports.minimal = exports.bibtex = exports.biblatex = void 0;
    exports.biblatex = require_biblatex();
    exports.bibtex = require_bibtex();
    exports.minimal = require_minimal();
    var maps = { biblatex: exports.biblatex, bibtex: exports.bibtex, minimal: exports.minimal };
    exports.latex2unicode = require_latex2unicode();
    function permutations(str) {
      if (str.length === 0)
        return [];
      if (str.length === 1)
        return [str];
      const result = [];
      for (let i = 0; i < str.length; i++) {
        const firstChar = str[i];
        const remainingChars = str.slice(0, i) + str.slice(i + 1);
        const remainingPermutations = permutations(remainingChars);
        for (let j = 0; j < remainingPermutations.length; j++) {
          result.push(firstChar + remainingPermutations[j]);
        }
      }
      return result;
    }
    exports.combining = require_combining();
    var combining_re = new RegExp(exports.combining.regex);
    function replace_macro_spacers(latex) {
      return latex.replace(/\0(\s)/g, "{}$1").replace(/\0([^;.,!?${}_^\\/])/g, " $1").replace(/\0/g, "");
    }
    exports.replace_macro_spacers = replace_macro_spacers;
    var switchMode = {
      math: "text",
      text: "math"
    };
    var re = /(i\uFE20a\uFE21)|([^\u0300-\u036F][\u0300-\u036F]+)|([\uD800-\uDBFF][\uDC00-\uDFFF])|(.)/g;
    var Transform = class {
      constructor(mode, options = {}) {
        let map = Object.assign({}, maps[mode].base);
        const packages = maps[mode].package;
        for (const pkg of (options.packages || []).map((p) => packages[p]).filter((p) => p)) {
          map = Object.assign(Object.assign({}, map), pkg);
        }
        for (const mode2 of ["text", "math"]) {
          if (!(mode2 in options))
            continue;
          for (const c of options[mode2]) {
            if (mode2 in map[c])
              map[c] = { [mode2]: map[c][mode2] };
          }
        }
        for (const c of options.ascii || "") {
          if (exports.bibtex.base[c])
            map[c] = exports.bibtex.base[c];
        }
        if (options.charmap) {
          for (const [u, t] of Object.entries(options.charmap)) {
            map[u.normalize("NFC")] = map[u.normalize("NFD")] = t;
          }
        }
        this.mode = mode;
        this.map = map;
      }
      tolatex(text, options = {}) {
        const { bracemath, preservemacrospacers, packages } = Object.assign({ bracemath: false, preservemacrospacers: false, packages: /* @__PURE__ */ new Set() }, options);
        let mode = "text";
        let braced = 0;
        const switchTo = {
          math: bracemath ? "{$" : "$",
          text: bracemath ? "$}" : "$"
        };
        let mapped;
        let switched;
        let m;
        let cd;
        let latex = "";
        text.normalize("NFD").replace(re, (match, tie, cdpair, pair, single) => {
          mapped = null;
          if (tie && !this.map[tie]) {
            mapped = { text: "ia" };
          } else {
            mapped = this.map[tie] || this.map[pair] || this.map[single] || this.map[cdpair];
          }
          if (!mapped && this.mode !== "minimal" && cdpair) {
            let char = cdpair[0];
            let cdmode = "";
            cdpair = cdpair.substr(1).replace(combining_re, (cdc) => {
              cd = exports.combining.tolatex[permutations(cdc).find((p) => exports.combining.tolatex[p])];
              if (!cd)
                return cdc;
              if (!cdmode) {
                cdmode = cd.mode;
                char = (this.map[char] || { text: char, math: char })[cdmode];
              }
              if (cdmode !== cd.mode)
                return cdc;
              const cmd = cd.macro.match(/[a-z]/i);
              if (this.mode === "bibtex" && cd.mode === "text") {
                char = `{\\${cd.macro}${cmd ? " " : ""}${char}}`;
              } else if (cmd && char.length === 1) {
                char = `\\${cd.macro} ${char}`;
              } else if (cmd) {
                char = `\\${cd.macro}{${char}}`;
              } else {
                char = `\\${cd.macro}${char}`;
              }
              return "";
            });
            if (!cdpair)
              mapped = { [cdmode]: char };
          }
          if (!mapped)
            mapped = { text: match };
          if (!mapped[mode]) {
            mode = switchMode[mode];
            latex += switchTo[mode];
            switched = true;
          } else {
            switched = false;
          }
          switch (mapped[mode]) {
            case "\\{":
              braced += 1;
              break;
            case "\\}":
              braced -= 1;
              break;
          }
          if (braced < 0) {
            latex += "\\vphantom\\{";
            braced = 0;
          }
          if (switched && mode === "text" && (m = latex.match(/([\^_])\{(.)\}(\$\}?)$/))) {
            latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[2] + m[3];
          }
          latex += mapped[mode];
          if (mapped.macrospacer)
            latex += "\0";
          if (!switched && mode === "math" && (m = latex.match(/(([\^_])\{[^{}]+)\}\2{(.\})$/))) {
            latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[3];
          }
          if (mapped.alt) {
            for (const pkg of mapped.alt) {
              packages.add(pkg);
            }
          }
          return match;
        });
        switch (braced) {
          case 0:
            break;
          case 1:
            latex += "\\vphantom\\}";
            break;
          default:
            latex += `\\vphantom{${"\\}".repeat(braced)}}`;
            break;
        }
        if (mode === "math")
          latex += switchTo.text;
        if (!preservemacrospacers)
          latex = replace_macro_spacers(latex);
        return latex.normalize("NFC");
      }
    };
    exports.Transform = Transform;
  }
});

// node_modules/xregexp/tools/output/categories.js
var require_categories = __commonJS({
  "node_modules/xregexp/tools/output/categories.js"(exports, module) {
    module.exports = [
      {
        "name": "C",
        "alias": "Other",
        "isBmpLast": true,
        "bmp": "\0--­͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-؅؜۝܎܏݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏-ࢗ࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠎᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿​-‏‪-‮⁠-⁯⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽-＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￻￾￿",
        "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCBD\uDCC3-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
      },
      {
        "name": "Cc",
        "alias": "Control",
        "bmp": "\0--"
      },
      {
        "name": "Cf",
        "alias": "Format",
        "bmp": "­؀-؅؜۝܏࢐࢑࣢᠎​-‏‪-‮⁠-⁤⁦-⁯\uFEFF￹-￻",
        "astral": "\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC38]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
      },
      {
        "name": "Cn",
        "alias": "Unassigned",
        "bmp": "͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-׿܎݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏࢒-ࢗ঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿⁥⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-퟿﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽﻾＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￸￾￿",
        "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCC3-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F\uDC39-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
      },
      {
        "name": "Co",
        "alias": "Private_Use",
        "bmp": "-",
        "astral": "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
      },
      {
        "name": "Cs",
        "alias": "Surrogate",
        "bmp": "\uD800-\uDFFF"
      },
      {
        "name": "L",
        "alias": "Letter",
        "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "LC",
        "alias": "Cased_Letter",
        "bmp": "A-Za-zµÀ-ÖØ-öø-ƺƼ-ƿǄ-ʓʕ-ʯͰ-ͳͶͷͻ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՠ-ֈႠ-ჅჇჍა-ჺჽ-ჿᎠ-Ᏽᏸ-ᏽᲀ-ᲈᲐ-ᲺᲽ-Ჿᴀ-ᴫᵫ-ᵷᵹ-ᶚḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℴℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⱻⱾ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭꙀ-ꙭꚀ-ꚛꜢ-ꝯꝱ-ꞇꞋ-ꞎꞐ-ꟊꟐꟑꟓꟕ-ꟙꟵꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗＡ-Ｚａ-ｚ",
        "astral": "\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD00-\uDD43]"
      },
      {
        "name": "Ll",
        "alias": "Lowercase_Letter",
        "bmp": "a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎↄⰰ-ⱟⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟁꟃꟈꟊꟑꟓꟕꟗꟙꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
        "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
      },
      {
        "name": "Lm",
        "alias": "Modifier_Letter",
        "bmp": "ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥۦߴߵߺࠚࠤࠨࣉॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼⱽⵯⸯ々〱-〵〻ゝゞー-ヾꀕꓸ-ꓽꘌꙿꚜꚝꜗ-ꜟꝰꞈꟲ-ꟴꟸꟹꧏꧦꩰꫝꫳꫴꭜ-ꭟꭩｰﾞﾟ",
        "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD838[\uDD37-\uDD3D]|𞥋"
      },
      {
        "name": "Lo",
        "alias": "Other_Letter",
        "bmp": "ªºƻǀ-ǃʔא-תׯ-ײؠ-ؿف-يٮٯٱ-ۓەۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣈऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๅກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳳᳵᳶᳺℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF4A\uDF50]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|𝼊|\uD838[\uDD00-\uDD2C\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "Lt",
        "alias": "Titlecase_Letter",
        "bmp": "ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ"
      },
      {
        "name": "Lu",
        "alias": "Uppercase_Letter",
        "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅↃⰀ-ⰯⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟀꟂꟄ-ꟇꟉꟐꟖꟘꟵＡ-Ｚ",
        "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
      },
      {
        "name": "M",
        "alias": "Mark",
        "bmp": "̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣඁ-ඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-ᫎᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯",
        "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      },
      {
        "name": "Mc",
        "alias": "Spacing_Mark",
        "bmp": "ःऻा-ीॉ-ौॎॏংঃা-ীেৈোৌৗਃਾ-ੀઃા-ીૉોૌଂଃାୀେୈୋୌୗாிுூெ-ைொ-ௌௗఁ-ఃు-ౄಂಃಾೀ-ೄೇೈೊೋೕೖംഃാ-ീെ-ൈൊ-ൌൗංඃා-ෑෘ-ෟෲෳ༾༿ཿါာေးျြၖၗၢ-ၤၧ-ၭႃႄႇ-ႌႏႚ-ႜ᜕᜴ាើ-ៅះៈᤣ-ᤦᤩ-ᤫᤰᤱᤳ-ᤸᨙᨚᩕᩗᩡᩣᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ᭄ᮂᮡᮦᮧ᮪ᯧᯪ-ᯬᯮ᯲᯳ᰤ-ᰫᰴᰵ᳡᳷〮〯ꠣꠤꠧꢀꢁꢴ-ꣃꥒ꥓ꦃꦴꦵꦺꦻꦾ-꧀ꨯꨰꨳꨴꩍꩻꩽꫫꫮꫯꫵꯣꯤꯦꯧꯩꯪ꯬",
        "astral": "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD30-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
      },
      {
        "name": "Me",
        "alias": "Enclosing_Mark",
        "bmp": "҈҉᪾⃝-⃠⃢-⃤꙰-꙲"
      },
      {
        "name": "Mn",
        "alias": "Nonspacing_Mark",
        "bmp": "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣ৾ਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣૺ-૿ଁ଼ିୁ-ୄ୍୕ୖୢୣஂீ்ఀఄ఼ా-ీె-ైొ-్ౕౖౢౣಁ಼ಿೆೌ್ೢೣഀഁ഻഼ു-ൄ്ൢൣඁ්ි-ුූัิ-ฺ็-๎ັິ-ຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲᜳᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᪿ-ᫎᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᮫-ᮭ᯦ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꠬꣄ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꦽꧥꨩ-ꨮꨱꨲꨵꨶꩃꩌꩼꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯",
        "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      },
      {
        "name": "N",
        "alias": "Number",
        "bmp": "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൘-൞൦-൸෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
        "astral": "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]"
      },
      {
        "name": "Nd",
        "alias": "Decimal_Number",
        "bmp": "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
        "astral": "\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]"
      },
      {
        "name": "Nl",
        "alias": "Letter_Number",
        "bmp": "ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ",
        "astral": "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
      },
      {
        "name": "No",
        "alias": "Other_Number",
        "bmp": "²³¹¼-¾৴-৹୲-୷௰-௲౸-౾൘-൞൰-൸༪-༳፩-፼៰-៹᧚⁰⁴-⁹₀-₉⅐-⅟↉①-⒛⓪-⓿❶-➓⳽㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꠰-꠵",
        "astral": "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C\uDFC0-\uDFD4]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]"
      },
      {
        "name": "P",
        "alias": "Punctuation",
        "bmp": "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}¡§«¶·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔༺-༽྅࿐-࿔࿙࿚၊-၏჻፠-፨᐀᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎⌈-⌋〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰-⹏⹒-⹝、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･",
        "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      },
      {
        "name": "Pc",
        "alias": "Connector_Punctuation",
        "bmp": "_‿⁀⁔︳︴﹍-﹏＿"
      },
      {
        "name": "Pd",
        "alias": "Dash_Punctuation",
        "bmp": "\\-֊־᐀᠆‐-―⸗⸚⸺⸻⹀⹝〜〰゠︱︲﹘﹣－",
        "astral": "𐺭"
      },
      {
        "name": "Pe",
        "alias": "Close_Punctuation",
        "bmp": "\\)\\]\\}༻༽᚜⁆⁾₎⌉⌋〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩⹖⹘⹚⹜〉》」』】〕〗〙〛〞〟﴾︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣"
      },
      {
        "name": "Pf",
        "alias": "Final_Punctuation",
        "bmp": "»’”›⸃⸅⸊⸍⸝⸡"
      },
      {
        "name": "Pi",
        "alias": "Initial_Punctuation",
        "bmp": "«‘‛“‟‹⸂⸄⸉⸌⸜⸠"
      },
      {
        "name": "Po",
        "alias": "Other_Punctuation",
        "bmp": "!-#%-'\\*,\\.\\/:;\\?@\\¡§¶·¿;·՚-՟։׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔྅࿐-࿔࿙࿚၊-၏჻፠-፨᙮᛫-᛭᜵᜶។-៖៘-៚᠀-᠅᠇-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‖‗†-‧‰-‸※-‾⁁-⁃⁇-⁑⁓⁕-⁞⳹-⳼⳾⳿⵰⸀⸁⸆-⸈⸋⸎-⸖⸘⸙⸛⸞⸟⸪-⸮⸰-⸹⸼-⸿⹁⹃-⹏⹒-⹔、-〃〽・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫︐-︖︙︰﹅﹆﹉-﹌﹐-﹒﹔-﹗﹟-﹡﹨﹪﹫！-＃％-＇＊，．／：；？＠＼｡､･",
        "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      },
      {
        "name": "Ps",
        "alias": "Open_Punctuation",
        "bmp": "\\(\\[\\{༺༼᚛‚„⁅⁽₍⌈⌊〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨⹂⹕⹗⹙⹛〈《「『【〔〖〘〚〝﴿︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢"
      },
      {
        "name": "S",
        "alias": "Symbol",
        "bmp": "\\$\\+<->\\^`\\|~¢-¦¨©¬®-±´¸×÷˂-˅˒-˟˥-˫˭˯-˿͵΄΅϶҂֍-֏؆-؈؋؎؏۞۩۽۾߶߾߿࢈৲৳৺৻૱୰௳-௺౿൏൹฿༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭៛᥀᧞-᧿᭡-᭪᭴-᭼᾽᾿-῁῍-῏῝-῟῭-`´῾⁄⁒⁺-⁼₊-₌₠-⃀℀℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊↋←-⌇⌌-⌨⌫-␦⑀-⑊⒜-ⓩ─-❧➔-⟄⟇-⟥⟰-⦂⦙-⧗⧜-⧻⧾-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿゛゜㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꜀-꜖꜠꜡꞉꞊꠨-꠫꠶-꠹꩷-꩹꭛꭪꭫﬩﮲-﯂﵀-﵏﷏﷼-﷿﹢﹤-﹦﹩＄＋＜-＞＾｀｜～￠-￦￨-￮￼�",
        "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
      },
      {
        "name": "Sc",
        "alias": "Currency_Symbol",
        "bmp": "\\$¢-¥֏؋߾߿৲৳৻૱௹฿៛₠-⃀꠸﷼﹩＄￠￡￥￦",
        "astral": "\uD807[\uDFDD-\uDFE0]|𞋿|𞲰"
      },
      {
        "name": "Sk",
        "alias": "Modifier_Symbol",
        "bmp": "\\^`¨¯´¸˂-˅˒-˟˥-˫˭˯-˿͵΄΅࢈᾽᾿-῁῍-῏῝-῟῭-`´῾゛゜꜀-꜖꜠꜡꞉꞊꭛꭪꭫﮲-﯂＾｀￣",
        "astral": "\uD83C[\uDFFB-\uDFFF]"
      },
      {
        "name": "Sm",
        "alias": "Math_Symbol",
        "bmp": "\\+<->\\|~¬±×÷϶؆-؈⁄⁒⁺-⁼₊-₌℘⅀-⅄⅋←-↔↚↛↠↣↦↮⇎⇏⇒⇔⇴-⋿⌠⌡⍼⎛-⎳⏜-⏡▷◁◸-◿♯⟀-⟄⟇-⟥⟰-⟿⤀-⦂⦙-⧗⧜-⧻⧾-⫿⬰-⭄⭇-⭌﬩﹢﹤-﹦＋＜-＞｜～￢￩-￬",
        "astral": "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
      },
      {
        "name": "So",
        "alias": "Other_Symbol",
        "bmp": "¦©®°҂֍֎؎؏۞۩۽۾߶৺୰௳-௸௺౿൏൹༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭᥀᧞-᧿᭡-᭪᭴-᭼℀℁℃-℆℈℉℔№℗℞-℣℥℧℩℮℺℻⅊⅌⅍⅏↊↋↕-↙↜-↟↡↢↤↥↧-↭↯-⇍⇐⇑⇓⇕-⇳⌀-⌇⌌-⌟⌢-⌨⌫-⍻⍽-⎚⎴-⏛⏢-␦⑀-⑊⒜-ⓩ─-▶▸-◀◂-◷☀-♮♰-❧➔-➿⠀-⣿⬀-⬯⭅⭆⭍-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꠨-꠫꠶꠷꠹꩷-꩹﵀-﵏﷏﷽-﷿￤￨￭￮￼�",
        "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFDC\uDFE1-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|𞅏|\uD83B[\uDCAC\uDD2E]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
      },
      {
        "name": "Z",
        "alias": "Separator",
        "bmp": "    - \u2028\u2029  　"
      },
      {
        "name": "Zl",
        "alias": "Line_Separator",
        "bmp": "\u2028"
      },
      {
        "name": "Zp",
        "alias": "Paragraph_Separator",
        "bmp": "\u2029"
      },
      {
        "name": "Zs",
        "alias": "Space_Separator",
        "bmp": "    -   　"
      }
    ];
  }
});

// node_modules/@retorquere/bibtex-parser/re.js
var require_re = __commonJS({
  "node_modules/@retorquere/bibtex-parser/re.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.categories = exports.match = void 0;
    function match(cats, extra, neg = false) {
      return `[${neg ? "^" : ""}${cats.map((cat) => cat.bmp).join("")}${extra || ""}]`;
    }
    exports.match = match;
    exports.categories = require_categories();
  }
});

// node_modules/@retorquere/bibtex-parser/yield.js
var require_yield = __commonJS({
  "node_modules/@retorquere/bibtex-parser/yield.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.playnice = void 0;
    async function playnice() {
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    exports.playnice = playnice;
  }
});

// node_modules/@retorquere/bibtex-parser/verbatim.js
var require_verbatim = __commonJS({
  "node_modules/@retorquere/bibtex-parser/verbatim.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.promises = exports.parse = exports.Library = void 0;
    var rx = __importStar(require_re());
    var yield_1 = require_yield();
    var ParsingError = class extends Error {
      constructor(message, parser) {
        message += ` at ${parser.location()}`;
        if (parser.parsing)
          message += ` in ${JSON.stringify(parser.parsing)}`;
        super(message);
        this.name = "ParsingError";
      }
    };
    var letter = new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^L[utlmo]$/))));
    var Library = class {
      constructor(input, options = {}) {
        this.entries = [];
        this.strings = {};
        this.comments = [];
        this.errors = [];
        this.preambles = [];
        this.default_strings = {
          JAN: "01",
          JANUARY: "01",
          FEB: "02",
          FEBRUARY: "02",
          MAR: "03",
          MARCH: "03",
          APR: "04",
          APRIL: "04",
          MAY: "05",
          JUN: "06",
          JUNE: "06",
          JUL: "07",
          JULY: "07",
          AUG: "08",
          AUGUST: "08",
          SEP: "09",
          SEPTEMBER: "09",
          OCT: "10",
          OCTOBER: "10",
          NOV: "11",
          NOVEMBER: "11",
          DEC: "12",
          DECEMBER: "12",
          ACMCS: "ACM Computing Surveys",
          ACTA: "Acta Informatica",
          CACM: "Communications of the ACM",
          IBMJRD: "IBM Journal of Research and Development",
          IBMSJ: "IBM Systems Journal",
          IEEESE: "IEEE Transactions on Software Engineering",
          IEEETC: "IEEE Transactions on Computers",
          IEEETCAD: "IEEE Transactions on Computer-Aided Design of Integrated Circuits",
          IPL: "Information Processing Letters",
          JACM: "Journal of the ACM",
          JCSS: "Journal of Computer and System Sciences",
          SCP: "Science of Computer Programming",
          SICOMP: "SIAM Journal on Computing",
          TOCS: "ACM Transactions on Computer Systems",
          TODS: "ACM Transactions on Database Systems",
          TOG: "ACM Transactions on Graphics",
          TOMS: "ACM Transactions on Mathematical Software",
          TOOIS: "ACM Transactions on Office Information Systems",
          TOPLAS: "ACM Transactions on Programming Languages and Systems",
          TCS: "Theoretical Computer Science"
        };
        this.pos = 0;
        this.linebreaks = [];
        this.max_entries = options.max_entries || 0;
        this.input = input;
        this.parsing = null;
        if (typeof options.strings === "string") {
          this.input = options.strings + "\n" + input;
        } else if (options.strings) {
          for (const [k, v] of Object.entries(options.strings)) {
            this.default_strings[k.toUpperCase()] = v;
          }
        }
        let pos = input.indexOf("\n");
        while (pos !== -1) {
          this.linebreaks.push(pos);
          pos = input.indexOf("\n", pos + 1);
        }
      }
      parse() {
        this.bibtex();
        this.entries.reverse();
      }
      async parseAsync() {
        await this.bibtexAsync();
        this.entries.reverse();
      }
      isWhitespace(s, horizontalOnly = false) {
        return s === " " || s === "	" || !horizontalOnly && (s === "\r" || s === "\n");
      }
      match(s, sws = true) {
        this.skipWhitespace();
        if (this.input.substr(this.pos, s.length) !== s) {
          throw new ParsingError(`Token mismatch, expected ${JSON.stringify(s)}, found ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
        }
        this.pos += s.length;
        if (sws)
          this.skipWhitespace();
      }
      tryMatch(s, consume = false) {
        this.skipWhitespace();
        const match = this.input.substr(this.pos, s.length) === s;
        if (match && consume)
          this.pos += s.length;
        return match;
      }
      skipWhitespace() {
        while (this.pos < this.input.length && this.input[this.pos].match(/[ \t\r\n%]/)) {
          if (this.input[this.pos] === "%") {
            while (this.pos < this.input.length && this.input[this.pos] !== "\n")
              this.pos++;
          } else {
            this.pos++;
          }
        }
      }
      /*
      private fix_path() {
        // workaround for https://github.com/siefkenj/unified-latex/issues/94
        const path = '\\path|'
        const verb = path.replace('path', 'verb')
        if (this.input.substring(this.pos).startsWith(path)) {
          // eslint-disable-next-line prefer-template, no-magic-numbers
          this.input = this.input.substring(0, this.pos) + verb + this.input.substring(this.pos + path.length)
        }
      }
      */
      value_braces() {
        let bracecount = 0;
        this.match("{", false);
        const start = this.pos;
        let math = false;
        while (true) {
          switch (this.input[this.pos]) {
            case "\\":
              this.pos += 1;
              break;
            case "{":
              bracecount++;
              break;
            case "}":
              if (bracecount === 0) {
                if (math)
                  throw new ParsingError("Unclosed math section", this);
                this.pos++;
                return this.input.substring(start, this.pos - 1);
              }
              bracecount--;
              break;
            case "$":
              math = !math;
              break;
          }
          this.pos++;
          if (this.pos >= this.input.length) {
            throw new ParsingError(`Unterminated brace-value ${JSON.stringify(this.input.substr(start, 20))}`, this);
          }
        }
      }
      value_quotes() {
        this.match('"', false);
        const start = this.pos;
        let bracecount = 0;
        while (true) {
          switch (this.input[this.pos]) {
            case "\\":
              this.pos += 1;
              break;
            case "{":
              bracecount++;
              break;
            case "}":
              bracecount--;
              break;
            case '"':
              if (bracecount <= 0) {
                this.pos++;
                return this.input.substring(start, this.pos - 1);
              }
          }
          this.pos++;
          if (this.pos >= this.input.length) {
            throw new ParsingError(`Unterminated quote-value ${JSON.stringify(this.input.substr(start, 20))}`, this);
          }
        }
      }
      single_value() {
        if (this.tryMatch("{")) {
          return this.value_braces();
        } else if (this.tryMatch('"')) {
          return this.value_quotes();
        } else {
          const bare = this.key();
          if (bare.match(/^\d+$/))
            return bare;
          const u_bare = bare.toUpperCase();
          const resolved = this.strings[u_bare] || this.default_strings[u_bare];
          if (typeof resolved === "undefined") {
            this.error({
              error: `Unresolved @string reference ${JSON.stringify(bare)}`,
              input: ""
            });
          }
          return resolved || `{{${bare}}}`;
        }
      }
      location() {
        const lines = this.input.substring(0, this.pos).split("\n");
        return `line ${lines.length}, column ${lines[lines.length - 1].length + 1}`;
      }
      error(err) {
        if (this.errors.find((e) => e.error === err.error))
          return;
        this.errors.push(err);
      }
      value() {
        const values = [];
        values.push(this.single_value());
        while (this.tryMatch("#")) {
          this.match("#");
          values.push(this.single_value());
        }
        return values.join("");
      }
      key(allow = "") {
        const start = this.pos;
        while (true) {
          if (this.pos === this.input.length) {
            throw new ParsingError("Runaway key", this);
          }
          if (this.input[this.pos].match(/[+'a-zA-Z0-9&;_:\\./-]/) || this.input[this.pos].match(letter) || allow.includes(this.input[this.pos])) {
            this.pos++;
          } else {
            return this.input.substring(start, this.pos);
          }
        }
      }
      key_equals_value(key) {
        key = key || this.key();
        if (!key)
          return;
        if (!this.tryMatch("=")) {
          throw new ParsingError(`${key} = value expected, equals sign missing: ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
        }
        this.match("=");
        const val = this.value();
        if (this.parsing === "string") {
          this.strings[key.toUpperCase()] = val;
        } else {
          const bare = key.toLowerCase();
          let postfix = 0;
          while (typeof this.entries[0].fields[key = postfix ? `${bare}+duplicate-${postfix}` : bare] === "string") {
            postfix++;
          }
          this.entries[0].fields[key] = val;
        }
      }
      entry(d, guard) {
        if (this.tryMatch(guard))
          return;
        let key;
        if (this.tryMatch(",")) {
          key = "";
        } else {
          key = this.key('[]*"');
        }
        if (this.tryMatch("=")) {
          this.key_equals_value(key);
        } else {
          this.entries[0].key = key;
        }
        this.tryMatch(",", true);
        if (this.tryMatch(guard))
          return;
        this.key_equals_value();
        while (this.tryMatch(",", true)) {
          if (this.tryMatch(guard))
            return;
          this.key_equals_value();
        }
      }
      directive() {
        this.match("@");
        return this.key().toLowerCase();
      }
      string() {
        this.key_equals_value();
      }
      preamble() {
        this.preambles.push(this.value());
      }
      comment() {
        while (this.isWhitespace(this.input[this.pos], true))
          this.pos++;
        if (this.input[this.pos] === "{") {
          this.comments.push(this.value_braces());
        } else {
          const start = this.pos;
          while (this.input[this.pos] !== "\n" && this.pos < this.input.length)
            this.pos++;
          this.comments.push(this.input.substring(start, this.pos));
        }
      }
      hasMore() {
        if (this.max_entries && this.entries.length >= this.max_entries)
          return false;
        return this.pos < this.input.length;
      }
      bibtex() {
        while (this.hasMore()) {
          this.parseNext();
        }
      }
      async bibtexAsync() {
        let n = 1;
        while (this.hasMore()) {
          this.parseNext();
          if (n++ % 1e3 === 0)
            await (0, yield_1.playnice)();
        }
      }
      matchGuard() {
        for (const guard of ["{}", "()"]) {
          if (this.tryMatch(guard[0])) {
            this.match(guard[0]);
            return guard[1];
          }
        }
        throw new ParsingError(`Token mismatch, expected '{' or '(', found ${JSON.stringify(this.input.substr(this.pos, 20))}...`, this);
      }
      parseNext() {
        this.skipWhitespace();
        while (this.pos < this.input.length && this.input[this.pos] !== "@") {
          if (this.input[this.pos] === "%") {
            while (this.pos < this.input.length && this.input[this.pos] !== "\n")
              this.pos++;
          } else {
            this.pos++;
          }
        }
        if (this.pos >= this.input.length)
          return;
        let guard = "";
        const start = this.pos;
        try {
          const d = this.parsing = this.directive();
          switch (d) {
            case "string":
              guard = this.matchGuard();
              this.string();
              this.match(guard);
              break;
            case "preamble":
              this.preamble();
              break;
            case "comment":
              this.comment();
              break;
            default:
              guard = this.matchGuard();
              this.entries.unshift({ input: "", type: d, key: "", fields: {} });
              this.entry(d, guard);
              this.match(guard);
              this.entries[0].input = this.input.substring(start, this.pos).trim();
              break;
          }
        } catch (err) {
          if (err.name !== "ParsingError")
            throw err;
          this.pos = start + 1;
          while (this.pos < this.input.length && this.input[this.pos] !== "@")
            this.pos++;
          this.error({
            error: err.message,
            input: this.input.substring(start, this.pos)
          });
        }
      }
    };
    exports.Library = Library;
    function parse(input, options = {}) {
      const parser = new Library(input, options);
      parser.parse();
      return parser;
    }
    exports.parse = parse;
    exports.promises = {
      async parse(input, options = {}) {
        const parser = new Library(input, options);
        await parser.parseAsync();
        return parser;
      }
    };
  }
});

// node_modules/@retorquere/bibtex-parser/jabref.js
var require_jabref = __commonJS({
  "node_modules/@retorquere/bibtex-parser/jabref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    function decode(s, sep = ";") {
      s = s.replace(/\r?\n/g, "");
      let pos = 0;
      const records = [""];
      while (pos < s.length) {
        switch (s[pos]) {
          case "\\":
            pos++;
            records[0] += s[pos];
            break;
          case sep:
            records.unshift("");
            break;
          default:
            records[0] += s[pos];
        }
        pos++;
      }
      return records.reverse().filter((record) => record);
    }
    function parse(comments) {
      const result = {
        root: [],
        groups: {}
      };
      const levels = [];
      const decoded = {
        fileDirectory: null,
        groupsversion: null,
        groupstree: null,
        grouping: null,
        databaseType: null
      };
      comments = comments.filter((comment) => {
        const m = comment.match(/^jabref-meta:\s*([^:]+):([\s\S]*)/);
        if (m) {
          decoded[m[1]] = decode(m[2]);
          return false;
        }
        return true;
      });
      if (decoded.groupsversion)
        result.groupsversion = parseInt(decoded.groupsversion[0].trim()) || decoded.groupsversion[0];
      if (decoded.fileDirectory)
        result.fileDirectory = decoded.fileDirectory[0];
      if (decoded.databaseType)
        result.databaseType = decoded.databaseType[0];
      for (const tree of ["groupstree", "grouping"]) {
        if (!decoded[tree])
          continue;
        for (const encoded of decoded[tree]) {
          const fields = decode(encoded);
          const level_type_name = decode(fields.shift(), ":");
          const m = /^([0-9]+) (.+)/.exec(level_type_name[0]);
          if (!m)
            break;
          const level = parseInt(m[1]);
          const type = m[2];
          if (type === "AllEntriesGroup")
            continue;
          const name = level_type_name[1];
          const intersection = decode(fields.shift())[0];
          const keys = tree === "grouping" ? [] : fields.map((field) => decode(field)[0]);
          const group = {
            name,
            entries: keys,
            groups: []
          };
          result.groups[name] = result.groups[name] || group;
          if (levels.length < level) {
            levels.push(group);
          } else {
            levels[level - 1] = group;
          }
          if (level === 1) {
            result.root.push(group);
          } else {
            const parent = levels[level - 2];
            switch (intersection) {
              case "0":
                break;
              case "1":
                group.entries = group.entries.filter((key) => parent.entries.includes(key));
                break;
              case "2":
                group.entries = group.entries.concat(parent.entries.filter((key) => !group.entries.includes(key)));
                break;
            }
            levels[level - 2].groups.push(group);
          }
        }
      }
      return { comments, jabref: result };
    }
    exports.parse = parse;
  }
});

// node_modules/moo/moo.js
var require_moo = __commonJS({
  "node_modules/moo/moo.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.moo = factory();
      }
    })(exports, function() {
      "use strict";
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length) return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
          if (obj.global) throw new Error("RegExp /g flag is implied");
          if (obj.sticky) throw new Error("RegExp /y flag is implied");
          if (obj.multiline) throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string, numLines) {
        var position = string.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string.substring(startPosition).split("\n");
      }
      function objectToRules(object) {
        var keys = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          var obj = array[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }
        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true) flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map) {
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys = Object.getOwnPropertyNames(states);
        if (!start) start = keys[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include) continue;
            var splice = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1) continue;
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j--;
          }
        }
        var map = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          map[key] = compileRules(ruleMap[key], true);
        }
        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var state = map[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map);
          }
        }
        return new Lexer(map, start);
      }
      function keywordTransform(map) {
        var isMap = typeof Map !== "undefined";
        var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map);
        for (var i = 0; i < types.length; i++) {
          var tokenType = types[i];
          var item = map[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== void 0) {
            return this.groups[i];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err = new Error(this.formatError(token, "invalid syntax"));
          throw err;
        }
        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i = 0; i < displayedLines.length; i++) {
          var line = displayedLines[i];
          var lineNo = firstDisplayedLine + i;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// node_modules/@retorquere/bibtex-parser/prepositions.json
var require_prepositions = __commonJS({
  "node_modules/@retorquere/bibtex-parser/prepositions.json"(exports, module) {
    module.exports = [
      "a",
      "about",
      "above",
      "according to",
      "across",
      "after",
      "against",
      "ahead of",
      "along",
      "although",
      "among",
      "an",
      "and",
      "apart from",
      "around",
      "as for",
      "as if",
      "as long as",
      "as of",
      "as per",
      "as regards",
      "as soon as",
      "as",
      "aside from",
      "at",
      "back to",
      "because of",
      "because",
      "before",
      "behind",
      "below",
      "beneath",
      "beside",
      "between",
      "but",
      "by",
      "close to",
      "down",
      "due to",
      "during",
      "except for",
      "far from",
      "for",
      "from",
      "if",
      "in",
      "inside of",
      "inside",
      "instead of",
      "into",
      "like",
      "near",
      "next to",
      "nor",
      "of",
      "off",
      "on",
      "onto",
      "or",
      "out",
      "outside of",
      "over",
      "owing to",
      "prior to",
      "pursuant to",
      "regardless of",
      "right of",
      "since",
      "so",
      "subsequent to",
      "the",
      "through",
      "to",
      "towards",
      "under",
      "underneath",
      "unless",
      "until",
      "up",
      "upon",
      "when",
      "while",
      "with",
      "within",
      "without",
      "yet"
    ];
  }
});

// node_modules/@retorquere/bibtex-parser/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/@retorquere/bibtex-parser/tokenizer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenize = void 0;
    var moo_1 = __importDefault(require_moo());
    var rx = __importStar(require_re());
    var L = rx.match(rx.categories.filter((cat) => cat.name === "L"));
    var LNM = rx.match(rx.categories.filter((cat) => cat.name.match(/^[LNM]/)), "­⁠");
    var W = `${LNM}*?${L}${LNM}*`;
    var B = `(?=(?:${rx.match(rx.categories.filter((cat) => cat.name.match(/^[LNM]/)), "­⁠").replace(/^./, "[^")}|$))`;
    var Word = new RegExp(`${W}${B}`);
    var P = new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^P/))));
    var Lu = rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"), "⁠");
    var Acronym = new RegExp(`(?:(?:(?:${Lu}[.]){2,}${B})|(?:(?:vs?[.])(?=[ 	
\r ])))`);
    var Contraction = new RegExp(`${W}['’]${W}${B}`);
    var Whitespace = /[ \t\n\r\u00A0]+/;
    var Ordinal = new RegExp(`\\d+(?:st|nd|rd|th)${B}`);
    var Email = new RegExp(`[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+(?:[.][A-Za-z0-9-]+)+${B}`);
    var Handle = new RegExp(`@[A-Za-z0-9-]{2,}${B}`);
    var Int = new RegExp(`\\d+${B}`);
    var Domain = new RegExp(`${W}(?:[.]${W})+${B}`);
    var Website = new RegExp(`https?://${W}(?:[.]${W})+(?:[^.!? 	
\r ]+|[.!?]${LNM})+`);
    var ComplexPreposition = /^([^ \t\n\r\u00A0]+)([ \t\n\r\u00A0]+)([^ \t\n\r\u00A0]+)(?:([ \t\n\r\u00A0]+)([^ \t\n\r\u00A0]+))?$/;
    function ci(s) {
      return s.replace(/[a-z]/ig, (match) => `[${match.toUpperCase()}${match.toLowerCase()}]`).replace(" ", Whitespace.source);
    }
    var prepositions = require_prepositions().sort().reverse().map(ci).join("|");
    var Preposition = new RegExp(`(?:${prepositions})${B}`);
    var lexer = moo_1.default.compile({
      "word-preposition": Preposition,
      "word-acronym": Acronym,
      "word-contraction": Contraction,
      "word-ordinal": Ordinal,
      email: Email,
      handle: Handle,
      website: Website,
      domain: Domain,
      word: Word,
      number: Int,
      // eslint-disable-line id-blacklist
      "punctuation-end": /[?.!](?=[ \t\n\r\u00A0]|$)/,
      "punctuation-colon": /:(?=[ \t\n\r\u00A0])/,
      "punctuation-ellipsis": /[.][.][.]/,
      punctuation: P,
      whitespace: { match: /[ \t\n\r\u00A0]/, lineBreaks: true },
      other: { match: /[\s\S]/, lineBreaks: true }
    });
    var Shape = new class {
      constructor() {
        this.shapes = {};
        this.re = {
          X: new RegExp(rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"))),
          x: new RegExp(rx.match(rx.categories.filter((cat) => cat.name.match(/^L[^Cut]/)))),
          d: new RegExp(rx.match(rx.categories.filter((cat) => cat.name[0] === "N")))
        };
      }
      match(c) {
        if (c.match(this.re.d))
          return "d";
        if (c.toLowerCase() === c.toUpperCase())
          return c;
        if (c.match(this.re.X))
          return "X";
        if (c.match(this.re.x))
          return "x";
        if (c === "’")
          return "'";
        if (c === "–")
          return "-";
        if (c === "⁠" || c === "­")
          return "";
        return c;
      }
      fetch(c) {
        if (typeof this.shapes[c] === "undefined")
          this.shapes[c] = this.match(c);
        return this.shapes[c];
      }
      shape(t) {
        if (!this.shapes[t])
          this.shapes[t] = Array.from(t).map((c) => this.fetch(c)).join("");
        return this.shapes[t];
      }
    }();
    function combine(tokens) {
      const combined = Object.assign({}, tokens[0]);
      for (const t of tokens.slice(1)) {
        combined.text += t.text;
        combined.end = t.end;
        combined.shape += t.shape;
      }
      return combined;
    }
    function hyphenate(t) {
      if (t.type === "word")
        return "w";
      if (t.text === "-" || t.text === "–")
        return "-";
      return " ";
    }
    function tokenize(title, markup) {
      if (markup)
        title = title.replace(markup, (match) => "⁠".repeat(match.length));
      lexer.reset(title);
      const tokens = [];
      let sentenceStart = true;
      let subSentenceStart = false;
      for (const token of lexer) {
        const [type, subtype] = (token.type.includes("-") ? token.type : `${token.type}-`).split("-");
        tokens.push({
          type,
          subtype,
          text: token.text,
          start: token.offset,
          end: token.offset + token.text.length - 1,
          shape: Shape.shape(token.text),
          sentenceStart: type === "word" && sentenceStart,
          subSentenceStart: type === "word" && subSentenceStart
        });
        switch (token.type) {
          case "punctuation-end":
            sentenceStart = true;
            break;
          case "punctuation-colon":
            subSentenceStart = true;
            break;
          default:
            if (type.match(/word|number|handle|domain|website/)) {
              sentenceStart = false;
              subSentenceStart = false;
            }
            break;
        }
      }
      const stack = tokens.splice(0);
      let cpt;
      let cps;
      while (stack.length) {
        if (stack[0].subtype === "preposition" && (cpt = stack[0].text.match(ComplexPreposition)) && (cps = stack[0].shape.match(ComplexPreposition))) {
          const complex = stack.shift();
          let start = complex.start;
          let end;
          for (const i of Array.from({ length: 5 }, (_, n) => n + 1)) {
            if (!cpt[i])
              break;
            end = start + cps[i].length - 1;
            tokens.push(Object.assign(Object.assign({}, complex), {
              text: cpt[i],
              shape: cps[i],
              start,
              end,
              type: i % 2 ? complex.type : "whitespace",
              subtype: i % 2 ? complex.type : ""
            }));
            start = end + 1;
          }
          continue;
        }
        const pat = stack.map((t) => hyphenate(t)).join("");
        if (cpt = pat.match(/^w(-w)+(?= |$)/)) {
          const hyphenated = stack.splice(0, cpt[0].length);
          tokens.push(Object.assign(Object.assign({}, combine(hyphenated)), { hyphenated }));
          continue;
        }
        tokens.push(stack.shift());
      }
      return markup ? tokens.map((token) => Object.assign(Object.assign({}, token), { text: title.substring(token.start, token.end + 1) })) : tokens;
    }
    exports.tokenize = tokenize;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge;
  }
});

// node_modules/@retorquere/bibtex-parser/merge.js
var require_merge = __commonJS({
  "node_modules/@retorquere/bibtex-parser/merge.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = __importDefault(require_lodash());
    function merge(options, defaults) {
      return (0, lodash_merge_1.default)(defaults, options);
    }
    exports.merge = merge;
  }
});

// node_modules/@retorquere/bibtex-parser/sentence-case.js
var require_sentence_case = __commonJS({
  "node_modules/@retorquere/bibtex-parser/sentence-case.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toSentenceCase = void 0;
    var tokenizer_1 = require_tokenizer();
    var merge_1 = require_merge();
    var rx = __importStar(require_re());
    var Lu = rx.match(rx.categories.filter((cat) => cat.name === "Lu" || cat.name === "Lt"));
    var Ll = rx.match(rx.categories.filter((cat) => cat.name === "Ll"));
    var connectedInnerWord = new RegExp(`-${Lu}${Ll}*(?=-|$)`, "g");
    function titleCase(s) {
      return s.replace(/^(.)(.+)/, (match, car, cdr) => `${car}${cdr.toLowerCase()}`);
    }
    function wordSC(token, allCaps, subSentence, hyphenated) {
      if (token.type === "domain")
        return token.text.toLowerCase();
      if (token.type !== "word")
        return token.text;
      if (token.text.match(/^I'/))
        return titleCase(token.text);
      if (subSentence && token.subSentenceStart && token.text.match(/^a$/i))
        return "a";
      if (subSentence && token.subSentenceStart || token.sentenceStart) {
        return allCaps ? titleCase(token.text) : token.text.replace(connectedInnerWord, (match) => match.toLowerCase());
      }
      if (token.subtype === "preposition")
        return token.text.toLowerCase();
      if (token.subtype === "acronym")
        return token.text;
      if (token.text.match(/^[B-Z]$/))
        return hyphenated ? token.text.toLowerCase() : token.text;
      const shape = token.shape.replace(/[^-Xxd]/g, "");
      if (shape.match(/^[Xd]+$/))
        return allCaps ? token.text.toLowerCase() : token.text;
      if (shape.match(/x.*X/))
        return token.text;
      return token.text.toLowerCase();
    }
    function toSentenceCase(title, options = {}) {
      options = (0, merge_1.merge)(options, {
        preserveQuoted: true,
        subSentenceCapitalization: true,
        guess: false
      });
      const allCaps = title === title.toUpperCase();
      const allLower = title === title.toLowerCase();
      if (options.guess && !allCaps && !allLower) {
        let $title = title;
        if (options.nocase)
          $title = $title.replace(options.nocase, (match) => match.match(/\s/) ? " " : "");
        if (options.markup)
          $title = $title.replace(options.markup, "");
        const guess = {
          words: (0, tokenizer_1.tokenize)($title),
          sc: 0,
          other: 0
        };
        guess.words.forEach((token, i) => {
          if (token.type === "word" && token.text.length > 1 && !token.subtype.match(/preposition|acronym|ordinal/) && (i === 0 || guess.words[i - 1].type === "whitespace")) {
            guess[token.shape.match(/^[^X]*x[^X]*$/) ? "sc" : "other"] += 1;
          }
        });
        if (guess.sc && guess.sc >= guess.other)
          return title;
      }
      if (allCaps && !title.match(/\s/))
        return title;
      const tokens = (0, tokenizer_1.tokenize)(title, options.markup);
      let sentenceCased = "";
      for (const token of tokens) {
        if (token.hyphenated && token.shape[0] === "x") {
          sentenceCased += token.text;
        } else if (token.hyphenated) {
          for (const t of token.hyphenated) {
            sentenceCased += wordSC(t, allCaps, options.subSentenceCapitalization, true);
          }
        } else {
          sentenceCased += wordSC(token, allCaps, options.subSentenceCapitalization, false);
        }
      }
      if (options.markup) {
        for (const match of title.matchAll(options.markup)) {
          sentenceCased = sentenceCased.substring(0, match.index) + match[0] + sentenceCased.substring(match.index + match[0].length);
        }
      }
      if (options.nocase) {
        sentenceCased = sentenceCased.replace(options.nocase, (match, tag, offset) => title.substring(offset, offset + match.length));
      }
      if (options.preserveQuoted) {
        for (const q of [/“.*?”/g, /‘.*?’/g, /".*?"/g]) {
          sentenceCased = sentenceCased.replace(q, (match, offset) => title.substring(offset, offset + match.length));
        }
      }
      return sentenceCased;
    }
    exports.toSentenceCase = toSentenceCase;
  }
});

// node_modules/@retorquere/bibtex-parser/crossref.json
var require_crossref = __commonJS({
  "node_modules/@retorquere/bibtex-parser/crossref.json"(exports, module) {
    module.exports = {
      "*": {
        "*": {
          verbb: "verba"
        }
      },
      article: {
        periodical: {
          journalsubtitle: "subtitle",
          journaltitle: "title"
        }
      },
      book: {
        mvbook: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      bookinbook: {
        book: {
          author: "author",
          bookauthor: "author",
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvbook: {
          author: "author",
          bookauthor: "author",
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      collection: {
        mvcollection: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        mvreference: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      inbook: {
        "*": {
          bookauthor: "author"
        },
        book: {
          author: "author",
          bookauthor: "author",
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvbook: {
          author: "author",
          bookauthor: "author",
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      incollection: {
        collection: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvcollection: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        mvreference: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        reference: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        }
      },
      inproceedings: {
        mvproceedings: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        proceedings: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        }
      },
      inreference: {
        collection: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvcollection: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        mvreference: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        reference: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        }
      },
      proceedings: {
        mvproceedings: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      reference: {
        mvcollection: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        mvreference: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      suppbook: {
        book: {
          author: "author",
          bookauthor: "author",
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvbook: {
          author: "author",
          bookauthor: "author",
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        }
      },
      suppcollection: {
        collection: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        },
        mvcollection: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        mvreference: {
          mainsubtitle: "subtitle",
          maintitle: "title",
          maintitleaddon: "titleaddon"
        },
        reference: {
          booksubtitle: "subtitle",
          booktitle: "title",
          booktitleaddon: "titleaddon"
        }
      },
      suppperiodical: {
        periodical: {
          journalsubtitle: "subtitle",
          journaltitle: "title"
        }
      }
    };
  }
});

// node_modules/@retorquere/bibtex-parser/fields.json
var require_fields = __commonJS({
  "node_modules/@retorquere/bibtex-parser/fields.json"(exports, module) {
    module.exports = {
      article: [
        "abstract",
        "addendum",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "commentator",
        "crossref",
        "day",
        "doi",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "issn",
        "issue",
        "issuesubtitle",
        "issuetitle",
        "issuetitleaddon",
        "iswc",
        "journalsubtitle",
        "journaltitle",
        "journaltitleaddon",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "volume",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      artwork: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      audio: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      bibnote: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      book: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      bookinbook: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookauthor",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      booklet: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "chapter",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "howpublished",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      collection: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "authortype",
        "bookpagination",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      commentary: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      customa: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      customb: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      customc: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      customd: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      custome: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      customf: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      dataset: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      image: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      inbook: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookauthor",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      incollection: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      inproceedings: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "eventday",
        "eventendday",
        "eventendhour",
        "eventendminute",
        "eventendmonth",
        "eventendsecond",
        "eventendtimezone",
        "eventendyear",
        "eventendyeardivision",
        "eventhour",
        "eventminute",
        "eventmonth",
        "eventsecond",
        "eventtimezone",
        "eventtitle",
        "eventtitleaddon",
        "eventyear",
        "eventyeardivision",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "venue",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      inreference: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      jurisdiction: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      legal: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      legislation: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      letter: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      manual: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "chapter",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      misc: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "howpublished",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      movie: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      music: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      mvbook: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagetotal",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      mvcollection: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      mvproceedings: [
        "abstract",
        "addendum",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "eventday",
        "eventendday",
        "eventendhour",
        "eventendminute",
        "eventendmonth",
        "eventendsecond",
        "eventendtimezone",
        "eventendyear",
        "eventendyeardivision",
        "eventhour",
        "eventminute",
        "eventmonth",
        "eventsecond",
        "eventtimezone",
        "eventtitle",
        "eventtitleaddon",
        "eventyear",
        "eventyeardivision",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagetotal",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "venue",
        "verba",
        "verbb",
        "verbc",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      mvreference: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      online: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      patent: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "holder",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      performance: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      periodical: [
        "abstract",
        "addendum",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "issn",
        "issue",
        "issuesubtitle",
        "issuetitle",
        "issuetitleaddon",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      proceedings: [
        "abstract",
        "addendum",
        "annotation",
        "authortype",
        "bookpagination",
        "chapter",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "eventday",
        "eventendday",
        "eventendhour",
        "eventendminute",
        "eventendmonth",
        "eventendsecond",
        "eventendtimezone",
        "eventendyear",
        "eventendyeardivision",
        "eventhour",
        "eventminute",
        "eventmonth",
        "eventsecond",
        "eventtimezone",
        "eventtitle",
        "eventtitleaddon",
        "eventyear",
        "eventyeardivision",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "venue",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      reference: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "authortype",
        "bookpagination",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      report: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "chapter",
        "crossref",
        "day",
        "doi",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "institution",
        "isan",
        "ismn",
        "isrn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      review: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      set: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      software: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "editor",
        "editortype",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "howpublished",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "organization",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "version",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      standard: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      suppbook: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookauthor",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      suppcollection: [
        "abstract",
        "addendum",
        "afterword",
        "annotation",
        "annotator",
        "author",
        "authortype",
        "bookpagination",
        "booksubtitle",
        "booktitle",
        "booktitleaddon",
        "chapter",
        "commentator",
        "crossref",
        "day",
        "doi",
        "edition",
        "editor",
        "editora",
        "editoratype",
        "editorb",
        "editorbtype",
        "editorc",
        "editorctype",
        "editortype",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "foreword",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "introduction",
        "isan",
        "isbn",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "mainsubtitle",
        "maintitle",
        "maintitleaddon",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "number",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlanguage",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagination",
        "part",
        "presort",
        "publisher",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "series",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "translator",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "volume",
        "volumes",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      suppperiodical: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      thesis: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "chapter",
        "crossref",
        "day",
        "doi",
        "eid",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "institution",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pages",
        "pagetotal",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      unpublished: [
        "abstract",
        "addendum",
        "annotation",
        "author",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "eventday",
        "eventendday",
        "eventendhour",
        "eventendminute",
        "eventendmonth",
        "eventendsecond",
        "eventendtimezone",
        "eventendyear",
        "eventendyeardivision",
        "eventhour",
        "eventminute",
        "eventmonth",
        "eventsecond",
        "eventtimezone",
        "eventtitle",
        "eventtitleaddon",
        "eventyear",
        "eventyeardivision",
        "execute",
        "file",
        "gender",
        "hour",
        "howpublished",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "language",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "location",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "note",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "pubstate",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "subtitle",
        "timezone",
        "title",
        "titleaddon",
        "type",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "venue",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      video: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ],
      xdata: [
        "abstract",
        "annotation",
        "authortype",
        "bookpagination",
        "crossref",
        "day",
        "doi",
        "endday",
        "endhour",
        "endminute",
        "endmonth",
        "endsecond",
        "endtimezone",
        "endyear",
        "endyeardivision",
        "entryset",
        "entrysubtype",
        "eprint",
        "eprintclass",
        "eprinttype",
        "execute",
        "file",
        "gender",
        "hour",
        "ids",
        "indexsorttitle",
        "indextitle",
        "isan",
        "ismn",
        "iswc",
        "keywords",
        "label",
        "langid",
        "langidopts",
        "library",
        "lista",
        "listb",
        "listc",
        "listd",
        "liste",
        "listf",
        "minute",
        "month",
        "namea",
        "nameaddon",
        "nameatype",
        "nameb",
        "namebtype",
        "namec",
        "namectype",
        "options",
        "origday",
        "origendday",
        "origendhour",
        "origendminute",
        "origendmonth",
        "origendsecond",
        "origendtimezone",
        "origendyear",
        "origendyeardivision",
        "orighour",
        "origlocation",
        "origminute",
        "origmonth",
        "origpublisher",
        "origsecond",
        "origtimezone",
        "origtitle",
        "origyear",
        "origyeardivision",
        "pagination",
        "presort",
        "related",
        "relatedoptions",
        "relatedstring",
        "relatedtype",
        "second",
        "shortauthor",
        "shorteditor",
        "shorthand",
        "shorthandintro",
        "shortjournal",
        "shortseries",
        "shorttitle",
        "sortkey",
        "sortname",
        "sortshorthand",
        "sorttitle",
        "sortyear",
        "timezone",
        "url",
        "urlday",
        "urlendday",
        "urlendhour",
        "urlendminute",
        "urlendmonth",
        "urlendsecond",
        "urlendtimezone",
        "urlendyear",
        "urlhour",
        "urlminute",
        "urlmonth",
        "urlsecond",
        "urltimezone",
        "urlyear",
        "usera",
        "userb",
        "userc",
        "userd",
        "usere",
        "userf",
        "verba",
        "verbb",
        "verbc",
        "xdata",
        "xref",
        "year",
        "yeardivision"
      ]
    };
  }
});

// node_modules/@retorquere/bibtex-parser/index.js
var require_bibtex_parser = __commonJS({
  "node_modules/@retorquere/bibtex-parser/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAsync = exports.parse = exports.English = exports.FieldMode = exports.toSentenceCase = void 0;
    var unified_latex_util_replace_1 = require_unified_latex_util_replace();
    var unified_latex_util_pegjs_1 = require_unified_latex_util_pegjs();
    var unified_latex_util_visit_1 = require_unified_latex_util_visit();
    var unified_latex_util_print_raw_1 = require_unified_latex_util_print_raw();
    var unicode2latex_1 = require_unicode2latex();
    var bibtex = __importStar(require_verbatim());
    var JabRef = __importStar(require_jabref());
    var sentence_case_1 = require_sentence_case();
    Object.defineProperty(exports, "toSentenceCase", { enumerable: true, get: function() {
      return sentence_case_1.toSentenceCase;
    } });
    var sentence_case_2 = require_sentence_case();
    var tokenizer_1 = require_tokenizer();
    var yield_1 = require_yield();
    var crossref_json_1 = __importDefault(require_crossref());
    var fields_json_1 = __importDefault(require_fields());
    var merge_1 = require_merge();
    function latexMode(node) {
      return node._renderInfo.mode;
    }
    function latex2unicode(tex, node) {
      const text = unicode2latex_1.latex2unicode[tex];
      if (typeof text === "string")
        return text;
      return text && text[latexMode(node)];
    }
    var open = {};
    var close = {};
    for (const tag of ["i", "b", "sc", "nc", "ncx", "br", "p", "li", "code"]) {
      open[tag] = `${tag}`;
      close[tag] = `/${tag}`;
    }
    var collapsable = /\x0E\/([a-z]+)\x0F(\s*)\x0E\1\x0F/ig;
    var Month = {
      jan: "1",
      january: "1",
      feb: "2",
      february: "2",
      mar: "3",
      march: "3",
      apr: "4",
      april: "4",
      may: "5",
      jun: "6",
      june: "6",
      jul: "7",
      july: "7",
      aug: "8",
      august: "8",
      sep: "9",
      september: "9",
      oct: "10",
      october: "10",
      nov: "11",
      november: "11",
      dec: "12",
      december: "12"
    };
    exports.FieldMode = {
      creatorlist: [
        "author",
        "bookauthor",
        "collaborator",
        "commentator",
        "director",
        "editor",
        "editora",
        "editorb",
        "editors",
        "holder",
        "scriptwriter",
        "translator"
      ],
      title: [
        "title",
        "subtitle",
        "series",
        "shorttitle",
        "booktitle",
        // 'type',
        "origtitle",
        "maintitle",
        "eventtitle"
      ],
      verbatim: [
        "doi",
        "eprint",
        "file",
        "files",
        "pdf",
        "groups",
        // jabref unilaterally decided to make this non-standard field verbatim
        "ids",
        "url",
        "verba",
        "verbb",
        "verbc",
        /^keywords([+]duplicate-\d+)?$/,
        /^citeulike-linkout-[0-9]+$/,
        /^bdsk-url-[0-9]+$/
      ],
      richtext: [
        "annotation",
        "comment",
        "annote",
        "review",
        "notes",
        "note"
      ],
      literallist: [
        "institution",
        "publisher",
        "origpublisher",
        "organization",
        "location",
        "origlocation"
      ]
    };
    exports.English = [
      "",
      "american",
      "british",
      "canadian",
      "english",
      "australian",
      "newzealand",
      "usenglish",
      "ukenglish",
      "en",
      "eng",
      "en-au",
      "en-bz",
      "en-ca",
      "en-cb",
      "en-gb",
      "en-ie",
      "en-jm",
      "en-nz",
      "en-ph",
      "en-tt",
      "en-us",
      "en-za",
      "en-zw",
      "anglais"
      // don't do this people
    ];
    var FieldAction = {
      removeOuterBraces: [
        "doi"
        // 'publisher',
        // 'location',
      ],
      parseInt: [
        "year",
        "month"
      ],
      noCrossRef: [
        "file"
      ]
    };
    var narguments = {
      advance: 1,
      ElsevierGlyph: 1,
      bar: 1,
      bibcyr: 1,
      bibstring: 1,
      chsf: 1,
      cite: 1,
      citeauthor: 1,
      cyrchar: 1,
      ding: 1,
      emph: 1,
      enquote: 1,
      frac: 2,
      hbox: 1,
      href: 2,
      hskip: 1,
      hspace: 1,
      ht: 1,
      mathrm: 1,
      mbox: 1,
      mkbibbold: 1,
      mkbibemph: 1,
      mkbibitalic: 1,
      mkbibquote: 1,
      newcommand: 2,
      noopsort: 1,
      ocirc: 1,
      overline: 1,
      ProvideTextCommandDefault: 2,
      rlap: 1,
      sb: 1,
      section: 1,
      sp: 1,
      subsection: 1,
      subsubsection: 1,
      subsubsubsection: 1,
      t: 1,
      textbf: 1,
      textcite: 1,
      textit: 1,
      textrm: 1,
      textsc: 1,
      textsl: 1,
      textsubscript: 1,
      textsuperscript: 1,
      texttt: 1,
      textup: 1,
      url: 1,
      vphantom: 1,
      vspace: 1,
      wd: 1,
      // math
      "math	_": 1,
      "math	^": 1
    };
    for (const m in unicode2latex_1.combining.tounicode) {
      narguments[m] = 1;
    }
    var BibTeXParser = class {
      constructor() {
        this.newcommands = {};
        this.unhandled = /* @__PURE__ */ new Set();
      }
      split(ast, sep, split) {
        const roots = [];
        const nodes = [...ast.content];
        const types = nodes.map((node) => {
          if (node.type === "whitespace")
            return " ";
          if (node.type === "string" && node.content.match(sep))
            return "&";
          return ".";
        }).join("");
        types.split(split).forEach((match, i) => {
          const content = match.length ? nodes.splice(0, match.length) : [];
          if (i % 2 === 0)
            roots.push({ type: "root", content });
        });
        return roots;
      }
      trimCreator(cr) {
        return JSON.parse(JSON.stringify(cr, (k, v) => typeof v === "string" ? v.trim() || void 0 : v));
      }
      parseCreator(ast) {
        if (ast.content.length === 1 && ast.content[0].type === "group")
          return this.trimCreator({ name: this.stringify(ast, { mode: "creatorlist" }) });
        const { parts, extended } = this.commaSeparatedCreator(ast);
        if (extended) {
          const name = {};
          for (const [attr, value] of Object.entries(extended)) {
            const rendered = this.stringify(value, { mode: "creatorlist" }).trim();
            switch (attr) {
              case "":
                break;
              case "given":
                name.firstName = rendered;
                break;
              case "family":
                name.lastName = rendered;
                break;
              case "given-i":
                name.initial = rendered;
                break;
              case "useprefix":
              case "juniorcomma":
                name[attr] = rendered.toLowerCase() === "true";
                break;
              default:
                name[attr] = rendered;
                break;
            }
          }
          return this.trimCreator(name);
        } else if (parts.length) {
          const nameparts = parts.map((part) => this.stringify(part, { mode: "creatorlist" }).trim());
          if (nameparts.length === 3 && nameparts[2] === "")
            nameparts.pop();
          if (nameparts.length > 3) {
            const key = this.current.key ? `@${this.current.key}: ` : "";
            this.bib.errors.push({
              // eslint-disable-next-line no-magic-numbers
              error: `${key}unexpected ${nameparts.length}-part name "${nameparts.join(", ")}", dropping "${nameparts.slice(3).join(", ")}"`,
              input: nameparts.join(", ")
            });
          }
          let [lastName, suffix, firstName] = nameparts.length === 2 ? [nameparts[0], void 0, nameparts[1]] : nameparts.slice(0, 3);
          let prefix;
          const m = lastName.match(/^([a-z'. ]+) (.+)/);
          if (m) {
            prefix = m[1];
            lastName = m[2];
          }
          return this.trimCreator({
            lastName,
            firstName,
            prefix,
            suffix
          });
        } else {
          const nameparts = this.split(ast, /^$/, /( )/).map((part) => this.stringify(part, { mode: "creatorlist" })).filter((n) => n);
          if (nameparts.length === 1)
            return this.trimCreator({ lastName: nameparts[0] });
          const prefix = nameparts.findIndex((n) => n.match(/^[a-z]/));
          const postfix = prefix <= 0 ? -1 : nameparts.findIndex((n, i) => i > prefix && !n.match(/^[a-z]/));
          if (postfix === -1) {
            const lastName = nameparts.pop();
            return this.trimCreator({ lastName, firstName: nameparts.join(" ") });
          }
          return this.trimCreator({
            firstName: nameparts.slice(0, prefix).join(" "),
            prefix: nameparts.slice(prefix, postfix).join(" "),
            lastName: nameparts.slice(postfix).join(" ")
          });
        }
      }
      ligature(nodes) {
        if (latexMode(nodes[0]) !== "text")
          return null;
        const max = 3;
        const slice = nodes.slice(0, max);
        const type = slice.map((n) => n.type === "string" ? "s" : " ").join("");
        if (type[0] !== "s")
          return null;
        const content = slice.map((n) => n.type === "string" ? n.content : "");
        let latex;
        while (content.length) {
          if (type.startsWith("s".repeat(content.length)) && (latex = latex2unicode(content.join(""), slice[0]))) {
            try {
              return { type: "string", content: latex, _renderInfo: {} };
            } finally {
              nodes.splice(0, content.length);
            }
          }
          content.pop();
        }
        return null;
      }
      wraparg(node, macro) {
        if (macro.content.match(/^(itshape|textsl|textit|emph|mkbibemph)$/))
          node._renderInfo.emph = true;
        if (macro.content.match(/^(textbf|mkbibbold|bfseries)$/))
          node._renderInfo.bold = true;
        if (macro.content.match(/^(textsc)$/))
          node._renderInfo.smallCaps = true;
        if (macro.content.match(/^(texttt)$/))
          node._renderInfo.code = true;
        return { type: "argument", content: [node], openMark: "", closeMark: "", _renderInfo: { mode: node._renderInfo.mode } };
      }
      argtogroup(node) {
        if (node.content.length === 1 && node.content[0].type === "group")
          return node.content[0];
        return { type: "group", content: node.content };
      }
      argument(nodes, macro) {
        if (!nodes.length)
          return null;
        if (nodes[0].type === "whitespace")
          nodes.shift();
        if (!nodes.length)
          return null;
        if (nodes[0].type === "string") {
          const char = nodes[0].content[0];
          nodes[0].content = nodes[0].content.substr(1);
          const arg = Object.assign(Object.assign({}, nodes[0]), { content: char });
          if (!nodes[0].content)
            nodes.shift();
          return this.wraparg(arg, macro);
        }
        return this.wraparg(nodes.shift(), macro);
      }
      unsupported(node) {
        var _a;
        const tex = (0, unified_latex_util_print_raw_1.printRaw)(node);
        if (this.fallback)
          return (_a = this.fallback(node, tex, this.current)) !== null && _a !== void 0 ? _a : "";
        let id;
        switch (node.type) {
          case "macro":
            id = `${node.type}.${node.content}`;
            if (!this.unhandled.has(id)) {
              this.unhandled.add(id);
              this.bib.errors.push({ error: `unhandled ${node.type} ${(0, unified_latex_util_print_raw_1.printRaw)(node)}`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
            }
            break;
          case "environment":
            id = `${node.type}.${node.env}`;
            if (!this.unhandled.has(id)) {
              this.unhandled.add(id);
              this.bib.errors.push({ error: `unhandled ${node.type} ${node.env} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
            }
            break;
          default:
            this.bib.errors.push({ error: `unhandled ${node.type} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
            break;
        }
        return tex;
      }
      wrap(text, tag, wrap = true) {
        if (!text || !wrap)
          return text || "";
        return `${tag}${text}/${tag}`;
      }
      registercommand(node) {
        const types = (nodes) => nodes.map((n) => n.type).join(".");
        const group = (arg, kind) => {
          if (!arg)
            throw new Error(`missing ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
          if (types(arg.content) !== "group")
            throw new Error(`Malformed ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
          return arg.content[0].content;
        };
        if (!node.args)
          throw new Error(`No arguments for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
        const namearg = group(node.args[0], "name");
        if (types(namearg) !== "macro")
          throw new Error(`Unexpected name for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
        this.newcommands[namearg[0].content] = node.args[1];
        return "";
      }
      subp(text, macro) {
        let subp = "";
        for (let char of text) {
          char = unicode2latex_1.latex2unicode[`${macro}{${char}}`];
          if (char) {
            subp += char;
          } else {
            const tag = { _: "sub", "^": "sup" }[macro];
            return `${tag}${text}/${tag}`;
          }
        }
        return subp;
      }
      macro(node, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const text = latex2unicode((0, unified_latex_util_print_raw_1.printRaw)(node), node);
        if (text)
          return text;
        let url;
        let label;
        let arg;
        let resolved;
        switch (node.content) {
          case "newcommand":
          case "ProvideTextCommandDefault":
            return this.registercommand(node);
          case "raise":
          case "accent":
          case "def":
          case "hss":
          case "ifmmode":
          case "makeatletter":
          case "makeatother":
          case "scriptscriptstyle":
          case "setbox":
          case "dimen":
          case "advance":
            return "";
          case "vphantom":
          case "noopsort":
          case "left":
          case "right":
          case "ensuremath":
          case "wd":
          case "ht":
            return "";
          case "path":
            return "";
          case "hspace":
          case "hskip":
            if (node.args && node.args.length) {
              if ((0, unified_latex_util_print_raw_1.printRaw)(node.args).match(/^[{]?0[a-z]*$/))
                return "";
              return " ";
            }
            return "";
          case "overline":
          case "bar":
            return node.args.map((a) => this.stringify(a, context)).join("").replace(/[a-z0-9]/ig, (m) => `${m}̅`);
          case "textup":
          case "textsc":
          case "textrm":
          case "texttt":
          case "mathrm":
          case "mbox":
          case "hbox":
          case "rlap":
            return node.args.map((n) => this.stringify(n, context)).join("");
          case "href":
          case "url":
            if (node.args) {
              url = node.args[0];
              label = node.args[node.content === "url" ? 0 : 1];
            }
            return `<a href="${this.stringify(url, context)}">${this.stringify(label, context)}</a>`;
          case "relax":
          case "aftergroup":
          case "ignorespaces":
          case "em":
          case "it":
          case "tt":
          case "sl":
            return "";
          case "rm":
          case "sc":
            return "";
          case "textbf":
          case "mkbibbold":
          case "textit":
          case "emph":
          case "mkbibemph":
            return this.stringify((_a = node.args) === null || _a === void 0 ? void 0 : _a[0], context);
          case "textsuperscript":
            return this.subp(this.stringify((_b = node.args) === null || _b === void 0 ? void 0 : _b[0], context), "^");
          case "textsubscript":
            return this.subp(this.stringify((_c = node.args) === null || _c === void 0 ? void 0 : _c[0], context), "_");
          case "_":
          case "^":
            switch (latexMode(node)) {
              case "math":
                return this.subp(this.stringify((_d = node.args) === null || _d === void 0 ? void 0 : _d[0], context), node.content);
              default:
                return node.content;
            }
          case "LaTeX":
            return this.wrap(`L${this.subp("A", "^")}T${this.subp("E", "_")}X`, "ncx");
          case "enquote":
          case "mkbibquote":
            return this.wrap(this.stringify((_e = node.args) === null || _e === void 0 ? void 0 : _e[0], context), "enquote");
          case "\\":
            return context.mode === "richtext" ? open.br : " ";
          case "par":
            return context.mode === "richtext" ? open.p : " ";
          case "item":
            return context.mode === "richtext" ? open.li : " ";
          case "section":
          case "subsection":
          case "subsubsection":
          case "subsubsubsection":
            return this.wrap(this.stringify((_f = node.args) === null || _f === void 0 ? void 0 : _f[0], context), `h${node.content.split("sub").length}`);
          case "frac":
            arg = node.args.map((a) => this.stringify(a, context));
            if (arg.length === 2 && (resolved = unicode2latex_1.latex2unicode[`\\frac${arg.map((a) => `{${a}}`).join("")}`]))
              return resolved;
            return arg.map((part, i) => this.subp(part, i ? "_" : "^")).join("⁄");
          case "chsf":
          case "bibstring":
          case "cite":
          case "textcite":
          case "citeauthor":
            return this.wrap(this.stringify((_g = node.args) === null || _g === void 0 ? void 0 : _g[0], context), "ncx", context.mode === "title");
          default:
            if (this.newcommands[node.content])
              return this.stringify(this.newcommands[node.content], context);
            return this.unsupported(node);
        }
      }
      what(node) {
        var _a;
        if (!node)
          return "";
        switch (node.type) {
          case "macro":
            return `macro:${(_a = node._renderInfo.mode) !== null && _a !== void 0 ? _a : "text"}:${node.content}`;
          case "environment":
            return `env:${node.env}`;
          default:
            return node.type;
        }
      }
      environment(node, context) {
        while (node.content.length && this.what(node.content[0]).match(/^parbreak|whitespace|macro:text:par$/))
          node.content.shift();
        while (node.content.length && this.what(node.content[node.content.length - 1]).match(/^parbreak|whitespace|macro:text:par$/))
          node.content.pop();
        switch (node.env) {
          case "quotation":
            return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "blockquote", context.mode === "richtext");
          case "itemize":
            return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "ul", context.mode === "richtext");
          case "em":
            return this.wrap(node.content.map((n) => this.stringify(n, context)).join(""), "i", context.mode === "richtext");
          default:
            return this.unsupported(node);
        }
      }
      stringify(node, context) {
        let content = this.stringifyContent(node, context);
        if (content && node._renderInfo) {
          if (node._renderInfo.emph)
            content = `${open.i}${content}${close.i}`;
          if (node._renderInfo.bold)
            content = `${open.b}${content}${close.b}`;
          if (node._renderInfo.smallCaps)
            content = `${open.sc}${content}${close.sc}`;
          if (node._renderInfo.code)
            content = `${open.code}${content}${close.code}`;
          if (this.english && node._renderInfo.protectCase)
            content = `${open.nc}${content}${close.nc}`;
        }
        return content;
      }
      stringifyContent(node, context) {
        if (!node)
          return "";
        switch (node.type) {
          case "root":
          case "argument":
          case "group":
          case "inlinemath":
            return node.content.map((n) => this.stringify(n, context)).join("");
          case "string":
          case "verbatim":
            return node.content;
          case "macro":
            return this.macro(node, context);
          case "parbreak":
            return context.mode === "richtext" ? open.p : " ";
          case "whitespace":
            return node._renderInfo.mode === "math" ? "" : " ";
          case "comment":
            return "";
          case "environment":
            return this.environment(node, context);
          case "verb":
            return node.content;
          default:
            return this.unsupported(node);
        }
      }
      protect(node) {
        if (node.type === "inlinemath")
          return true;
        if (node.type !== "group")
          return false;
        if (!node.content.length)
          return false;
        return node.content[0].type !== "macro";
      }
      mode(field) {
        if (this.options.verbatimFields && this.options.verbatimFields.find((name) => typeof name === "string" ? name === field : field.match(name)))
          return "verbatim";
        let mode = "literal";
        for (const [selected, fields] of Object.entries(this.fieldMode)) {
          if (fields.find((match) => typeof match === "string" ? field === match : field.match(match)))
            mode = selected;
        }
        return mode;
      }
      restoreMarkup(s) {
        if (!s.includes(""))
          return s;
        const restored = [s.replace(/\x0E\/?ncx\x0F/ig, "")];
        while (restored[0] !== restored[1]) {
          restored.unshift(restored[0].replace(collapsable, "$2"));
        }
        return restored[0].replace(/(\x0Ep\x0F\s*){2,}/ig, "p").replace(/\s*(\x0E\/p\x0F){2,}/ig, "/p").replace(/\x0Eenquote\x0F/ig, "“").replace(/\x0E\/enquote\x0F/ig, "”").replace(/\x0Esc\x0F/ig, '<span style="font-variant:small-caps;">').replace(/\x0E\/sc\x0F/ig, "</span>").replace(/\x0Enc\x0F/ig, '<span class="nocase">').replace(/\x0E\/nc\x0F/ig, "</span>").replace(/\x0E/ig, "<").replace(/\x0F/ig, ">");
      }
      stringField(field, value, mode, guessSC) {
        if (field === "crossref")
          return value;
        if (FieldAction.parseInt.includes(field) && value.trim().match(/^-?\d+$/))
          return `${parseInt(value)}`;
        if (this.english && mode === "title") {
          value = (0, sentence_case_2.toSentenceCase)(value, {
            preserveQuoted: this.options.sentenceCase.preserveQuoted,
            subSentenceCapitalization: this.options.sentenceCase.subSentence,
            markup: /\x0E\/?([a-z]+)\x0F/ig,
            nocase: /\x0E(ncx?)\x0F.*?\x0E\/\1\x0F/ig,
            guess: guessSC
          });
          let cancel = (_match, stripped) => stripped;
          switch (this.options.caseProtection) {
            case "strict":
              cancel = (match, _stripped) => match;
              break;
            case "as-needed":
              cancel = (match, stripped) => {
                const words = (0, tokenizer_1.tokenize)(stripped, /\x0E\/?([a-z]+)\x0F/ig);
                return words.find((w) => w.shape.match(/^(?!.*X).*x.*$/)) ? match : this.wrap(stripped, "ncx");
              };
              break;
          }
          return value.replace(/\x0Enc\x0F(.*?)\x0E\/nc\x0F/ig, cancel);
        }
        return value;
      }
      commaSeparatedCreator(ast) {
        var _a;
        const result = {
          parts: []
        };
        if (!ast.content.find((node) => node.type === "string" && node.content === ","))
          return result;
        result.parts = this.split(ast, /^,$/, /(&)/);
        result.extended = {};
        for (const part of result.parts) {
          const start = ((_a = part.content[0]) === null || _a === void 0 ? void 0 : _a.type) === "whitespace" ? 1 : 0;
          let signature = part.content.slice(start, start + 4).map((node, i) => node._renderInfo.mode === "text" && node.type === "string" ? node.content.replace(i % 2 ? /[^=-]/g : /[^a-z]/gi, ".") : ".").join("");
          if (signature.match(/^[a-z]+(-[a-z]+)?=/i)) {
            signature = signature.replace(/=.*/, "").toLowerCase();
            result.extended[signature] = { type: "root", content: part.content.slice(signature.includes("-") ? start + 4 : start + 2) };
          } else {
            delete result.extended;
            break;
          }
        }
        return result;
      }
      field(entry, field, value) {
        const mode = entry.mode[field] = this.mode(field);
        const caseProtection = {
          present: false,
          intuitive: 0
          // a lot of people don't realise `some text \textit{in italics}` will protect 'in italics'
        };
        const ast = unified_latex_util_pegjs_1.LatexPegParser.parse(value);
        if (this.options.removeOuterBraces.includes(field) && ast.content.length === 1 && ast.content[0].type === "group") {
          ast.content = ast.content[0].content;
        }
        if (mode === "verbatim") {
          entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
          return;
        }
        if (this.english && mode === "title") {
          let root = [...ast.content];
          while (root.length) {
            const node = root.shift();
            if (this.protect(node))
              node._renderInfo = { root: true };
            if (node.type === "environment")
              root = [...root, ...node.content];
          }
        }
        (0, unified_latex_util_visit_1.visit)(ast, (node, info) => {
          if (!node._renderInfo)
            node._renderInfo = {};
          node._renderInfo.mode = info.context.inMathMode ? "math" : "text";
          if (mode === "title" && node.type === "inlinemath" && !info.parents.find((p) => p._renderInfo.protectCase))
            node._renderInfo.protectCase = true;
          if (!info.context.inMathMode) {
            if (mode === "title" && node._renderInfo.root && (node.type !== "group" || node.content[0].type !== "macro")) {
              node._renderInfo.protectCase = true;
              if (node.type === "group") {
                caseProtection.present = true;
                caseProtection.intuitive += 1;
              }
            }
            if (node.type === "macro" && typeof node.escapeToken !== "string")
              node.escapeToken = "\\";
            if (node.type === "environment" && node.env === "em")
              node._renderInfo.emph = true;
          }
        });
        if (this.options.raw) {
          switch (mode) {
            case "creatorlist":
              entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((cr) => {
                const { parts, extended } = this.commaSeparatedCreator(cr);
                if (parts.length === 2 && !extended) {
                  return this.trimCreator({ lastName: (0, unified_latex_util_print_raw_1.printRaw)(parts[0]), firstName: (0, unified_latex_util_print_raw_1.printRaw)(parts[1]) });
                }
                if (!parts.length) {
                  const nameparts = this.split(ast, /^$/, /( )/);
                  if (nameparts.length === 2) {
                    return this.trimCreator({
                      lastName: (0, unified_latex_util_print_raw_1.printRaw)(nameparts[1]),
                      firstName: (0, unified_latex_util_print_raw_1.printRaw)(nameparts[0])
                    });
                  }
                }
                return { name: (0, unified_latex_util_print_raw_1.printRaw)(cr) };
              });
              return;
            case "literallist":
              entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((elt) => (0, unified_latex_util_print_raw_1.printRaw)(elt));
              return;
            default:
              entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
              return;
          }
        }
        (0, unified_latex_util_visit_1.visit)(ast, (nodes, info) => {
          var _a;
          let node;
          const compacted = [];
          let inif = 0;
          while (nodes.length) {
            if (node = this.ligature(nodes)) {
              compacted.push(node);
              continue;
            }
            node = nodes.shift();
            if (node.type === "macro" && node.content === "ifdefined") {
              inif += 1;
              continue;
            } else if (node.type === "macro" && node.content === "else") {
              continue;
            } else if (node.type === "macro" && node.content === "fi") {
              inif = Math.max(inif - 1, 0);
              continue;
            } else if (inif) {
              continue;
            }
            const nargs = node.type === "macro" ? narguments[node.content] || narguments[`${info.context.inMathMode ? "math" : "text"}	${node.content}`] : 0;
            if (node.type === "macro" && nargs) {
              node.args = Array(nargs).fill(void 0).map((_i) => this.argument(nodes, node)).filter((arg) => arg);
              if (node.content.match(/^(url|href)$/) && node.args.length) {
                let url = node.args[0].content;
                if (url.length === 1 && url[0].type === "group")
                  url = url[0].content;
                node.args[0] = this.wraparg({ type: "string", content: (0, unified_latex_util_print_raw_1.printRaw)(url), _renderInfo: { mode: url[0]._renderInfo.mode } }, node);
              }
              caseProtection.intuitive -= node.args.filter((arg) => arg.content[0].type === "group" && arg.content[0]._renderInfo.protectCase).length;
            } else if (node.type === "macro" && node.content.match(/^[a-z]+$/i) && ((_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.type) === "whitespace") {
              nodes.shift();
            }
            compacted.push(node);
          }
          if (!info.context.inMathMode) {
            for (const [macro, markup] of Object.entries({ em: "emph", it: "emph", sl: "emph", bf: "bold", sc: "smallCaps", tt: "code" })) {
              if (info.parents.find((p) => p._renderInfo[markup]))
                continue;
              compacted.forEach((markup_node, i) => {
                if (markup_node.type === "macro" && markup_node.content === macro) {
                  compacted.slice(i + 1).forEach((n) => n._renderInfo[markup] = true);
                }
              });
            }
          }
          nodes.push(...compacted);
        }, { test: Array.isArray, includeArrays: true });
        (0, unified_latex_util_replace_1.replaceNode)(ast, (node, _info) => {
          if (node.type !== "macro")
            return;
          if (node.escapeToken && unicode2latex_1.combining.tounicode[node.content]) {
            let arg;
            if (!node.args || node.args.length === 0 || node.args[0].content.length === 0) {
              arg = { type: "string", content: " ", _renderInfo: {} };
            } else if (node.args.length !== 1 || node.args[0].content.length !== 1) {
              return;
            } else {
              arg = node.args[0].content[0];
            }
            if (arg.type === "group") {
              switch (arg.content.length) {
                case 0:
                  arg = { type: "string", content: " ", _renderInfo: {} };
                  break;
                case 1:
                  arg = arg.content[0];
                  break;
                default:
                  return;
              }
            }
            switch (arg.type) {
              case "verbatim":
              case "string":
                return { type: "string", content: `${arg.content}${unicode2latex_1.combining.tounicode[node.content]}`, _renderInfo: {} };
              default:
                return;
            }
          }
          let latex = `${node.escapeToken}${node.content}`;
          latex += (node.args || []).map((arg) => (0, unified_latex_util_print_raw_1.printRaw)(this.argtogroup(arg))).join("");
          if (latex in unicode2latex_1.latex2unicode)
            return { type: "string", content: latex2unicode(latex, node), _renderInfo: {} };
        });
        switch (mode) {
          case "creatorlist":
            entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((cr) => this.parseCreator(cr)).filter((cr) => Object.keys(cr).length);
            break;
          case "literallist":
            entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/).map((elt) => this.stringify(elt, { mode: "literal" }).trim());
            break;
          default:
            entry.fields[field] = this.stringField(
              field,
              this.stringify(ast, { mode }),
              mode,
              this.options.sentenceCase.guess
              // && (!caseProtection.present || caseProtection.intuitive > 0)
            );
            break;
        }
        entry.fields[field] = JSON.parse(JSON.stringify(entry.fields[field], (k, v) => typeof v === "string" ? this.restoreMarkup(v) : v));
      }
      reset(options = {}) {
        var _a;
        this.options = (0, merge_1.merge)(options, {
          caseProtection: "as-needed",
          applyCrossRef: (_a = options.applyCrossRef) !== null && _a !== void 0 ? _a : true,
          fieldMode: {},
          english: exports.English,
          sentenceCase: {
            guess: true,
            preserveQuoted: true
          }
        });
        if (this.options.caseProtection === true)
          this.options.caseProtection = "as-needed";
        if (this.options.verbatimFields)
          this.options.verbatimFields = this.options.verbatimFields.map((f) => typeof f === "string" ? f.toLowerCase() : new RegExp(f.source, f.flags + (f.flags.includes("i") ? "" : "i")));
        if (typeof this.options.english === "boolean")
          this.options.english = this.options.english ? exports.English : [];
        this.options.english = this.options.english.map((langid) => langid.toLowerCase());
        this.fieldMode = Object.entries(exports.FieldMode).reduce((acc, [mode, test]) => {
          const strings = test.filter((fieldname_or_regex) => typeof fieldname_or_regex === "string" && !this.options.fieldMode[fieldname_or_regex]);
          const regexes = test.filter((fieldname_or_regex) => typeof fieldname_or_regex !== "string");
          acc[mode] = [...strings, ...regexes];
          return acc;
        }, {});
        for (const [field, mode] of Object.entries(this.options.fieldMode)) {
          this.fieldMode[mode].unshift(field);
        }
        if (!this.options.removeOuterBraces) {
          this.options.removeOuterBraces = [
            ...FieldAction.removeOuterBraces,
            ...this.fieldMode.title,
            ...this.fieldMode.verbatim
          ].filter((field) => typeof field === "string");
        }
        this.fallback = options.unsupported === "ignore" ? (_node, _tex) => "" : options.unsupported;
        this.bib = {
          errors: [],
          entries: [],
          comments: [],
          strings: {},
          preamble: [],
          jabref: null
        };
      }
      reparse(verbatim) {
        let langid = (verbatim.fields.langid || verbatim.fields.hyphenation || "").toLowerCase();
        if (!langid && this.options.languageAsLangid && verbatim.fields.language)
          langid = verbatim.fields.language.toLowerCase();
        this.english = this.options.english.includes(langid);
        const entry = this.current = {
          type: verbatim.type,
          key: verbatim.key,
          fields: {},
          mode: {},
          input: verbatim.input
        };
        let keywords = [];
        try {
          for (let [field, value] of Object.entries(verbatim.fields)) {
            if (!value.trim())
              continue;
            if (field.match(/^keywords([+]duplicate-\d+)?$/))
              field = "keywords";
            this.field(entry, field, value);
            if (field === "keywords") {
              keywords = [...keywords, ...entry.fields.keywords.split(/\s*[,;]\s*/)].map((k) => k.trim()).filter((k) => k);
              delete entry.fields.keywords;
            }
            if (!this.options.raw && typeof entry.fields[field] === "string") {
              entry.fields[field] = entry.fields[field].trim();
              if (field === "month")
                entry.fields[field] = Month[entry.fields[field].toLowerCase()] || entry.fields[field];
            }
          }
          if (keywords.length) {
            entry.fields.keywords = [...new Set(keywords)].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            entry.mode.keywords = "verbatimlist";
          }
          this.bib.entries.push(entry);
        } catch (err) {
          this.bib.errors.push({ error: `${err.message}
${entry.input}`, input: entry.input });
        }
      }
      content(tex) {
        const entry = { key: "", type: "", fields: {}, mode: {}, input: tex };
        const english = this.english;
        this.english = false;
        this.field(entry, "tex", tex);
        this.english = english;
        return entry.fields.tex;
      }
      prep(base) {
        for (const preamble of base.preambles) {
          try {
            this.content(preamble);
          } catch (err) {
          }
        }
        for (const [k, v] of Object.entries(base.strings)) {
          this.bib.strings[k] = this.content(v);
        }
      }
      finalize(base) {
        var _a;
        if (this.options.applyCrossRef) {
          const entries = {};
          for (const entry of this.bib.entries) {
            if (entry.key)
              entries[entry.key.toUpperCase()] = entry;
          }
          const order = [];
          for (const entry of this.bib.entries) {
            if (!entry.key || typeof entry.fields.crossref !== "string")
              continue;
            const crossref = entry.fields.crossref.toUpperCase();
            if (!entries[crossref])
              continue;
            const key = entry.key.toUpperCase();
            if (!order.includes(crossref))
              order.unshift(crossref);
            if (!order.includes(key))
              order.push(key);
          }
          const add = (obj, kind, field) => {
            obj[kind] = [.../* @__PURE__ */ new Set([...obj[kind], field])].sort();
          };
          for (const key of order) {
            const child = entries[key.toUpperCase()];
            const parent = entries[(_a = child.fields.crossref) === null || _a === void 0 ? void 0 : _a.toUpperCase()];
            if (!parent)
              continue;
            child.crossref = child.crossref || { donated: [], inherited: [] };
            parent.crossref = parent.crossref || { donated: [], inherited: [] };
            for (const mappings of [crossref_json_1.default[child.type], crossref_json_1.default["*"]].filter((m) => m)) {
              for (const mapping of [mappings[parent.type], mappings["*"]].filter((m) => m)) {
                for (const [childfield, parentfield] of Object.entries(mapping)) {
                  if (!child.fields[childfield] && parent.fields[parentfield]) {
                    child.fields[childfield] = parent.fields[parentfield];
                    add(child.crossref, "inherited", childfield);
                    add(parent.crossref, "donated", parentfield);
                  }
                }
                for (const field of fields_json_1.default[child.type] || []) {
                  if (FieldAction.noCrossRef.includes(field))
                    continue;
                  if (!child.fields[field] && parent.fields[field]) {
                    child.fields[field] = parent.fields[field];
                    add(child.crossref, "inherited", field);
                    add(parent.crossref, "donated", field);
                  }
                }
              }
            }
          }
          for (const entry of this.bib.entries) {
            if (entry.crossref && !entry.crossref.donated.length && !entry.crossref.inherited.length)
              delete entry.crossref;
          }
        }
        const { comments, jabref } = JabRef.parse(base.comments);
        this.bib.comments = comments;
        this.bib.jabref = jabref;
        this.bib.preamble = base.preambles;
        this.bib.errors = [...base.errors, ...this.bib.errors];
      }
      parse(input, options = {}) {
        this.reset(options);
        const base = bibtex.parse(input, { strings: options.strings });
        this.prep(base);
        for (const entry of base.entries) {
          this.reparse(entry);
        }
        this.finalize(base);
        return this.bib;
      }
      async parseAsync(input, options = {}) {
        this.reset(options);
        const base = await bibtex.promises.parse(input, { strings: options.strings });
        this.prep(base);
        let n = 1;
        for (const entry of base.entries) {
          this.reparse(entry);
          if (n++ % 1e3 === 0)
            await (0, yield_1.playnice)();
        }
        this.finalize(base);
        return this.bib;
      }
    };
    function parse(input, options = {}) {
      const parser = new BibTeXParser();
      return parser.parse(input, options);
    }
    exports.parse = parse;
    async function parseAsync(input, options = {}) {
      const parser = new BibTeXParser();
      return await parser.parseAsync(input, options);
    }
    exports.parseAsync = parseAsync;
  }
});
export default require_bibtex_parser();
//# sourceMappingURL=@retorquere_bibtex-parser.js.map
