{
  "version": 3,
  "sources": ["../../../../node_modules/smob/src/constants.ts", "../../../../node_modules/smob/src/utils/check.ts", "../../../../node_modules/smob/src/utils/array.ts", "../../../../node_modules/smob/src/utils/clone.ts", "../../../../node_modules/smob/src/utils/object.ts", "../../../../node_modules/smob/src/utils/options.ts", "../../../../node_modules/smob/src/module.ts", "../../../../node_modules/smob/src/presets.ts"],
  "sourcesContent": ["export enum PriorityName {\n    LEFT = 'left',\n    RIGHT = 'right',\n}\n", "export function isObject(item: unknown) : item is Record<string, any> {\n    return (\n        !!item &&\n        typeof item === 'object' &&\n        !Array.isArray(item)\n    );\n}\n\nexport function isSafeKey(key: string) : boolean {\n    return key !== '__proto__' &&\n        key !== 'prototype' &&\n        key !== 'constructor';\n}\n\nexport function isEqual(x: any, y: any): boolean {\n    if (Object.is(x, y)) return true;\n\n    if (x instanceof Date && y instanceof Date) {\n        return x.getTime() === y.getTime();\n    }\n\n    if (x instanceof RegExp && y instanceof RegExp) {\n        return x.toString() === y.toString();\n    }\n\n    if (\n        isObject(x) &&\n        isObject(y)\n    ) {\n        const keysX = Reflect.ownKeys(x) as string[];\n        const keysY = Reflect.ownKeys(y) as string[];\n        if (keysX.length !== keysY.length) {\n            return false;\n        }\n\n        for (let i = 0; i < keysX.length; i++) {\n            const key = keysX[i];\n            if (!Reflect.has(y, key) || !isEqual(x[key], y[key])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (\n        Array.isArray(x) &&\n        Array.isArray(y)\n    ) {\n        if (x.length !== y.length) {\n            return false;\n        }\n\n        for (let i = 0; i < x.length; i++) {\n            if (!isEqual(x[i], y[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n", "import { isEqual } from './check';\n\nexport function distinctArray<T = any>(arr: T[]) : T[] {\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = arr.length - 1; j > i; j--) {\n            if (isEqual(arr[i], arr[j])) {\n                arr.splice(j, 1);\n            }\n        }\n    }\n\n    return arr;\n}\n", "import { isObject } from './check';\n\n/* istanbul ignore next */\nconst gT = (() => {\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof self !== 'undefined') {\n        // eslint-disable-next-line no-restricted-globals\n        return self;\n    }\n\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n\n    throw new Error('unable to locate global object');\n})();\n\nexport function polyfillClone<T>(input: T) {\n    const map = new WeakMap();\n\n    const fn = <A>(value: A) : A => {\n        if (Array.isArray(value)) {\n            if (map.has(value)) {\n                return map.get(value);\n            }\n\n            const cloned = [] as A;\n            map.set(value, cloned);\n\n            value.map((el) => (cloned as any[]).push(fn(el)));\n\n            return cloned;\n        }\n\n        if (isObject(value)) {\n            if (map.has(value)) {\n                return map.get(value);\n            }\n\n            const output = {} as A;\n            const keys = Object.keys(value);\n\n            map.set(value, output);\n            for (let i = 0; i < keys.length; i++) {\n                output[keys[i] as keyof A] = fn(value[keys[i]]);\n            }\n\n            return output;\n        }\n\n        return value;\n    };\n\n    return fn(input);\n}\n\n/* istanbul ignore next */\nexport function clone<T>(value: T) : T {\n    if (gT.structuredClone) {\n        return gT.structuredClone(value);\n    }\n\n    /* istanbul ignore next */\n    return polyfillClone(value);\n}\n", "// eslint-disable-next-line @typescript-eslint/ban-types\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n", "import { PriorityName } from '../constants';\nimport type { Options, OptionsInput } from '../type';\n\nexport function buildOptions(options: OptionsInput = {}) : Options {\n    options.array = options.array ?? true;\n    options.arrayDistinct = options.arrayDistinct ?? false;\n    options.clone = options.clone ?? false;\n    options.inPlace = options.inPlace ?? false;\n    options.priority = options.priority || PriorityName.LEFT;\n    options.arrayPriority = options.arrayPriority || options.priority;\n\n    return options as Options;\n}\n\nexport function togglePriority(priority: `${PriorityName}`) {\n    return priority === PriorityName.LEFT ?\n        `${PriorityName.RIGHT}` :\n        `${PriorityName.LEFT}`;\n}\n", "import { PriorityName } from './constants';\nimport type {\n    Merger, MergerContext,\n    MergerResult,\n    MergerSource,\n    MergerSourceUnwrap,\n    OptionsInput,\n} from './type';\n\nimport {\n    buildOptions,\n    clone,\n    distinctArray,\n    hasOwnProperty,\n    isObject,\n    isSafeKey, togglePriority,\n} from './utils';\n\nfunction baseMerger<B extends MergerSource[]>(\n    context: MergerContext,\n    ...sources: B\n) : MergerResult<B> {\n    let target : MergerSourceUnwrap<B>;\n    let source : MergerSourceUnwrap<B> | undefined;\n\n    let { priority } = context.options;\n    if (sources.length >= 2) {\n        if (\n            Array.isArray(sources.at(0)) &&\n            Array.isArray(sources.at(-1))\n        ) {\n            priority = context.options.arrayPriority;\n        }\n    }\n\n    if (priority === PriorityName.RIGHT) {\n        target = sources.pop() as MergerSourceUnwrap<B>;\n        source = sources.pop() as MergerSourceUnwrap<B>;\n    } else {\n        target = sources.shift() as MergerSourceUnwrap<B>;\n        source = sources.shift() as MergerSourceUnwrap<B>;\n    }\n\n    if (!source) {\n        if (\n            Array.isArray(target) &&\n            context.options.arrayDistinct\n        ) {\n            return distinctArray(target) as MergerResult<B>;\n        }\n\n        return target as MergerResult<B>;\n    }\n\n    if (\n        Array.isArray(target) &&\n        Array.isArray(source)\n    ) {\n        target.push(...source as MergerSource[]);\n\n        if (context.options.arrayPriority === PriorityName.RIGHT) {\n            return baseMerger(\n                context,\n                ...sources,\n                target,\n            ) as MergerResult<B>;\n        }\n\n        return baseMerger(\n            context,\n            target,\n            ...sources,\n        ) as MergerResult<B>;\n    }\n\n    context.map.set(source, true);\n\n    if (\n        isObject(target) &&\n        isObject(source)\n    ) {\n        const keys = Object.keys(source);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i] as (keyof MergerSourceUnwrap<B>);\n\n            if (hasOwnProperty(target, key)) {\n                if (!isSafeKey(key as string)) {\n                    continue;\n                }\n\n                if (context.options.strategy) {\n                    const applied = context.options.strategy(target, key as string, source[key]);\n                    if (typeof applied !== 'undefined') {\n                        continue;\n                    }\n                }\n\n                if (\n                    isObject(target[key]) &&\n                    isObject(source[key])\n                ) {\n                    if (context.map.has(source[key])) {\n                        const sourceKeys = Object.keys(source[key] as Record<string, any>);\n                        for (let j = 0; j < sourceKeys.length; j++) {\n                            if (\n                                isSafeKey(sourceKeys[j]) &&\n                                !hasOwnProperty(target[key] as Record<string, any>, sourceKeys[j])\n                            ) {\n                                (target[key] as Record<string, any>)[sourceKeys[j]] = (source[key] as Record<string, any>)[sourceKeys[j]];\n                            }\n                        }\n\n                        continue;\n                    }\n\n                    if (context.options.priority === PriorityName.RIGHT) {\n                        target[key] = baseMerger(\n                            context,\n                            source[key] as MergerSource,\n                            target[key] as MergerSource,\n                        ) as MergerSourceUnwrap<B>[keyof MergerSourceUnwrap<B>];\n                    } else {\n                        target[key] = baseMerger(\n                            context,\n                            target[key] as MergerSource,\n                            source[key] as MergerSource,\n                        ) as MergerSourceUnwrap<B>[keyof MergerSourceUnwrap<B>];\n                    }\n\n                    continue;\n                }\n\n                if (\n                    context.options.array &&\n                    Array.isArray(target[key]) &&\n                    Array.isArray(source[key])\n                ) {\n                    const arrayPriority = context.options.priority !== context.options.arrayPriority ?\n                        togglePriority(context.options.arrayPriority) :\n                        context.options.arrayPriority;\n\n                    switch (arrayPriority) {\n                        case PriorityName.LEFT:\n                            Object.assign(target, {\n                                [key]: baseMerger(context, target[key] as MergerSource, source[key] as MergerSource),\n                            });\n                            break;\n                        case PriorityName.RIGHT:\n                            Object.assign(target, {\n                                [key]: baseMerger(context, source[key] as MergerSource, target[key] as MergerSource),\n                            });\n                            break;\n                    }\n                }\n            } else {\n                Object.assign(target, {\n                    [key]: source[key],\n                });\n            }\n        }\n    }\n\n    context.map = new WeakMap();\n\n    if (context.options.priority === PriorityName.RIGHT) {\n        return baseMerger(context, ...sources, target) as MergerResult<B>;\n    }\n\n    return baseMerger(context, target, ...sources) as MergerResult<B>;\n}\n\nexport function createMerger(input?: OptionsInput) : Merger {\n    const options = buildOptions(input);\n\n    return <B extends MergerSource[]>(\n        ...sources: B\n    ) : MergerResult<B> => {\n        if (!sources.length) {\n            throw new SyntaxError('At least one input element is required.');\n        }\n\n        const ctx : MergerContext = {\n            options,\n            map: new WeakMap<any, any>(),\n        };\n\n        if (options.clone) {\n            return baseMerger(ctx, ...clone(sources));\n        }\n\n        if (!options.inPlace) {\n            if (\n                Array.isArray(sources.at(0)) &&\n                options.arrayPriority === PriorityName.LEFT\n            ) {\n                sources.unshift([]);\n                return baseMerger(ctx, ...sources);\n            }\n\n            if (\n                Array.isArray(sources.at(-1)) &&\n                options.arrayPriority === PriorityName.RIGHT\n            ) {\n                sources.push([]);\n                return baseMerger(ctx, ...sources);\n            }\n\n            if (options.priority === PriorityName.LEFT) {\n                sources.unshift({});\n            } else {\n                sources.push({});\n            }\n        }\n\n        return baseMerger(ctx, ...sources);\n    };\n}\n\nexport const merge = createMerger();\n", "import { createMerger } from './module';\nimport type { MergerResult } from './type';\n\n/**\n * Assign source attributes to a target object.\n *\n * @param target\n * @param sources\n */\nexport function assign<A extends Record<string, any>, B extends Record<string, any>[]>(\n    target: A,\n    ...sources: B\n) : A & MergerResult<B> {\n    return createMerger({\n        inPlace: true,\n        priority: 'left',\n        array: false,\n    })(target, ...sources) as A & MergerResult<B>;\n}\n"],
  "mappings": "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",
  "names": ["PriorityName", "isObject", "item", "Array", "isArray", "isSafeKey", "key", "isEqual", "x", "y", "Object", "is", "Date", "getTime", "RegExp", "toString", "keysX", "Reflect", "ownKeys", "keysY", "length", "i", "has", "distinctArray", "arr", "j", "splice", "gT", "globalThis", "self", "window", "global", "Error", "polyfillClone", "input", "map", "WeakMap", "fn", "value", "get", "cloned", "set", "el", "push", "output", "keys", "clone", "structuredClone", "hasOwnProperty", "obj", "prop", "prototype", "call", "buildOptions", "options", "array", "arrayDistinct", "inPlace", "priority", "LEFT", "arrayPriority", "togglePriority", "RIGHT", "baseMerger", "context", "sources", "target", "source", "at", "pop", "shift", "strategy", "applied", "sourceKeys", "assign", "createMerger", "SyntaxError", "ctx", "unshift", "merge"]
}
